// Language system
const languages = {
    'zh-TW': {
        // Header
        'sortToggleText': 'æ’åºç…§ç‰‡åˆ°æ–‡ä»¶å¤¾',
        'languageToggleText': 'ä¸­æ–‡ç¹é«”',
        
        // Table headers
        'defectNo': 'ç¼ºé™·ç·¨è™Ÿ',
        'inspectionNo': 'æª¢æŸ¥ç·¨è™Ÿ',
        'imminentDanger': 'ç·Šæ€¥å±éšª',
        'inspectionDate': 'æª¢æŸ¥æ—¥æœŸ',
        'floor': 'æ¨“å±¤',
        'areaName': 'å€åŸŸåç¨±',
        'roomNo': 'æˆ¿é–“ç·¨è™Ÿ',
        'photoNumbers': 'ç…§ç‰‡ç·¨è™Ÿ',
        'categories': 'åˆ†é¡',
        'defectType': 'ç¼ºé™·é¡å‹',
        'description': 'æè¿°',
        'remedialWorks': 'ä¿®å¾©å·¥ç¨‹',
        'action': 'æ“ä½œ',
        
        // Labels table headers
        'labelInspectionNo': 'æª¢æŸ¥ç·¨è™Ÿ',
        'labelInspectionDate': 'æª¢æŸ¥æ—¥æœŸ',
        'labelFloor': 'æ¨“å±¤',
        'labelAreaName': 'å€åŸŸåç¨±',
        'labelRoomNo': 'æˆ¿é–“ç·¨è™Ÿ',
        'labelCategoryA': 'åˆ†é¡A',
        'labelCategoryB': 'åˆ†é¡B',
        'labelCategoryC': 'åˆ†é¡C',
        'labelCategoryD': 'åˆ†é¡D',
        'labelCategoryE': 'åˆ†é¡E',
        'labelCategoryF': 'åˆ†é¡F',
        'labelCategoryG': 'åˆ†é¡G',
        'labelCategoryH': 'åˆ†é¡H',
        'labelCategoryI': 'åˆ†é¡I',
        'labelCategoryJ': 'åˆ†é¡J',
        'labelDefects': 'ç¼ºé™·',
        
        // Buttons
        'submit': 'æäº¤',
        'delete': 'åˆªé™¤',
        'save': 'ä¿å­˜',
        'cancel': 'å–æ¶ˆ',
        'close': 'é—œé–‰',
        'add': 'æ·»åŠ ',
        'edit': 'ç·¨è¼¯',
        'assign': 'åˆ†é…',
        'create': 'å‰µå»º',
        'update': 'æ›´æ–°',
        
        // Messages
        'dataSubmitted': 'æ•¸æ“šå·²æäº¤åˆ°æ¨™ç±¤è©³ç´°è¡¨æ ¼ï¼',
        'defectDeleted': 'ç¼ºé™·è¨˜éŒ„å·²åˆªé™¤',
        'labelDeleted': 'æ¨™ç±¤è¨˜éŒ„å·²åˆªé™¤',
        'recordUpdated': 'è¨˜éŒ„å·²æ›´æ–°',
        'recordCreated': 'è¨˜éŒ„å·²å‰µå»º',
        'confirmDelete': 'ç¢ºå®šè¦åˆªé™¤é€™å€‹è¨˜éŒ„å—ï¼Ÿ',
        'noData': 'æš«ç„¡æ•¸æ“š',
        'loading': 'è¼‰å…¥ä¸­...',
        'success': 'æˆåŠŸ',
        'error': 'éŒ¯èª¤',
        'warning': 'è­¦å‘Š',
        'info': 'ä¿¡æ¯',
        
        // Form labels
        'inspectionNoLabel': 'æª¢æŸ¥ç·¨è™Ÿ',
        'inspectionDateLabel': 'æª¢æŸ¥æ—¥æœŸ',
        'floorLabel': 'æ¨“å±¤',
        'areaNameLabel': 'å€åŸŸåç¨±',
        'roomNoLabel': 'æˆ¿é–“ç·¨è™Ÿ',
        'defectNoLabel': 'ç¼ºé™·ç·¨è™Ÿ',
        'imminentDangerLabel': 'ç·Šæ€¥å±éšª',
        'photoNumbersLabel': 'ç…§ç‰‡ç·¨è™Ÿ',
        'categoriesLabel': 'åˆ†é¡',
        'defectTypeLabel': 'ç¼ºé™·é¡å‹',
        'descriptionLabel': 'æè¿°',
        'remedialWorksLabel': 'ä¿®å¾©å·¥ç¨‹',
        
        // Modal titles
        'defectForm': 'ç¼ºé™·è¡¨å–®',
        'labelForm': 'æ¨™ç±¤è¡¨å–®',
        'defectsDetail': 'ç¼ºé™·è©³ç´°',
        'labelsDetail': 'æ¨™ç±¤è©³ç´°',
        
        // Status
        'yes': 'æ˜¯',
        'no': 'å¦',
        'assigned': 'å·²åˆ†é…',
        'unassigned': 'æœªåˆ†é…',
        'submitted': 'å·²æäº¤',
        'pending': 'å¾…è™•ç†',
        'defectRenumbered': 'ç¼ºé™·ç·¨è™Ÿå·²é‡æ–°æ’åˆ—',
        'defectDeleted': 'ç¼ºé™·è¨˜éŒ„å·²åˆªé™¤',
        'labelDeleted': 'æ¨™ç±¤è¨˜éŒ„å·²åˆªé™¤',
        
        // HTML attributes and placeholders
        'openFloorPlan': 'é–‹å•Ÿæ¨“å±¤å¹³é¢åœ–',
        'sortPhotosToFolder': 'æ’åºç…§ç‰‡åˆ°æ–‡ä»¶å¤¾',
        'languageSwitch': 'èªè¨€åˆ‡æ›',
        'enterInspectionNumber': 'è¼¸å…¥æª¢æŸ¥ç·¨è™Ÿ',
        'enterFloor': 'è¼¸å…¥æ¨“å±¤',
        'enterAreaName': 'è¼¸å…¥å€åŸŸåç¨±',
        'enterRoomNumber': 'è¼¸å…¥æˆ¿é–“ç·¨è™Ÿ',
        'photoZoomControl': 'ç…§ç‰‡ç¸®æ”¾æ§åˆ¶',
        'submitToTable': 'æäº¤åˆ°è¡¨æ ¼',
        'clearAllCategories': 'æ¸…é™¤æ‰€æœ‰åˆ†é¡',
        'allLabelsDetail': 'æ‰€æœ‰æ¨™ç±¤è©³ç´°',
        'allDefectsDetail': 'æ‰€æœ‰ç¼ºé™·è©³ç´°',
        'imminentDangerSwitch': 'ç·Šæ€¥å±éšªé–‹é—œ',
        'enterInspectionDate': 'è¼¸å…¥æª¢æŸ¥æ—¥æœŸ',
        'autoAssignedFromDefectSummary': 'å¾ç¼ºé™·æ‘˜è¦è‡ªå‹•åˆ†é…',
        'selectedPhotoNumbers': 'é¸ä¸­çš„ç…§ç‰‡ç·¨è™Ÿ',
        'selectCategory': 'é¸æ“‡åˆ†é¡',
        'enterDefectTypeDirectly': 'ç›´æ¥è¼¸å…¥ç¼ºé™·é¡å‹æˆ–å¾ä¸‹æ‹‰é¸å–®é¸æ“‡',
        'searchDefectTypes': 'æœç´¢ç¼ºé™·é¡å‹...',
        'clearSearch': 'æ¸…é™¤æœç´¢',
        'enterDescription': 'è¼¸å…¥æè¿°',
        'selectCondition': 'é¸æ“‡æ¢ä»¶',
        'enterHumidity': 'è¼¸å…¥æ¿•åº¦',
        'enterMoistureContent': 'è¼¸å…¥æ°´åˆ†å«é‡',
        'enterChlorideContent': 'è¼¸å…¥æ°¯åŒ–ç‰©å«é‡',
        'enterCarbonationDetails': 'è¼¸å…¥ç¢³åŒ–è©³æƒ…',
        'enterRemedialWorks': 'è¼¸å…¥ä¿®å¾©å·¥ç¨‹',
        'enterPreventiveWorks': 'è¼¸å…¥é é˜²æ€§å·¥ç¨‹',
        'enterRemarks': 'è¼¸å…¥å‚™è¨»',
        'close': 'é—œé–‰',
        'resizePhoto': 'èª¿æ•´ç…§ç‰‡å¤§å°',
        'photoPreview': 'ç…§ç‰‡é è¦½',
        'addPhotos': 'æ·»åŠ ç…§ç‰‡',
        'selectedPhotos': 'å·²é¸æ“‡',
        'photos': 'å¼µç…§ç‰‡',
        'defectForm': 'ç¼ºé™·è¡¨å–®',
        'labelsDetail': 'æ¨™ç±¤è©³ç´°',
        'defectsDetail': 'ç¼ºé™·è©³ç´°',
        'inspectionNo': 'æª¢æŸ¥ç·¨è™Ÿ',
        'inspectionDate': 'æª¢æŸ¥æ—¥æœŸ',
        'floor': 'æ¨“å±¤',
        'areaName': 'å€åŸŸåç¨±',
        'roomNo': 'æˆ¿é–“ç·¨è™Ÿ',
        'defectNo': 'ç¼ºé™·ç·¨è™Ÿ',
        'photoNo': 'ç…§ç‰‡ç·¨è™Ÿ',
        'categories': 'åˆ†é¡',
        'defectType': 'ç¼ºé™·é¡å‹',
        'description': 'æè¿°',
        'existingCondition': 'ç¾æœ‰æ¢ä»¶',
        'humidity': 'æ¿•åº¦',
        'moistureContent': 'æ°´åˆ†å«é‡',
        'chlorideContent': 'æ°¯åŒ–ç‰©å«é‡',
        'carbonationDetails': 'ç¢³åŒ–è©³æƒ…',
        'remedialWorks': 'ä¿®å¾©å·¥ç¨‹',
        'preventiveWorks': 'é é˜²æ€§å·¥ç¨‹',
        'remarks': 'å‚™è¨»',
        'imminentDanger': 'ç·Šæ€¥å±éšª',
        'yes': 'æ˜¯',
        'no': 'å¦',
        'selectFolderToPreviewPhotos': 'é¸æ“‡æ–‡ä»¶å¤¾ä»¥é è¦½ç…§ç‰‡',
        'selectPhotoFolder': 'é¸æ“‡ç…§ç‰‡æ–‡ä»¶å¤¾',
        'pleaseEnterInspectionNumber': 'è«‹å…ˆåœ¨æ¨™é¡Œæ¬„ä½å¡«å¯«æª¢æŸ¥ç·¨è™Ÿï¼Œæ‰èƒ½åˆ†é…ç…§ç‰‡åˆ°åˆ†é¡',
        
        // Section titles
        'assignToCategories': 'åˆ†é…åˆ°åˆ†é¡',
        'inspectionRecords': 'æª¢æŸ¥è¨˜éŒ„',
        'defectSummary': 'ç¼ºé™·æ‘˜è¦',
        'categoriesRecords': 'åˆ†é¡è¨˜éŒ„',
        
        // Inspection Records table headers
        'inspectionNoHeader': 'æª¢æŸ¥ç·¨è™Ÿ',
        'inspectionDateHeader': 'æª¢æŸ¥æ—¥æœŸ',
        'locationHeader': 'ä½ç½®ï¼ˆæ¨“å±¤ã€å€åŸŸåç¨±å’Œæˆ¿é–“ç·¨è™Ÿé †åºï¼‰',
        'categoryAHeader': 'A: å¤–éœ²çµæ§‹é‡‘å±¬ä»¶',
        'categoryBHeader': 'B: çµæ§‹å…ƒç´ ',
        'categoryCHeader': 'C: å¤–éƒ¨å»ºç¯‰å…ƒç´ ',
        'categoryDHeader': 'D: æ‡¸æ›ç‰©ä»¶',
        'categoryEHeader': 'E: é«˜å±¤å…§éƒ¨è£ä¿®',
        'categoryFHeader': 'F: é‡å‹é‡‘å±¬é–€/é–˜é–€',
        'categoryGHeader': 'G: çª—æˆ¶å’Œç»ç’ƒç™¾è‘‰',
        'categoryHHeader': 'H: æ’æ°´å’Œç®¡é“ç³»çµ±',
        'categoryIHeader': 'I: æ¶ˆé˜²å®‰å…¨å…ƒç´ ',
        'categoryJHeader': 'J: ç¼ºé™·',
        
        // Defect Summary table headers
        'defectNoHeader': 'ç¼ºé™·ç·¨è™Ÿ',
        'defectWithImminentDangerHeader': 'ç¼ºé™·ï¼ˆç·Šæ€¥å±éšª æ˜¯/å¦ï¼‰å¾ŒçºŒè¡Œå‹•è¦‹A.5éƒ¨åˆ†',
        'locationsOfDefectsHeader': 'ç¼ºé™·ä½ç½®ï¼ˆæ¨“å±¤ã€å€åŸŸåç¨±å’Œæˆ¿é–“ç·¨è™Ÿé †åºï¼‰',
        'typeOfHighRiskBuildingElementsHeader': 'é«˜é¢¨éšªå»ºç¯‰å…ƒç´ é¡å‹',
        'descriptionConstructionHeader': 'æè¿°/é«˜é¢¨éšªå»ºç¯‰å…ƒç´ æ§‹é€ ',
        'existingConditionHeader': 'é«˜é¢¨éšªå»ºç¯‰å…ƒç´ ç¾æœ‰æ¢ä»¶',
        'defectsDiagnosisHeader': 'ç¼ºé™·è¨ºæ–·å’Œè­˜åˆ¥',
        'relativeHumidityHeader': 'ç¾å ´æª¢æŸ¥æœŸé–“æ¸¬é‡çš„æˆ¿é–“/å€åŸŸç›¸å°æ¿•åº¦',
        'moistureContentHeader': 'åƒ…æ··å‡åœŸçµæ§‹å…ƒç´ çš„æ°´åˆ†å«é‡',
        'chlorideContentHeader': 'æ··å‡åœŸçµæ§‹å…ƒç´ çš„æ°¯åŒ–ç‰©å«é‡',
        'depthExtentCarbonationHeader': 'æ··å‡åœŸçµæ§‹å…ƒç´ çš„ç¢³åŒ–æ·±åº¦å’Œç¯„åœ',
        'scopeExtentRepairHeader': 'å»ºè­°å¾ŒçºŒä¿®å¾©å·¥ç¨‹çš„ç¯„åœå’Œç¨‹åº¦',
        'scopeExtentPreventiveHeader': 'å»ºè­°é é˜²æ€§ç¶­è­·å·¥ç¨‹çš„ç¯„åœå’Œç¨‹åº¦',
        'remarksHeader': 'å‚™è¨»',
        
        // Labels Detail table headers
        'actionsHeader': 'æ“ä½œ',
        'inspectionNoHeaderLabels': 'æª¢æŸ¥ç·¨è™Ÿ',
        'floorHeaderLabels': 'æ¨“å±¤',
        'areaNameHeaderLabels': 'å€åŸŸåç¨±',
        'roomNoHeaderLabels': 'æˆ¿é–“ç·¨è™Ÿ',
        'inspectionDateHeaderLabels': 'æª¢æŸ¥æ—¥æœŸ',
        'categoryAHeaderLabels': 'A: å¤–éœ²çµæ§‹é‡‘å±¬ä»¶',
        'categoryBHeaderLabels': 'B: çµæ§‹å…ƒç´ ',
        'categoryCHeaderLabels': 'C: å¤–éƒ¨å»ºç¯‰å…ƒç´ ',
        'categoryDHeaderLabels': 'D: æ‡¸æ›ç‰©ä»¶',
        'categoryEHeaderLabels': 'E: é«˜å±¤å…§éƒ¨è£ä¿®',
        'categoryFHeaderLabels': 'F: é‡å‹é‡‘å±¬é–€/é–˜é–€',
        'categoryGHeaderLabels': 'G: çª—æˆ¶å’Œç»ç’ƒç™¾è‘‰',
        'categoryHHeaderLabels': 'H: æ’æ°´å’Œç®¡é“ç³»çµ±',
        'categoryIHeaderLabels': 'I: æ¶ˆé˜²å®‰å…¨å…ƒç´ ',
        'categoryJHeaderLabels': 'J: ç¼ºé™·',
        
        // Defects Detail table headers
        'actionsHeaderDefects': 'æ“ä½œ',
        'defectNoHeaderDefects': 'ç¼ºé™·ç·¨è™Ÿ',
        'inspectionNoHeaderDefects': 'æª¢æŸ¥ç·¨è™Ÿ',
        'imminentDangerHeaderDefects': 'ç·Šæ€¥å±éšª',
        'inspectionDateHeaderDefects': 'æª¢æŸ¥æ—¥æœŸ',
        'floorHeaderDefects': 'æ¨“å±¤',
        'areaNameHeaderDefects': 'å€åŸŸåç¨±',
        'roomNoHeaderDefects': 'æˆ¿é–“ç·¨è™Ÿ',
        'photoNumbersHeaderDefects': 'ç…§ç‰‡ç·¨è™Ÿ',
        'categoriesHeaderDefects': 'åˆ†é¡',
        'defectTypeHeaderDefects': 'ç¼ºé™·é¡å‹',
        'descriptionHeaderDefects': 'æè¿°',
        'remedialWorksHeaderDefects': 'ä¿®å¾©å·¥ç¨‹',
        
        // Category names
        'categoryA': 'A: å¤–éœ²çµæ§‹é‡‘å±¬ä»¶',
        'categoryB': 'B: çµæ§‹å…ƒç´ ',
        'categoryC': 'C: å¤–éƒ¨å»ºç¯‰å…ƒç´ ',
        'categoryD': 'D: æ‡¸æ›ç‰©ä»¶',
        'categoryE': 'E: é«˜å±¤å…§éƒ¨è£ä¿®',
        'categoryF': 'F: é‡å‹é‡‘å±¬é–€/é–˜é–€',
        'categoryG': 'G: çª—æˆ¶å’Œç»ç’ƒç™¾è‘‰',
        'categoryH': 'H: æ’æ°´å’Œç®¡é“ç³»çµ±',
        'categoryI': 'I: æ¶ˆé˜²å®‰å…¨å…ƒç´ ',
        'categoryJ': 'J: ç¼ºé™·',
        
        // Category table headers
        'locationNoHeader': 'ä½ç½®ç·¨è™Ÿ',
        'roomNoHeader': 'æˆ¿é–“ç·¨è™Ÿ',
        'photoNoHeader': 'ç…§ç‰‡ç·¨è™Ÿ',
        'defectsHeader': 'ç¼ºé™·',
        
        // Category table titles
        'categoryTableA': 'A: å¤–éœ²çµæ§‹é‡‘å±¬ä»¶',
        'categoryTableB': 'B: çµæ§‹å…ƒç´ ',
        'categoryTableC': 'C: å¤–éƒ¨å»ºç¯‰å…ƒç´ ',
        'categoryTableD': 'D: æ‡¸æ›ç‰©ä»¶',
        'categoryTableE': 'E: é«˜å±¤å…§éƒ¨è£ä¿®',
        'categoryTableF': 'F: é‡å‹é‡‘å±¬é–€/é–˜é–€',
        'categoryTableG': 'G: çª—æˆ¶å’Œç»ç’ƒç™¾è‘‰',
        'categoryTableH': 'H: æ’æ°´å’Œç®¡é“ç³»çµ±',
        'categoryTableI': 'I: æ¶ˆé˜²å®‰å…¨å…ƒç´ ',
        
        // PNE dropdown menu items
        'openDrawingMode': 'é–‹å•Ÿç¹ªåœ–æ¨¡å¼',
        'selectPhotoFolder': 'é¸æ“‡ç…§ç‰‡æ–‡ä»¶å¤¾',
        'openPNEFile': 'é–‹å•ŸPNEæ–‡ä»¶',
        'saveAsPNEFile': 'å¦å­˜ç‚ºPNEæ–‡ä»¶',
        'exportCSV': 'åŒ¯å‡ºCSV',
        'defectsReport': 'ç¼ºé™·å ±å‘Š',
        'photoAssignmentSummary': 'ç…§ç‰‡åˆ†é…æ‘˜è¦',
        
        // Floor plan container
        'openFloorPlan': 'é–‹å•Ÿæ¨“å±¤å¹³é¢åœ–',
        'newFloorPlan': 'æ–°å»ºæ¨“å±¤å¹³é¢åœ–',
        'showDetails': 'é¡¯ç¤ºè©³ç´°ä¿¡æ¯',
        'allLabelsDetail': 'æ‰€æœ‰æ¨™ç±¤è©³ç´°ä¿¡æ¯',
        'allDefectsDetail': 'æ‰€æœ‰ç¼ºé™·è©³ç´°ä¿¡æ¯',
        'clearData': 'æ¸…é™¤æ•¸æ“š',
        'clearAllLabels': 'æ¸…é™¤æ‰€æœ‰æ¨™ç±¤',
        'clearAllDefectMarks': 'æ¸…é™¤æ‰€æœ‰ç¼ºé™·æ¨™è¨˜',
        'clearAllLabelsAndDefectMarks': 'æ¸…é™¤æ‰€æœ‰æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜',
        'exportAsPDF': 'åŒ¯å‡ºç‚ºPDF',
        'zoomTo100AndCenter': 'ç¸®æ”¾è‡³100%ä¸¦å±…ä¸­',
        'close': 'é—œé–‰',
        'previousFloorPlanDataFound': 'ç™¼ç¾ä¹‹å‰çš„æ¨“å±¤å¹³é¢åœ–æ•¸æ“š',
        'clickToUploadPDFFloorPlan': 'é»æ“Šä¸Šå‚³PDFæ¨“å±¤å¹³é¢åœ–',
        'chooseFile': 'é¸æ“‡æ–‡ä»¶',
        'quickLabelMode': 'å¿«é€Ÿæ¨™ç±¤æ¨¡å¼',
        'clickToAddLabel': 'é»æ“Šæ·»åŠ æ¨™ç±¤',
        'clickToAddDefect': 'é»æ“Šæ·»åŠ ç¼ºé™·',
        
        // Previous floor plan elements
        'previousFloorPlanDataFound': 'ç™¼ç¾ä¹‹å‰çš„æ¨“å±¤å¹³é¢åœ–æ•¸æ“š',
        'youHaveLabelDataFromPreviousFloorPlan': 'æ‚¨æœ‰ä¾†è‡ªä¹‹å‰æ¨“å±¤å¹³é¢åœ–çš„æ¨™ç±¤æ•¸æ“šã€‚è¦æŸ¥çœ‹å’Œç®¡ç†é€™äº›æ¨™ç±¤ï¼Œè«‹é–‹å•Ÿç›¸åŒçš„æ¨“å±¤å¹³é¢åœ–æ–‡ä»¶ã€‚',
        'previousFile': 'ä¹‹å‰çš„æ–‡ä»¶ï¼š',
        'openPreviousFloorPlan': 'é–‹å•Ÿä¹‹å‰çš„æ¨“å±¤å¹³é¢åœ–',
        
        // Floor plan header
        'floorPlanTitle': 'æ¨“å±¤å¹³é¢åœ–',
        
        // Detail table containers
        'allLabelsDetailTableContainer': 'æ‰€æœ‰æ¨™ç±¤è©³ç´°è¡¨æ ¼',
        'allDefectsDetailTableContainer': 'æ‰€æœ‰ç¼ºé™·è©³ç´°è¡¨æ ¼',
        
        // Floor plan header
        'drawingMode': 'ç¹ªåœ–æ¨¡å¼',
        'newFloorPlan': 'æ–°å»ºæ¨“å±¤å¹³é¢åœ–',
        'exportAsPDF': 'åŒ¯å‡ºç‚ºPDF',
        'quickLabel': 'å¿«é€Ÿæ¨™ç±¤',
        'doubleClickToPlaceDefectMark': 'é›™æ“Šå¹³é¢åœ–æ”¾ç½®ç¼ºé™·æ¨™è¨˜',
        'labelSize': 'æ¨™ç±¤å¤§å°',
        'defectSize': 'ç¼ºé™·å¤§å°',
        'allLabelsDetail': 'æ‰€æœ‰æ¨™ç±¤è©³ç´°',
        'allDefectsDetail': 'æ‰€æœ‰ç¼ºé™·è©³ç´°',
        'zoomTo100AndCenter': 'ç¸®æ”¾è‡³100%ä¸¦ç½®ä¸­',
        'close': 'é—œé–‰',
        
        // Floor plan content
        'previousFloorPlanDataFound': 'ç™¼ç¾å…ˆå‰çš„æ¨“å±¤å¹³é¢åœ–æ•¸æ“š',
        'previousFloorPlanDataDescription': 'æ‚¨æœ‰ä¾†è‡ªå…ˆå‰æ¨“å±¤å¹³é¢åœ–çš„æ¨™ç±¤æ•¸æ“šã€‚è¦æŸ¥çœ‹å’Œç®¡ç†é€™äº›æ¨™ç±¤ï¼Œè«‹é–‹å•Ÿç›¸åŒçš„æ¨“å±¤å¹³é¢åœ–æª”æ¡ˆã€‚',
        'previousFile': 'å…ˆå‰æª”æ¡ˆï¼š',
        'openPreviousFloorPlan': 'é–‹å•Ÿå…ˆå‰æ¨“å±¤å¹³é¢åœ–',
        'clickToUploadPDFFloorPlan': 'é»æ“Šä¸Šå‚³PDFæ¨“å±¤å¹³é¢åœ–',
        'chooseFile': 'é¸æ“‡æª”æ¡ˆ',
        'doubleClickToPlaceLabel': 'é›™æ“Šå¹³é¢åœ–æ”¾ç½®æ¨™ç±¤',
        
        // Label modal
        'newLabel': 'æ–°å»ºæ¨™ç±¤',
        'inspectionNoRequired': 'æª¢æŸ¥ç·¨è™Ÿ *',
        'floorOptional': 'æ¨“å±¤ï¼ˆå¯é¸ï¼‰',
        'areaNameOptional': 'å€åŸŸåç¨±ï¼ˆå¯é¸ï¼‰',
        'roomNoOptional': 'æˆ¿é–“ç·¨è™Ÿï¼ˆå¯é¸ï¼‰',
        'inspectionDateOptional': 'æª¢æŸ¥æ—¥æœŸï¼ˆå¯é¸ï¼‰',
        'enterFloorNumber': 'è¼¸å…¥æ¨“å±¤ç·¨è™Ÿ',
        'enterAreaName': 'è¼¸å…¥å€åŸŸåç¨±',
        'enterRoomNumber': 'è¼¸å…¥æˆ¿é–“ç·¨è™Ÿ',
        'onlyInspectionNoRequired': '* åªéœ€è¦æª¢æŸ¥ç·¨è™Ÿ',
        'otherFieldsOptional': 'å…¶ä»–æ¬„ä½ç‚ºå¯é¸ï¼Œå¯ç¨å¾Œå¡«å¯«',
        'cancel': 'å–æ¶ˆ',
        'create': 'å»ºç«‹',
        'saveAndAssignToNewRecord': 'å„²å­˜ä¸¦æŒ‡æ´¾è‡³æ–°è¨˜éŒ„',
        
        // Quick label messages
        'quickLabelModeDisabled': 'å¿«é€Ÿæ¨™ç±¤æ¨¡å¼å·²åœç”¨',
        
        // Session restore modal
        'restorePreviousSession': 'æ¢å¾©å…ˆå‰çš„æœƒè©±ï¼Ÿ',
        'sessionRestoreDescription': 'æˆ‘å€‘ç™¼ç¾äº†å…ˆå‰å„²å­˜çš„æ•¸æ“šå’Œè¨­ç½®ã€‚æ‚¨æƒ³è¦ç¾åœ¨é–‹å•Ÿå®ƒå€‘ï¼Œé‚„æ˜¯å¾ç©ºç™½é é¢é–‹å§‹ï¼Ÿ',
        'previousFloorPlanPDFAndLabels': 'å…ˆå‰çš„æ¨“å±¤å¹³é¢åœ–PDFå’Œæ¨™ç±¤',
        'previouslyLoadedPhotosAndAssignments': 'å…ˆå‰è¼‰å…¥çš„ç…§ç‰‡å’ŒæŒ‡æ´¾',
        'defectEntriesAndViewState': 'ç¼ºé™·æ¢ç›®å’Œæª¢è¦–ç‹€æ…‹',
        'previousTaskData': 'å…ˆå‰çš„ä»»å‹™æ•¸æ“š',
        'startFresh': 'é‡æ–°é–‹å§‹',
        'openPrevious': 'é–‹å•Ÿå…ˆå‰',
        
        // Loading previous data modal
        'loadingPreviousData': 'æ­£åœ¨è¼‰å…¥å…ˆå‰çš„æ•¸æ“š',
        'loadingPreviousDataDescription': 'è«‹ç¨å€™ï¼Œæˆ‘å€‘æ­£åœ¨æ¢å¾©æ‚¨å…ˆå‰çš„æœƒè©±...',
        'loadingFloorPlanPDF': 'æ­£åœ¨è¼‰å…¥æ¨“å±¤å¹³é¢åœ–PDF...',
        'loadingPhotos': 'æ­£åœ¨è¼‰å…¥ç…§ç‰‡...',
        'loadingInspectionData': 'æ­£åœ¨è¼‰å…¥æª¢æŸ¥æ•¸æ“š...',
        
        // Task display
        'taskDisplay': 'ä»»å‹™é¡¯ç¤º',
        'taskEntries': 'ç•¶å‰ä»»å‹™',
        'currentTask': 'ç•¶å‰ä»»å‹™',
        'taskName': 'ä»»å‹™åç¨±',
        'taskLocation': 'ä½ç½®',
        'taskStartDate': 'é–‹å§‹æ—¥æœŸ',
        'taskTargetDate': 'ç›®æ¨™å®Œæˆæ—¥æœŸ',
        'taskDescription': 'æè¿°ï¼ˆå¯é¸ï¼‰',
        'taskSaved': 'ä»»å‹™ä¿å­˜æˆåŠŸ',
        
        // Start Fresh Overlay
        'startFreshTitle': 'æº–å‚™é‡æ–°é–‹å§‹ï¼Ÿ',
        'startFreshDescription': 'é¸æ“‡æ‚¨æƒ³è¦é–‹å§‹æ–°å°ˆæ¡ˆçš„æ–¹å¼ï¼š',
        'startNewTask': 'é–‹å§‹æ–°ä»»å‹™',
        'startNewTaskDescription': 'å‰µå»ºæ–°ä»»å‹™ä¸¦é–‹å§‹å·¥ä½œ',
        'openPNEFileDescription': 'è¼‰å…¥ç¾æœ‰å°ˆæ¡ˆæª”æ¡ˆ'
    },
    'en-GB': {
        // Header
        'sortToggleText': 'Sorting photo to folder',
        'languageToggleText': 'English',
        
        // Table headers
        'defectNo': 'Defect No.',
        'inspectionNo': 'Inspection No.',
        'imminentDanger': 'Imminent Danger',
        'inspectionDate': 'Inspection Date',
        'floor': 'Floor',
        'areaName': 'Area Name',
        'roomNo': 'Room No.',
        'photoNumbers': 'Photo Numbers',
        'categories': 'Categories',
        'defectType': 'Defect Type',
        'description': 'Description',
        'remedialWorks': 'Remedial Works',
        'action': 'Action',
        
        // Labels table headers
        'labelInspectionNo': 'Inspection No.',
        'labelInspectionDate': 'Inspection Date',
        'labelFloor': 'Floor',
        'labelAreaName': 'Area Name',
        'labelRoomNo': 'Room No.',
        'labelCategoryA': 'Category A',
        'labelCategoryB': 'Category B',
        'labelCategoryC': 'Category C',
        'labelCategoryD': 'Category D',
        'labelCategoryE': 'Category E',
        'labelCategoryF': 'Category F',
        'labelCategoryG': 'Category G',
        'labelCategoryH': 'Category H',
        'labelCategoryI': 'Category I',
        'labelCategoryJ': 'Category J',
        'labelDefects': 'Defects',
        
        // Buttons
        'submit': 'Submit',
        'delete': 'Delete',
        'save': 'Save',
        'cancel': 'Cancel',
        'close': 'Close',
        'add': 'Add',
        'edit': 'Edit',
        'assign': 'Assign',
        'create': 'Create',
        'update': 'Update',
        
        // Messages
        'dataSubmitted': 'Data submitted to labels detail table!',
        'defectDeleted': 'Defect record deleted',
        'labelDeleted': 'Label record deleted',
        'recordUpdated': 'Record updated',
        'recordCreated': 'Record created',
        'confirmDelete': 'Are you sure you want to delete this record?',
        'noData': 'No data available',
        'loading': 'Loading...',
        'success': 'Success',
        'error': 'Error',
        'warning': 'Warning',
        'info': 'Information',
        
        // Form labels
        'inspectionNoLabel': 'Inspection No.',
        'inspectionDateLabel': 'Inspection Date',
        'floorLabel': 'Floor',
        'areaNameLabel': 'Area Name',
        'roomNoLabel': 'Room No.',
        'defectNoLabel': 'Defect No.',
        'imminentDangerLabel': 'Imminent Danger',
        'photoNumbersLabel': 'Photo Numbers',
        'categoriesLabel': 'Categories',
        'defectTypeLabel': 'Defect Type',
        'descriptionLabel': 'Description',
        'remedialWorksLabel': 'Remedial Works',
        
        // Modal titles
        'defectForm': 'Defect Form',
        'labelForm': 'Label Form',
        'defectsDetail': 'Defects Detail',
        'labelsDetail': 'Labels Detail',
        
        // Status
        'yes': 'Yes',
        'no': 'No',
        'assigned': 'Assigned',
        'unassigned': 'Unassigned',
        'submitted': 'Submitted',
        'pending': 'Pending',
        'defectRenumbered': 'Defect numbers have been renumbered',
        'defectDeleted': 'Defect record deleted',
        'labelDeleted': 'Label record deleted',
        
        // HTML attributes and placeholders
        'openFloorPlan': 'Open Floor Plan',
        'sortPhotosToFolder': 'Sort photos to folder',
        'languageSwitch': 'Language switch',
        'enterInspectionNumber': 'Enter inspection number',
        'enterFloor': 'Enter floor',
        'enterAreaName': 'Enter area name',
        'enterRoomNumber': 'Enter room number',
        'photoZoomControl': 'Photo zoom control',
        'submitToTable': 'Submit to table',
        'clearAllCategories': 'Clear all categories',
        'allLabelsDetail': 'All Labels Detail',
        'allDefectsDetail': 'All Defects Detail',
        'imminentDangerSwitch': 'Imminent danger switch',
        'enterInspectionDate': 'Enter inspection date',
        'autoAssignedFromDefectSummary': 'Auto-assigned from defect summary',
        'selectedPhotoNumbers': 'Selected photo numbers',
        'selectCategory': 'Select a category',
        'enterDefectTypeDirectly': 'Enter defect type directly or select from dropdown',
        'searchDefectTypes': 'Search defect types...',
        'clearSearch': 'Clear search',
        'enterDescription': 'Enter description',
        'selectCondition': 'Select condition',
        'enterHumidity': 'Enter humidity',
        'enterMoistureContent': 'Enter moisture content',
        'enterChlorideContent': 'Enter chloride content',
        'enterCarbonationDetails': 'Enter carbonation details',
        'enterRemedialWorks': 'Enter remedial works',
        'enterPreventiveWorks': 'Enter preventive works',
        'enterRemarks': 'Enter remarks',
        'close': 'Close',
        'resizePhoto': 'Resize Photo',
        'photoPreview': 'Photo Preview',
        'addPhotos': 'Add photos',
        'selectedPhotos': 'Selected',
        'photos': 'photos',
        'defectForm': 'Defect Form',
        'labelsDetail': 'Labels Detail',
        'defectsDetail': 'Defects Detail',
        'inspectionNo': 'Inspection No.',
        'inspectionDate': 'Inspection Date',
        'floor': 'Floor',
        'areaName': 'Area Name',
        'roomNo': 'Room No.',
        'defectNo': 'Defect No.',
        'photoNo': 'Photo No.',
        'categories': 'Categories',
        'defectType': 'Defect Type',
        'description': 'Description',
        'existingCondition': 'Existing Condition',
        'humidity': 'Humidity',
        'moistureContent': 'Moisture Content',
        'chlorideContent': 'Chloride Content',
        'carbonationDetails': 'Carbonation Details',
        'remedialWorks': 'Remedial Works',
        'preventiveWorks': 'Preventive Works',
        'remarks': 'Remarks',
        'imminentDanger': 'Imminent Danger',
        'yes': 'Yes',
        'no': 'No',
        'selectFolderToPreviewPhotos': 'Select a folder to preview photos',
        'selectPhotoFolder': 'Select Photo Folder',
        'pleaseEnterInspectionNumber': 'Please enter Inspection No. in header fields before assigning photos',
        
        // Section titles
        'assignToCategories': 'Assign to Categories',
        'inspectionRecords': 'Inspection Records',
        'defectSummary': 'Defect Summary',
        'categoriesRecords': 'Categories Records',
        
        // Inspection Records table headers
        'inspectionNoHeader': 'Inspection No.',
        'inspectionDateHeader': 'Inspection Date',
        'locationHeader': 'Location (Floor, Area name and Room no. in sequence)',
        'categoryAHeader': 'A: Exposed structural metalwork',
        'categoryBHeader': 'B: Structural elements',
        'categoryCHeader': 'C: External building elements',
        'categoryDHeader': 'D: Suspended objects',
        'categoryEHeader': 'E: High level internal finishes',
        'categoryFHeader': 'F: Heavy metal gates/doors',
        'categoryGHeader': 'G: Window and glass louvers',
        'categoryHHeader': 'H: Drainage and Plumbing systems',
        'categoryIHeader': 'I: Fire safety elements',
        'categoryJHeader': 'J: Defects',
        
        // Defect Summary table headers
        'defectNoHeader': 'Defect No.',
        'defectWithImminentDangerHeader': 'Defect(s) with Imminent Danger (Yes/No) Follow up action at Part A.5',
        'locationsOfDefectsHeader': 'Locations of Defects (Floor, Area Name and Room No. in sequence)',
        'typeOfHighRiskBuildingElementsHeader': 'Type of High Risk Building Elements',
        'descriptionConstructionHeader': 'Description / Construction of High Risk Building Elements',
        'existingConditionHeader': 'Existing Condition of of High Risk Building Elements',
        'defectsDiagnosisHeader': 'Defects Diagnosis and Deficiencies Identified',
        'relativeHumidityHeader': 'Relative Humidity of Room / Area measured during Site Inspection',
        'moistureContentHeader': 'Moisture Content of Concrete Structural Elements only',
        'chlorideContentHeader': 'Chloride Content of Concrete Structural Elements',
        'depthExtentCarbonationHeader': 'Depth and Extent of Carbonation for Concrete Structural Elements',
        'scopeExtentRepairHeader': 'Scope and Extent of Recommended Follow-up Repair Remedial Works',
        'scopeExtentPreventiveHeader': 'Scope and Extent of Recommended Preventive Maintenance Works',
        'remarksHeader': 'Remarks',
        
        // Labels Detail table headers
        'actionsHeader': 'Actions',
        'inspectionNoHeaderLabels': 'Inspection No.',
        'floorHeaderLabels': 'Floor',
        'areaNameHeaderLabels': 'Area Name',
        'roomNoHeaderLabels': 'Room No.',
        'inspectionDateHeaderLabels': 'Inspection Date',
        'categoryAHeaderLabels': 'A: Exposed structural metalwork',
        'categoryBHeaderLabels': 'B: Structural elements',
        'categoryCHeaderLabels': 'C: External building elements',
        'categoryDHeaderLabels': 'D: Suspended objects',
        'categoryEHeaderLabels': 'E: High level internal finishes',
        'categoryFHeaderLabels': 'F: Heavy metal gates/doors',
        'categoryGHeaderLabels': 'G: Window and glass louvers',
        'categoryHHeaderLabels': 'H: Drainage and Plumbing systems',
        'categoryIHeaderLabels': 'I: Fire safety elements',
        'categoryJHeaderLabels': 'J: Defects',
        
        // Defects Detail table headers
        'actionsHeaderDefects': 'Actions',
        'defectNoHeaderDefects': 'Defect No.',
        'inspectionNoHeaderDefects': 'Inspection No.',
        'imminentDangerHeaderDefects': 'Imminent Danger',
        'inspectionDateHeaderDefects': 'Inspection Date',
        'floorHeaderDefects': 'Floor',
        'areaNameHeaderDefects': 'Area Name',
        'roomNoHeaderDefects': 'Room No.',
        'photoNumbersHeaderDefects': 'Photo Numbers',
        'categoriesHeaderDefects': 'Categories',
        'defectTypeHeaderDefects': 'Defect Type',
        'descriptionHeaderDefects': 'Description',
        'remedialWorksHeaderDefects': 'Remedial Works',
        
        // Category names
        'categoryA': 'A: Exposed structural metalwork',
        'categoryB': 'B: Structural elements',
        'categoryC': 'C: External building elements',
        'categoryD': 'D: Suspended objects',
        'categoryE': 'E: High level internal finishes',
        'categoryF': 'F: Heavy metal gates/doors',
        'categoryG': 'G: Window and glass louvers',
        'categoryH': 'H: Drainage and Plumbing systems',
        'categoryI': 'I: Fire safety elements',
        'categoryJ': 'J: Defects',
        
        // Category table headers
        'locationNoHeader': 'Location No.',
        'roomNoHeader': 'Room No.',
        'photoNoHeader': 'Photo No.',
        'defectsHeader': 'Defects',
        
        // Category table titles
        'categoryTableA': 'A: Exposed structural metalwork',
        'categoryTableB': 'B: Structural elements',
        'categoryTableC': 'C: External building elements',
        'categoryTableD': 'D: Suspended objects',
        'categoryTableE': 'E: High level internal finishes',
        'categoryTableF': 'F: Heavy metal gates/doors',
        'categoryTableG': 'G: Window and glass louvers',
        'categoryTableH': 'H: Drainage and Plumbing systems',
        'categoryTableI': 'I: Fire safety elements',
        
        // PNE dropdown menu items
        'openDrawingMode': 'Open drawing mode',
        'selectPhotoFolder': 'Select Photo Folder',
        'openPNEFile': 'Open PNE file',
        'saveAsPNEFile': 'Save as PNE file',
        'exportCSV': 'Export CSV',
        'defectsReport': 'Defects Report',
        'photoAssignmentSummary': 'Photo Assignment Summary',
        
        // Floor plan container
        'openFloorPlan': 'Open Floor Plan',
        'newFloorPlan': 'New Floor Plan',
        'showDetails': 'Show Details',
        'allLabelsDetail': 'All Labels Detail',
        'allDefectsDetail': 'All Defects Detail',
        'clearData': 'Clear Data',
        'clearAllLabels': 'Clear All Labels',
        'clearAllDefectMarks': 'Clear All Defect Marks',
        'clearAllLabelsAndDefectMarks': 'Clear All Labels & Defect Marks',
        'exportAsPDF': 'Export as PDF',
        'zoomTo100AndCenter': 'Zoom to 100% and center',
        'close': 'Close',
        'previousFloorPlanDataFound': 'Previous Floor Plan Data Found',
        'clickToUploadPDFFloorPlan': 'Click to upload PDF floor plan',
        'chooseFile': 'Choose File',
        'quickLabelMode': 'Quick Label Mode',
        'clickToAddLabel': 'Click to add label',
        'clickToAddDefect': 'Click to add defect',
        
        // Previous floor plan elements
        'previousFloorPlanDataFound': 'Previous Floor Plan Data Found',
        'youHaveLabelDataFromPreviousFloorPlan': 'You have label data from a previous floor plan. To view and manage these labels, please open the same floor plan file.',
        'previousFile': 'Previous file:',
        'openPreviousFloorPlan': 'Open Previous Floor Plan',
        
        // Floor plan header
        'floorPlanTitle': 'Floor Plan',
        
        // Detail table containers
        'allLabelsDetailTableContainer': 'All Labels Detail Table',
        'allDefectsDetailTableContainer': 'All Defects Detail Table',
        
        // Floor plan header
        'drawingMode': 'Drawing mode',
        'newFloorPlan': 'New Floor Plan',
        'exportAsPDF': 'Export as PDF',
        'quickLabel': 'Quick Label',
        'doubleClickToPlaceDefectMark': 'Double-click to place defect mark',
        'labelSize': 'Label size',
        'defectSize': 'Defect size',
        'allLabelsDetail': 'All Labels Detail',
        'allDefectsDetail': 'All Defects Detail',
        'zoomTo100AndCenter': 'Zoom to 100% and center',
        'close': 'Close',
        
        // Floor plan content
        'previousFloorPlanDataFound': 'Previous Floor Plan Data Found',
        'previousFloorPlanDataDescription': 'You have label data from a previous floor plan. To view and manage these labels, please open the same floor plan file.',
        'previousFile': 'Previous file:',
        'openPreviousFloorPlan': 'Open Previous Floor Plan',
        'clickToUploadPDFFloorPlan': 'Click to upload PDF floor plan',
        'chooseFile': 'Choose File',
        'doubleClickToPlaceLabel': 'Double-click to place label',
        
        // Label modal
        'newLabel': 'New Label',
        'inspectionNoRequired': 'Inspection no. *',
        'floorOptional': 'Floor (Optional)',
        'areaNameOptional': 'Area name (Optional)',
        'roomNoOptional': 'Room no. (Optional)',
        'inspectionDateOptional': 'Inspection date (Optional)',
        'enterFloorNumber': 'Enter floor number',
        'enterAreaName': 'Enter area name',
        'enterRoomNumber': 'Enter room number',
        'onlyInspectionNoRequired': '* Only Inspection No. is required',
        'otherFieldsOptional': 'Other fields are optional and can be filled later',
        'cancel': 'Cancel',
        'create': 'Create',
        'saveAndAssignToNewRecord': 'Save and Assign to New Record',
        
        // Quick label messages
        'quickLabelModeDisabled': 'Quick Label mode disabled',
        
        // Session restore modal
        'restorePreviousSession': 'Restore previous session?',
        'sessionRestoreDescription': 'We found previously saved data and settings. Would you like to open them now, or start with an empty page?',
        'previousFloorPlanPDFAndLabels': 'Previous floor plan PDF and labels',
        'previouslyLoadedPhotosAndAssignments': 'Previously loaded photos and assignments',
        'defectEntriesAndViewState': 'Defect entries and view state',
        'previousTaskData': 'Previous task data',
        'startFresh': 'Start fresh',
        'openPrevious': 'Open previous',
        
        // Loading previous data modal
        'loadingPreviousData': 'Loading previous data',
        'loadingPreviousDataDescription': 'Please wait while we restore your previous session...',
        'loadingFloorPlanPDF': 'Loading floor plan PDF...',
        'loadingPhotos': 'Loading photos...',
        'loadingInspectionData': 'Loading inspection data...',
        
        // Task display
        'taskDisplay': 'Task Display',
        'taskEntries': 'Current Task',
        'currentTask': 'Current Task',
        'taskName': 'Task Name',
        'taskLocation': 'Location',
        'taskStartDate': 'Start Date',
        'taskTargetDate': 'Target Completion Date',
        'taskDescription': 'Description (Optional)',
        'taskSaved': 'Task saved successfully',
        
        // Start Fresh Overlay
        'startFreshTitle': 'Ready to Start Fresh?',
        'startFreshDescription': 'Choose how you\'d like to begin your new project:',
        'startNewTask': 'Start a New Task',
        'startNewTaskDescription': 'Create a new task and begin working',
        'openPNEFileDescription': 'Load an existing project file'
    }
};

let currentLanguage = 'en-GB'; // Default language

// Language functions
function getText(key) {
    return languages[currentLanguage][key] || key;
}

// å˜—è©¦å–å¾—åŸå§‹å½±åƒçš„ Blobï¼ˆè‹¥æœ‰å„²å­˜çš„è³‡æ–™å¤¾ handle èˆ‡ webkitRelativePathï¼‰ï¼Œå¦å‰‡å›å‚³ null
async function tryGetOriginalImageBlob(file) {
    try {
        if (file && file.webkitRelativePath && window.showDirectoryPicker && window.storageAdapter && window.storageAdapter.getItem) {
            const dirHandle = await window.storageAdapter.getItem('pne_photos_dir_handle');
            if (dirHandle && dirHandle.getDirectoryHandle) {
                const pathParts = file.webkitRelativePath.split('/');
                let currentHandle = dirHandle;
                for (let i = 0; i < pathParts.length - 1; i++) {
                    const part = pathParts[i];
                    if (part) currentHandle = await currentHandle.getDirectoryHandle(part);
                }
                const fileHandle = await currentHandle.getFileHandle(pathParts[pathParts.length - 1]);
                const originalFile = await fileHandle.getFile();
                const arrayBuffer = await originalFile.arrayBuffer();
                return new Blob([arrayBuffer], { type: originalFile.type || 'image/jpeg' });
            }
        }
    } catch (e) {
        window.logger.warn('tryGetOriginalImageBlob failed, fallback to preview dataURL:', e);
    }
    return null;
}

// é¡¯ç¤ºç…§ç‰‡é è¦½å½ˆçª—ï¼Œå¸¶ç¸®æ”¾/ä½ç§»å‹•ç•«ï¼ˆé›™æ“Šç¸®åœ–é–‹å•Ÿã€é›™æ“Šå½ˆçª—é—œé–‰ï¼‰
async function showPhotoPreviewPopup(file, thumbnailEl) {
    // è‹¥å·²æœ‰é–‹å•Ÿä¸­çš„å½ˆçª—ï¼Œå…ˆå¿½ç•¥
    if (document.getElementById('photoPreviewOverlay')) return;
    
    const thumbRect = thumbnailEl.getBoundingClientRect();
    
    // å˜—è©¦åŸå§‹æª”ï¼Œå¦å‰‡ä½¿ç”¨ dataURL/ç¸®åœ–
    let imgSrc = '';
    const originalBlob = await tryGetOriginalImageBlob(file);
    let objectUrl = '';
    if (originalBlob) {
        objectUrl = URL.createObjectURL(originalBlob);
        imgSrc = objectUrl;
    } else if (file && typeof file.dataURL === 'string' && file.dataURL) {
        imgSrc = file.dataURL;
    } else {
        // å¾ç•¶å‰ç¸®åœ–å–ç”¨ï¼ˆæœ€å¾Œé€€å›ï¼‰
        const img = thumbnailEl.querySelector('img');
        imgSrc = img ? img.src : '';
    }
    if (!imgSrc) return;
    
    // æª¢æŸ¥æ˜¯å¦ç‚º360ç…§ç‰‡ä¸¦ä½¿ç”¨360é è¦½åŠŸèƒ½
    console.log('ğŸ” Checking 360 preview functions availability...');
    console.log('ğŸ” detectPhoto360Panorama available:', typeof detectPhoto360Panorama === 'function');
    console.log('ğŸ” openPhoto360Preview available:', typeof openPhoto360Preview === 'function');
    
    if (typeof detectPhoto360Panorama === 'function' && typeof openPhoto360Preview === 'function') {
        console.log('ğŸ” 360 functions available, starting detection...');
        const img = new Image();
        img.onload = async function() {
            try {
                console.log('ğŸ” Image loaded, starting 360 detection...');
                const isPanorama = await detectPhoto360Panorama(img);
                console.log('ğŸ” 360 detection result:', isPanorama, 'for image:', imgSrc.substring(0, 50));
                if (isPanorama) {
                    console.log('âœ… Opening 360 preview');
                    openPhoto360Preview(imgSrc);
                    if (objectUrl) URL.revokeObjectURL(objectUrl);
                    return;
                }
                console.log('ğŸ“· Opening normal preview');
                // å¦‚æœä¸æ˜¯360ç…§ç‰‡ï¼Œç¹¼çºŒä½¿ç”¨åŸä¾†çš„é è¦½æ–¹å¼
                showOriginalPhotoPreview();
            } catch (error) {
                console.error('âŒ Error in 360 detection:', error);
                // å‡ºéŒ¯æ™‚ä½¿ç”¨åŸä¾†çš„é è¦½æ–¹å¼
                showOriginalPhotoPreview();
            }
        };
        img.onerror = function() {
            console.warn('âš ï¸ Image load error, using normal preview');
            showOriginalPhotoPreview();
        };
        img.src = imgSrc;
        return;
    }
    
    console.log('âš ï¸ 360 preview functions not available, using normal preview');
    // åŸä¾†çš„é è¦½æ–¹å¼
    showOriginalPhotoPreview();
    
    function showOriginalPhotoPreview() {
        // å»ºç«‹è¦†è“‹å±¤
        const overlay = document.createElement('div');
        overlay.id = 'photoPreviewOverlay';
        overlay.className = 'photo-preview-overlay';
        overlay.style.cssText = `
            position: fixed; inset: 0; background: rgba(0,0,0,0.45);
            display: block; z-index: 7000; overflow: hidden;
        `;
        document.body.appendChild(overlay);
        
        // å»ºç«‹å¯å‹•ç•«çš„å½±åƒå…ƒç´ ï¼ˆçµ•å°å®šä½ï¼Œä»¥ç¸®åœ–åº§æ¨™èµ·å§‹ï¼‰
        const animImg = document.createElement('img');
        animImg.src = imgSrc;
        animImg.alt = file.name || '';
        animImg.style.cssText = `
            position: fixed; top: ${thumbRect.top}px; left: ${thumbRect.left}px;
            width: ${thumbRect.width}px; height: ${thumbRect.height}px;
            object-fit: contain; border-radius: 8px; box-shadow: 0 8px 32px rgba(0,0,0,0.25);
            transition: top 300ms ease, left 300ms ease, width 300ms ease, height 300ms ease, border-radius 300ms ease;
            will-change: top, left, width, height;
            background: #111;
        `;
        overlay.appendChild(animImg);
        
        // è¼‰å…¥å®Œæˆå¾Œè¨ˆç®—æœ€çµ‚å°ºå¯¸ï¼ˆ90vw/90vh å…§ç­‰æ¯”é¡¯ç¤ºï¼‰
        const loadAndAnimate = async () => {
            await new Promise((resolve) => {
                if (animImg.complete) return resolve();
                animImg.onload = () => resolve();
                animImg.onerror = () => resolve();
            });
            
            const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
            const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
            const maxW = Math.floor(vw * 0.9);
            const maxH = Math.floor(vh * 0.9);
            const naturalW = animImg.naturalWidth || thumbRect.width;
            const naturalH = animImg.naturalHeight || thumbRect.height;
            
            let finalW = naturalW;
            let finalH = naturalH;
            const scale = Math.min(maxW / naturalW, maxH / naturalH, 1);
            finalW = Math.round(naturalW * scale);
            finalH = Math.round(naturalH * scale);
            const finalLeft = Math.round((vw - finalW) / 2);
            const finalTop = Math.round((vh - finalH) / 2);
            
            // è§¸ç™¼å‹•ç•«åˆ°ä¸­å¤®æ”¾å¤§
            requestAnimationFrame(() => {
                animImg.style.top = `${finalTop}px`;
                animImg.style.left = `${finalLeft}px`;
                animImg.style.width = `${finalW}px`;
                animImg.style.height = `${finalH}px`;
                animImg.style.borderRadius = '12px';
            });
        };
        
        loadAndAnimate();
        
        // é›™æ“Šå½ˆçª—å½±åƒï¼Œæ”¶åˆå›ç¸®åœ–ä¸¦é—œé–‰
        let closePopup = () => {
            const currentRect = thumbnailEl.getBoundingClientRect();
            animImg.style.top = `${currentRect.top}px`;
            animImg.style.left = `${currentRect.left}px`;
            animImg.style.width = `${currentRect.width}px`;
            animImg.style.height = `${currentRect.height}px`;
            animImg.style.borderRadius = '8px';
            
            const onTransitionEnd = () => {
                animImg.removeEventListener('transitionend', onTransitionEnd);
                if (objectUrl) URL.revokeObjectURL(objectUrl);
                overlay.remove();
            };
            animImg.addEventListener('transitionend', onTransitionEnd);
        };
        
        // åªæ¥å—é›™æ“Šé—œé–‰ï¼ˆç¬¦åˆéœ€æ±‚ #2ï¼‰ï¼ŒåŒæ™‚æ”¯æ´ Esc èˆ‡é»æ“Šé®ç½©
        const onDblClick = (e) => { e.stopPropagation(); closePopup(); };
        overlay.addEventListener('dblclick', onDblClick);
        
        const onKeyDown = (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                closePopup();
            }
        };
        document.addEventListener('keydown', onKeyDown);
        
        const onOverlayClick = (e) => {
            if (e.target === overlay) {
                closePopup();
            }
        };
        overlay.addEventListener('click', onOverlayClick, true);
        
        // é—œé–‰æ™‚æ¸…ç†ç›£è½å™¨
        const originalClose = closePopup;
        closePopup = () => {
            const currentRect = thumbnailEl.getBoundingClientRect();
            animImg.style.top = `${currentRect.top}px`;
            animImg.style.left = `${currentRect.left}px`;
            animImg.style.width = `${currentRect.width}px`;
            animImg.style.height = `${currentRect.height}px`;
            animImg.style.borderRadius = '8px';
            const onTransitionEnd = () => {
                animImg.removeEventListener('transitionend', onTransitionEnd);
                if (objectUrl) URL.revokeObjectURL(objectUrl);
                overlay.removeEventListener('dblclick', onDblClick);
                overlay.removeEventListener('click', onOverlayClick, true);
                document.removeEventListener('keydown', onKeyDown);
                overlay.remove();
            };
            animImg.addEventListener('transitionend', onTransitionEnd);
        };
    }
}
function setLanguage(lang) {
    currentLanguage = lang;
    localStorage.setItem('selectedLanguage', lang);
    updateAllTexts();
}

function updateAllTexts() {
    // Update header texts
    const sortToggleText = document.getElementById('sortToggleText');
    const languageToggleText = document.getElementById('languageToggleText');
    
    if (sortToggleText) {
        sortToggleText.textContent = getText('sortToggleText');
    }
    if (languageToggleText) {
        languageToggleText.textContent = getText('languageToggleText');
    }
    
    // Update HTML attributes
    updateHTMLAttributes();
    
    // Update table headers
    updateTableHeaders();
    
    // Update button texts
    updateButtonTexts();
    
    // Update modal texts
    updateModalTexts();
    
    // Update form labels
    updateFormLabels();
    
    // Update placeholders
    updatePlaceholders();
    
    // Update other texts
    updateOtherTexts();
    
    // Update floor plan header texts
    updateFloorPlanHeaderTexts();
}

function updateTableHeaders() {
    // Update defects detail table headers
    const defectsTable = document.getElementById('defectsDetailTable');
    if (defectsTable) {
        const headers = defectsTable.querySelectorAll('th');
        const headerKeys = ['action', 'defectNo', 'inspectionNo', 'imminentDanger', 'inspectionDate', 'floor', 'areaName', 'roomNo', 'photoNumbers', 'categories', 'defectType', 'description', 'remedialWorks'];
        
        headers.forEach((header, index) => {
            if (headerKeys[index]) {
                header.textContent = getText(headerKeys[index]);
            }
        });
    }
    
    // Update labels detail table headers
    const labelsTable = document.getElementById('labelsDetailTable');
    if (labelsTable) {
        const headers = labelsTable.querySelectorAll('th');
        const headerKeys = ['action', 'labelInspectionNo', 'labelInspectionDate', 'labelFloor', 'labelAreaName', 'labelRoomNo', 'labelCategoryA', 'labelCategoryB', 'labelCategoryC', 'labelCategoryD', 'labelCategoryE', 'labelCategoryF', 'labelCategoryG', 'labelCategoryH', 'labelCategoryI', 'labelCategoryJ', 'labelDefects'];
        
        headers.forEach((header, index) => {
            if (headerKeys[index]) {
                header.textContent = getText(headerKeys[index]);
            }
        });
    }
}

function updateButtonTexts() {
    // Update specific button texts
    const submitBtn = document.getElementById('submitBtn');
    if (submitBtn) {
        submitBtn.textContent = getText('submitToTable');
    }
    
    const clearBtn = document.getElementById('clearBtn');
    if (clearBtn) {
        clearBtn.innerHTML = `<i class="fas fa-eraser"></i> ${getText('clearAllCategories')}`;
    }
    
    const addPhotosBtn = document.getElementById('addPhotosBtn');
    if (addPhotosBtn) {
        addPhotosBtn.textContent = getText('addPhotos');
    }
    
    const labelsDetailBtn = document.querySelector('[data-action="all-labels-detail"]');
    if (labelsDetailBtn) {
        labelsDetailBtn.innerHTML = `<i class="fas fa-list-alt"></i> ${getText('allLabelsDetail')}`;
    }
    
    const defectsDetailBtn = document.querySelector('[data-action="all-defects-detail"]');
    if (defectsDetailBtn) {
        defectsDetailBtn.innerHTML = `<i class="fas fa-clipboard-list"></i> ${getText('allDefectsDetail')}`;
    }
    
    // Update close buttons
    const closeButtons = document.querySelectorAll('.detail-popup-close, .resize-photo-close');
    closeButtons.forEach(btn => {
        btn.title = getText('close');
    });
    
    // Update common button texts
    const buttons = document.querySelectorAll('button');
    buttons.forEach(button => {
        const text = button.textContent.trim();
        if (text === 'æäº¤' || text === 'Submit') {
            button.textContent = getText('submit');
        } else if (text === 'åˆªé™¤' || text === 'Delete') {
            button.textContent = getText('delete');
        } else if (text === 'ä¿å­˜' || text === 'Save') {
            button.textContent = getText('save');
        } else if (text === 'å–æ¶ˆ' || text === 'Cancel') {
            button.textContent = getText('cancel');
        } else if (text === 'é—œé–‰' || text === 'Close') {
            button.textContent = getText('close');
        }
    });
}

function updateModalTexts() {
    // Update modal titles
    const modals = document.querySelectorAll('.modal-title, .modal-header h4, .modal-header h3');
    modals.forEach(modal => {
        const text = modal.textContent.trim();
        if (text.includes('ç¼ºé™·') || text.includes('Defect')) {
            modal.textContent = getText('defectForm');
        } else if (text.includes('æ¨™ç±¤') || text.includes('Label')) {
            modal.textContent = getText('labelForm');
        }
    });
}

function updateHTMLAttributes() {
    // Update title attributes
    const floorplanThumb = document.getElementById('floorplanThumb');
    if (floorplanThumb) {
        floorplanThumb.title = getText('openFloorPlan');
    }
    
    // Update aria-label attributes
    const sortToggle = document.querySelector('.sort-toggle');
    if (sortToggle) {
        sortToggle.setAttribute('aria-label', getText('sortPhotosToFolder'));
    }
    
    const languageToggle = document.querySelector('.language-toggle');
    if (languageToggle) {
        languageToggle.setAttribute('aria-label', getText('languageSwitch'));
    }
    
    // Update button aria-labels
    const submitBtn = document.getElementById('submitBtn');
    if (submitBtn) {
        submitBtn.setAttribute('aria-label', getText('submitToTable'));
    }
    
    const clearBtn = document.getElementById('clearBtn');
    if (clearBtn) {
        clearBtn.setAttribute('aria-label', getText('clearAllCategories'));
    }
    
    const labelsDetailBtn = document.querySelector('[data-action="all-labels-detail"]');
    if (labelsDetailBtn) {
        labelsDetailBtn.setAttribute('aria-label', getText('allLabelsDetail'));
    }
    
    const defectsDetailBtn = document.querySelector('[data-action="all-defects-detail"]');
    if (defectsDetailBtn) {
        defectsDetailBtn.setAttribute('aria-label', getText('allDefectsDetail'));
    }
    
    const imminentDangerSwitch = document.getElementById('imminentDangerSwitch');
    if (imminentDangerSwitch) {
        imminentDangerSwitch.setAttribute('aria-label', getText('imminentDangerSwitch'));
    }
    
    const zoomSliderElement = document.getElementById('zoomSlider');
    if (zoomSliderElement) {
        zoomSliderElement.setAttribute('aria-label', getText('photoZoomControl'));
    }
}

function updateFormLabels() {
    // Update header field labels
    const locationIdLabel = document.querySelector('label[for="locationId"]');
    if (locationIdLabel) {
        locationIdLabel.innerHTML = `<i class="fas fa-map-marker-alt"></i> ${getText('inspectionNo')}`;
    }
    
    const inspectionDateLabel = document.querySelector('label[for="inspectionDate"]');
    if (inspectionDateLabel) {
        inspectionDateLabel.innerHTML = `<i class="fas fa-calendar-check"></i> ${getText('inspectionDate')}`;
    }
    
    const floorLabel = document.querySelector('label[for="floorHeader"]');
    if (floorLabel) {
        floorLabel.innerHTML = `<i class="fas fa-layer-group"></i> ${getText('floor')}`;
    }
    
    const areaNameLabel = document.querySelector('label[for="areaNameHeader"]');
    if (areaNameLabel) {
        areaNameLabel.innerHTML = `<i class="fas fa-map"></i> ${getText('areaName')}`;
    }
    
    const roomNoLabel = document.querySelector('label[for="roomNo"]');
    if (roomNoLabel) {
        roomNoLabel.innerHTML = `<i class="fas fa-door-closed"></i> ${getText('roomNo')}`;
    }
    
    // Update defect form labels
    const defectInspectionNoLabel = document.querySelector('label[for="defectInspectionNo"]');
    if (defectInspectionNoLabel) {
        defectInspectionNoLabel.textContent = getText('inspectionNo');
    }
    
    const inspectionDateDefectLabel = document.querySelector('label[for="inspectionDateDefect"]');
    if (inspectionDateDefectLabel) {
        inspectionDateDefectLabel.textContent = getText('inspectionDate');
    }
    
    const defectFloorLabel = document.querySelector('label[for="defectFloor"]');
    if (defectFloorLabel) {
        defectFloorLabel.textContent = getText('floor');
    }
    
    const defectAreaNameLabel = document.querySelector('label[for="defectAreaName"]');
    if (defectAreaNameLabel) {
        defectAreaNameLabel.textContent = getText('areaName');
    }
    
    const defectRoomNoLabel = document.querySelector('label[for="defectRoomNo"]');
    if (defectRoomNoLabel) {
        defectRoomNoLabel.textContent = getText('roomNo');
    }
    
    const defectNoLabel = document.querySelector('label[for="defectNo"]');
    if (defectNoLabel) {
        defectNoLabel.textContent = getText('defectNo');
    }
    
    const defectPhotoNoLabel = document.querySelector('label[for="defectPhotoNo"]');
    if (defectPhotoNoLabel) {
        defectPhotoNoLabel.textContent = getText('photoNo');
    }
    
    const defectCategoryLabel = document.querySelector('label[for="defectCategory"]');
    if (defectCategoryLabel) {
        defectCategoryLabel.textContent = getText('categories');
    }
    
    const defectDescriptionLabel = document.querySelector('label[for="defectDescription"]');
    if (defectDescriptionLabel) {
        defectDescriptionLabel.textContent = getText('description');
    }
    
    const defectExistingConditionLabel = document.querySelector('label[for="defectExistingCondition"]');
    if (defectExistingConditionLabel) {
        defectExistingConditionLabel.textContent = getText('existingCondition');
    }
    
    const defectHumidityLabel = document.querySelector('label[for="defectHumidity"]');
    if (defectHumidityLabel) {
        defectHumidityLabel.textContent = getText('humidity');
    }
    
    const defectMoistureLabel = document.querySelector('label[for="defectMoisture"]');
    if (defectMoistureLabel) {
        defectMoistureLabel.textContent = getText('moistureContent');
    }
    
    const defectChlorideLabel = document.querySelector('label[for="defectChloride"]');
    if (defectChlorideLabel) {
        defectChlorideLabel.textContent = getText('chlorideContent');
    }
    
    const defectCarbonationLabel = document.querySelector('label[for="defectCarbonation"]');
    if (defectCarbonationLabel) {
        defectCarbonationLabel.textContent = getText('carbonationDetails');
    }
    
    const defectRemedialWorksLabel = document.querySelector('label[for="defectRemedialWorks"]');
    if (defectRemedialWorksLabel) {
        defectRemedialWorksLabel.textContent = getText('remedialWorks');
    }
    
    const defectPreventiveWorksLabel = document.querySelector('label[for="defectPreventiveWorks"]');
    if (defectPreventiveWorksLabel) {
        defectPreventiveWorksLabel.textContent = getText('preventiveWorks');
    }
    
    const defectRemarksLabel = document.querySelector('label[for="defectRemarks"]');
    if (defectRemarksLabel) {
        defectRemarksLabel.textContent = getText('remarks');
    }
}

function updatePlaceholders() {
    // Update header field placeholders
    const locationId = document.getElementById('locationId');
    if (locationId) {
        locationId.placeholder = getText('enterInspectionNumber');
    }
    
    const floorHeader = document.getElementById('floorHeader');
    if (floorHeader) {
        floorHeader.placeholder = getText('enterFloor');
    }
    
    const areaNameHeader = document.getElementById('areaNameHeader');
    if (areaNameHeader) {
        areaNameHeader.placeholder = getText('enterAreaName');
    }
    
    const roomNo = document.getElementById('roomNo');
    if (roomNo) {
        roomNo.placeholder = getText('enterRoomNumber');
    }
    
    // Update defect form placeholders
    const defectInspectionNo = document.getElementById('defectInspectionNo');
    if (defectInspectionNo) {
        defectInspectionNo.placeholder = getText('enterInspectionNumber');
    }
    
    const inspectionDateDefect = document.getElementById('inspectionDateDefect');
    if (inspectionDateDefect) {
        inspectionDateDefect.placeholder = getText('enterInspectionDate');
    }
    
    const defectFloor = document.getElementById('defectFloor');
    if (defectFloor) {
        defectFloor.placeholder = getText('enterFloor');
    }
    
    const defectAreaName = document.getElementById('defectAreaName');
    if (defectAreaName) {
        defectAreaName.placeholder = getText('enterAreaName');
    }
    
    const defectRoomNo = document.getElementById('defectRoomNo');
    if (defectRoomNo) {
        defectRoomNo.placeholder = getText('enterRoomNumber');
    }
    
    const defectNo = document.getElementById('defectNo');
    if (defectNo) {
        defectNo.placeholder = getText('autoAssignedFromDefectSummary');
    }
    
    const defectPhotoNo = document.getElementById('defectPhotoNo');
    if (defectPhotoNo) {
        defectPhotoNo.placeholder = getText('selectedPhotoNumbers');
    }
    
    const defectTypeDirectInput = document.getElementById('defectTypeDirectInput');
    if (defectTypeDirectInput) {
        defectTypeDirectInput.placeholder = getText('enterDefectTypeDirectly');
    }
    
    const defectSearchInput = document.getElementById('defectSearchInput');
    if (defectSearchInput) {
        defectSearchInput.placeholder = getText('searchDefectTypes');
    }
    
    const defectDescription = document.getElementById('defectDescription');
    if (defectDescription) {
        defectDescription.placeholder = getText('enterDescription');
    }
    
    const defectHumidity = document.getElementById('defectHumidity');
    if (defectHumidity) {
        defectHumidity.placeholder = getText('enterHumidity');
    }
    
    const defectMoisture = document.getElementById('defectMoisture');
    if (defectMoisture) {
        defectMoisture.placeholder = getText('enterMoistureContent');
    }
    
    const defectChloride = document.getElementById('defectChloride');
    if (defectChloride) {
        defectChloride.placeholder = getText('enterChlorideContent');
    }
    
    const defectCarbonation = document.getElementById('defectCarbonation');
    if (defectCarbonation) {
        defectCarbonation.placeholder = getText('enterCarbonationDetails');
    }
    
    const defectRemedialWorks = document.getElementById('defectRemedialWorks');
    if (defectRemedialWorks) {
        defectRemedialWorks.placeholder = getText('enterRemedialWorks');
    }
    
    const defectPreventiveWorks = document.getElementById('defectPreventiveWorks');
    if (defectPreventiveWorks) {
        defectPreventiveWorks.placeholder = getText('enterPreventiveWorks');
    }
    
    const defectRemarks = document.getElementById('defectRemarks');
    if (defectRemarks) {
        defectRemarks.placeholder = getText('enterRemarks');
    }
}

function updateOtherTexts() {
    // Update photo preview title - preserve Add photos button
    const photoPreviewTitle = document.getElementById('photo-preview-title');
    if (photoPreviewTitle) {
        // Find the camera icon and update only the text content
        const cameraIcon = photoPreviewTitle.querySelector('i.fas.fa-camera');
        if (cameraIcon) {
            // Update the text node after the icon
            const textNode = cameraIcon.nextSibling;
            if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                textNode.textContent = ` ${getText('photoPreview')}`;
            } else {
                // If no text node exists, create one
                photoPreviewTitle.insertBefore(document.createTextNode(` ${getText('photoPreview')}`), cameraIcon.nextSibling);
            }
        } else {
            // Fallback: if icon not found, update the entire content but preserve Add photos button
            const addPhotosBtn = photoPreviewTitle.querySelector('#addPhotosBtn');
            if (addPhotosBtn) {
                // Store the button temporarily
                const buttonHTML = addPhotosBtn.outerHTML;
                photoPreviewTitle.innerHTML = `<i class="fas fa-camera"></i> ${getText('photoPreview')} ${buttonHTML}`;
            } else {
                photoPreviewTitle.innerHTML = `<i class="fas fa-camera"></i> ${getText('photoPreview')}`;
            }
        }
    }
    
    // Update photo count text - preserve zoom controls
    const photoCount = document.querySelector('.photo-count');
    if (photoCount) {
        // Store the zoom controls before updating
        const zoomControls = photoCount.querySelector('.zoom-controls');
        const zoomControlsHTML = zoomControls ? zoomControls.outerHTML : '';
        
        // Update the text content while preserving zoom controls
        photoCount.innerHTML = `${getText('selectedPhotos')}: <span id="selectedCount">0</span> ${getText('photos')} ${zoomControlsHTML}`;
    }
    
    // Update empty preview text
    const emptyPreview = document.querySelector('.empty-preview p');
    if (emptyPreview) {
        emptyPreview.textContent = getText('selectFolderToPreviewPhotos');
    }
    
    // Update select folder button
    const centerFolderBtn = document.getElementById('centerFolderBtn');
    if (centerFolderBtn) {
        centerFolderBtn.innerHTML = `<i class="fas fa-folder-open"></i> ${getText('selectPhotoFolder')}`;
    }
    
    // Update modal titles
    const resizePhotoTitle = document.querySelector('#resizePhotoWindow h3');
    if (resizePhotoTitle) {
        resizePhotoTitle.innerHTML = `<i class="fas fa-expand-arrows-alt"></i> ${getText('resizePhoto')}`;
    }
    
    const labelsDetailTitle = document.querySelector('#labelsDetailPopup h3');
    if (labelsDetailTitle) {
        labelsDetailTitle.innerHTML = `<i class="fas fa-list-alt"></i> ${getText('labelsDetail')}`;
    }
    
    const defectsDetailTitle = document.querySelector('#defectsDetailPopup h3');
    if (defectsDetailTitle) {
        defectsDetailTitle.innerHTML = `<i class="fas fa-clipboard-list"></i> ${getText('defectsDetail')}`;
    }
    
    // Update dropdown items
    const labelsDetailDropdown = document.querySelector('[data-action="all-labels-detail"]');
    if (labelsDetailDropdown && labelsDetailDropdown.classList.contains('show-details-dropdown-item')) {
        labelsDetailDropdown.innerHTML = `<i class="fas fa-list-alt"></i> ${getText('allLabelsDetail')}`;
    }
    
    const defectsDetailDropdown = document.querySelector('[data-action="all-defects-detail"]');
    if (defectsDetailDropdown && defectsDetailDropdown.classList.contains('show-details-dropdown-item')) {
        defectsDetailDropdown.innerHTML = `<i class="fas fa-clipboard-list"></i> ${getText('allDefectsDetail')}`;
    }
    
    // Update select option texts
    const defectCategorySelect = document.getElementById('defectCategory');
    if (defectCategorySelect) {
        const selectOption = defectCategorySelect.querySelector('option[value=""]');
        if (selectOption) {
            selectOption.textContent = getText('selectCategory');
        }
    }
    
    const defectExistingConditionSelect = document.getElementById('defectExistingCondition');
    if (defectExistingConditionSelect) {
        const selectOption = defectExistingConditionSelect.querySelector('option[value=""]');
        if (selectOption) {
            selectOption.textContent = getText('selectCondition');
        }
    }
    
    // Update search clear button title
    const searchClearBtn = document.getElementById('searchClearBtn');
    if (searchClearBtn) {
        searchClearBtn.title = getText('clearSearch');
    }
    
    // Update section titles
    updateSectionTitles();
    
    // Update table headers
    updateAllTableHeaders();
    
    // Update category grid and category tables
    updateCategoryGrid();
    updateCategoryTables();
    
    // Update PNE dropdown and floor plan container
    updatePNEDropdown();
    updateFloorPlanContainer();
}

function updateSectionTitles() {
    // Update Categories title
    const categoriesTitle = document.getElementById('categories-title');
    if (categoriesTitle) {
        categoriesTitle.innerHTML = `<i class="fas fa-tags"></i> ${getText('assignToCategories')}`;
    }
    
    // Update Inspection Records title
    const inspectionRecordsTitle = document.getElementById('data-table-title');
    if (inspectionRecordsTitle) {
        inspectionRecordsTitle.innerHTML = `<i class="fas fa-table"></i> ${getText('inspectionRecords')}`;
    }
    
    // Update Defect Summary title
    const defectSummaryTitle = document.getElementById('defect-summary-title');
    if (defectSummaryTitle) {
        defectSummaryTitle.innerHTML = `<i class="fas fa-clipboard-list"></i> ${getText('defectSummary')}`;
    }
    
    // Update Categories Records title
    const categoriesRecordsTitle = document.getElementById('category-tables-title');
    if (categoriesRecordsTitle) {
        categoriesRecordsTitle.textContent = getText('categoriesRecords');
    }
}

function updateAllTableHeaders() {
    // Update Inspection Records table headers
    updateInspectionRecordsTableHeaders();
    
    // Update Defect Summary table headers
    updateDefectSummaryTableHeaders();
    
    // Update Labels Detail table headers
    updateLabelsDetailTableHeaders();
    
    // Update Defects Detail table headers
    updateDefectsDetailTableHeaders();
}

function updateInspectionRecordsTableHeaders() {
    const inspectionRecordsTable = document.querySelector('.data-table[aria-describedby="data-table-title"]');
    if (inspectionRecordsTable) {
        const headers = inspectionRecordsTable.querySelectorAll('th');
        const headerKeys = [
            'inspectionNoHeader',
            'inspectionDateHeader', 
            'locationHeader',
            'categoryAHeader',
            'categoryBHeader',
            'categoryCHeader',
            'categoryDHeader',
            'categoryEHeader',
            'categoryFHeader',
            'categoryGHeader',
            'categoryHHeader',
            'categoryIHeader',
            'categoryJHeader'
        ];
        
        headers.forEach((header, index) => {
            if (headerKeys[index]) {
                header.textContent = getText(headerKeys[index]);
            }
        });
    }
}

function updateDefectSummaryTableHeaders() {
    const defectSummaryTable = document.querySelector('.data-table[aria-describedby="defect-summary-title"]');
    if (defectSummaryTable) {
        const headers = defectSummaryTable.querySelectorAll('th');
        const headerKeys = [
            'defectNoHeader',
            'defectWithImminentDangerHeader',
            'locationsOfDefectsHeader',
            'typeOfHighRiskBuildingElementsHeader',
            'descriptionConstructionHeader',
            'existingConditionHeader',
            'defectsDiagnosisHeader',
            'relativeHumidityHeader',
            'moistureContentHeader',
            'chlorideContentHeader',
            'depthExtentCarbonationHeader',
            'scopeExtentRepairHeader',
            'scopeExtentPreventiveHeader',
            'remarksHeader'
        ];
        
        headers.forEach((header, index) => {
            if (headerKeys[index]) {
                header.textContent = getText(headerKeys[index]);
            }
        });
    }
}

function updateLabelsDetailTableHeaders() {
    const labelsDetailTable = document.getElementById('labelsDetailTable');
    if (labelsDetailTable) {
        const headers = labelsDetailTable.querySelectorAll('th');
        const headerKeys = [
            'actionsHeader',
            'inspectionNoHeaderLabels',
            'floorHeaderLabels',
            'areaNameHeaderLabels',
            'roomNoHeaderLabels',
            'inspectionDateHeaderLabels',
            'categoryAHeaderLabels',
            'categoryBHeaderLabels',
            'categoryCHeaderLabels',
            'categoryDHeaderLabels',
            'categoryEHeaderLabels',
            'categoryFHeaderLabels',
            'categoryGHeaderLabels',
            'categoryHHeaderLabels',
            'categoryIHeaderLabels',
            'categoryJHeaderLabels'
        ];
        
        headers.forEach((header, index) => {
            if (headerKeys[index]) {
                header.textContent = getText(headerKeys[index]);
            }
        });
    }
}

function updateDefectsDetailTableHeaders() {
    const defectsDetailTable = document.getElementById('defectsDetailTable');
    if (defectsDetailTable) {
        const headers = defectsDetailTable.querySelectorAll('th');
        const headerKeys = [
            'defectNoHeaderDefects',
            'inspectionNoHeaderDefects',
            'imminentDangerHeaderDefects',
            'inspectionDateHeaderDefects',
            'floorHeaderDefects',
            'areaNameHeaderDefects',
            'roomNoHeaderDefects',
            'photoNumbersHeaderDefects',
            'categoriesHeaderDefects',
            'defectTypeHeaderDefects',
            'descriptionHeaderDefects',
            'remedialWorksHeaderDefects'
        ];
        
        headers.forEach((header, index) => {
            if (headerKeys[index]) {
                header.textContent = getText(headerKeys[index]);
            }
        });
    }
}

function updateCategoryGrid() {
    // Update category headers in the categories grid
    const categoryHeaders = document.querySelectorAll('.category-header-text');
    categoryHeaders.forEach(header => {
        const icon = header.querySelector('i');
        const categoryId = header.parentElement.dataset.category;
        
        if (categoryId && icon) {
            const categoryKey = `category${categoryId.toUpperCase()}`;
            const categoryName = getText(categoryKey);
            header.innerHTML = `<i class="fas ${icon.className.split(' ')[1]}"></i> ${categoryName}`;
        }
    });
}

function updateCategoryTables() {
    // Update category table titles
    const categoryTableTitles = document.querySelectorAll('.category-table-title');
    categoryTableTitles.forEach(title => {
        const icon = title.querySelector('i');
        const tableId = title.parentElement.querySelector('table').id;
        const categoryId = tableId.replace('category-table-', '');
        
        if (categoryId && icon) {
            const categoryKey = `categoryTable${categoryId.toUpperCase()}`;
            const categoryName = getText(categoryKey);
            title.innerHTML = `<i class="fas ${icon.className.split(' ')[1]}"></i> ${categoryName}`;
        }
    });
    
    // Update category table headers
    const categoryTables = document.querySelectorAll('.category-table');
    categoryTables.forEach(table => {
        const headers = table.querySelectorAll('th');
        const headerKeys = [
            'locationNoHeader',
            'roomNoHeader', 
            'photoNoHeader',
            'defectsHeader'
        ];
        
        headers.forEach((header, index) => {
            if (headerKeys[index]) {
                header.textContent = getText(headerKeys[index]);
            }
        });
    });
}

function updatePNEDropdown() {
    // Update PNE dropdown menu items
    const pneDropdownItems = document.querySelectorAll('.pne-dropdown-item');
    pneDropdownItems.forEach(item => {
        const action = item.getAttribute('data-action');
        const icon = item.querySelector('i');
        const iconClass = icon ? icon.className : '';
        
        let textKey = '';
        switch(action) {
            case 'uploadfloorplan':
                textKey = 'openDrawingMode';
                break;
            case 'selectfolder':
                textKey = 'selectPhotoFolder';
                break;
            case 'open':
                textKey = 'openPNEFile';
                break;
            case 'saveas':
                textKey = 'saveAsPNEFile';
                break;
            case 'exportcsv':
                textKey = 'exportCSV';
                break;
            case 'preview':
                textKey = 'defectsReport';
                break;
            case 'summary':
                textKey = 'photoAssignmentSummary';
                break;
        }
        
        if (textKey && icon) {
            item.innerHTML = `<i class="${iconClass}"></i> ${getText(textKey)}`;
        }
    });
}

function updateFloorPlanContainer() {
    // Update floor plan thumbnail title
    const floorplanThumb = document.getElementById('floorplanThumb');
    if (floorplanThumb) {
        floorplanThumb.title = getText('openFloorPlan');
    }
    
    // Update floor plan dropdown menu items
    const floorPlanDropdownItems = document.querySelectorAll('.floor-plan-dropdown-item');
    floorPlanDropdownItems.forEach(item => {
        const action = item.getAttribute('data-action');
        const icon = item.querySelector('i');
        const iconClass = icon ? icon.className : '';
        
        let textKey = '';
        switch(action) {
            case 'new-floor-plan':
                textKey = 'newFloorPlan';
                break;
            case 'show-details':
                textKey = 'showDetails';
                break;
            case 'clear-data':
                textKey = 'clearData';
                break;
            case 'export-to-pdf':
                textKey = 'exportAsPDF';
                break;
        }
        
        if (textKey && icon) {
            // Check if there's a chevron icon (for submenu items)
            const chevron = item.querySelector('.fa-chevron-right');
            if (chevron) {
                item.innerHTML = `<i class="${iconClass}"></i> ${getText(textKey)} <i class="fas fa-chevron-right" style="margin-left: auto; font-size: 12px; pointer-events: none;"></i>`;
            } else {
                item.innerHTML = `<i class="${iconClass}"></i> ${getText(textKey)}`;
            }
        }
    });
    
    // Update show details dropdown items
    const showDetailsDropdownItems = document.querySelectorAll('.show-details-dropdown-item');
    showDetailsDropdownItems.forEach(item => {
        const action = item.getAttribute('data-action');
        const icon = item.querySelector('i');
        const iconClass = icon ? icon.className : '';
        
        let textKey = '';
        switch(action) {
            case 'all-labels-detail':
                textKey = 'allLabelsDetail';
                break;
            case 'all-defects-detail':
                textKey = 'allDefectsDetail';
                break;
        }
        
        if (textKey && icon) {
            item.innerHTML = `<i class="${iconClass}"></i> ${getText(textKey)}`;
        }
    });
    
    // Update clear data dropdown items
    const clearDataDropdownItems = document.querySelectorAll('.clear-data-dropdown-item');
    clearDataDropdownItems.forEach(item => {
        const action = item.getAttribute('data-action');
        const icon = item.querySelector('i');
        const iconClass = icon ? icon.className : '';
        
        let textKey = '';
        switch(action) {
            case 'clear-all-labels':
                textKey = 'clearAllLabels';
                break;
            case 'clear-all-defect-marks':
                textKey = 'clearAllDefectMarks';
                break;
            case 'clear-all-data':
                textKey = 'clearAllLabelsAndDefectMarks';
                break;
        }
        
        if (textKey && icon) {
            item.innerHTML = `<i class="${iconClass}"></i> ${getText(textKey)}`;
        }
    });
    
    // Update floor plan buttons
    const zoomTo100Btn = document.getElementById('zoomTo100Btn');
    if (zoomTo100Btn) {
        zoomTo100Btn.title = getText('zoomTo100AndCenter');
    }
    
    const closeFloorPlanBtn = document.getElementById('closeFloorPlanBtn');
    if (closeFloorPlanBtn) {
        closeFloorPlanBtn.title = getText('close');
    }
    
    // Update floor plan upload area text
    const uploadAreaText = document.querySelector('#floorPlanUploadArea p');
    if (uploadAreaText) {
        uploadAreaText.textContent = getText('clickToUploadPDFFloorPlan');
    }
    
    const uploadBtn = document.getElementById('uploadFloorPlanBtn');
    if (uploadBtn) {
        uploadBtn.textContent = getText('chooseFile');
    }
    
    // Update labels data reminder
    const labelsDataReminder = document.getElementById('labelsDataReminder');
    if (labelsDataReminder) {
        const reminderTitle = labelsDataReminder.querySelector('h4');
        if (reminderTitle) {
            reminderTitle.textContent = getText('previousFloorPlanDataFound');
        }
    }
    
    // Update quick label instruction
    const quickLabelInstruction = document.getElementById('quickLabelInstruction');
    if (quickLabelInstruction) {
        const labelText = quickLabelInstruction.querySelector('.quick-label-text');
        const defectText = quickLabelInstruction.querySelector('.quick-defect-text');
        
        if (labelText) {
            labelText.textContent = getText('clickToAddLabel');
        }
        if (defectText) {
            defectText.textContent = getText('clickToAddDefect');
        }
    }
    
    // Update previous floor plan elements
    updatePreviousFloorPlanElements();
    
    // Update floor plan header
    updateFloorPlanHeader();
    
    // Update detail table containers
    updateDetailTableContainers();
}

function updatePreviousFloorPlanElements() {
    // Update labels data reminder title
    const labelsDataReminder = document.getElementById('labelsDataReminder');
    if (labelsDataReminder) {
        const reminderTitle = labelsDataReminder.querySelector('h4');
        if (reminderTitle) {
            reminderTitle.textContent = getText('previousFloorPlanDataFound');
        }
        
        // Update reminder description
        const reminderDescription = labelsDataReminder.querySelector('p');
        if (reminderDescription) {
            reminderDescription.textContent = getText('youHaveLabelDataFromPreviousFloorPlan');
        }
        
        // Update previous file info
        const previousFileInfo = labelsDataReminder.querySelector('.previous-file-info');
        if (previousFileInfo) {
            const strongElement = previousFileInfo.querySelector('strong');
            if (strongElement) {
                strongElement.textContent = getText('previousFile');
            }
        }
        
        // Update open previous floor plan button
        const openPreviousFloorPlanBtn = document.getElementById('openPreviousFloorPlanBtn');
        if (openPreviousFloorPlanBtn) {
            const icon = openPreviousFloorPlanBtn.querySelector('i');
            const iconClass = icon ? icon.className : '';
            openPreviousFloorPlanBtn.innerHTML = `<i class="${iconClass}"></i> ${getText('openPreviousFloorPlan')}`;
        }
    }
}

function updateFloorPlanHeader() {
    // Update floor plan header title
    const floorPlanHeader = document.querySelector('.floor-plan-header');
    if (floorPlanHeader) {
        const titleElement = floorPlanHeader.querySelector('h3');
        if (titleElement) {
            const icon = titleElement.querySelector('i');
            const iconClass = icon ? icon.className : '';
            titleElement.innerHTML = `<i class="${iconClass}"></i> ${getText('floorPlanTitle')}`;
        }
    }
}

function updateFloorPlanHeaderTexts() {
    // Update floor plan dropdown items
    const newFloorPlanItem = document.querySelector('.floor-plan-dropdown-item[data-action="new-floor-plan"] span[data-text="newFloorPlan"]');
    if (newFloorPlanItem) {
        newFloorPlanItem.textContent = getText('newFloorPlan');
    }
    
    const exportPDFItem = document.querySelector('.floor-plan-dropdown-item[data-action="export-to-pdf"] span[data-text="exportAsPDF"]');
    if (exportPDFItem) {
        exportPDFItem.textContent = getText('exportAsPDF');
    }
    
    // Update drawing mode title
    const drawingModeTitle = document.querySelector('h3 span[data-text="drawingMode"]');
    if (drawingModeTitle) {
        drawingModeTitle.textContent = getText('drawingMode');
    }
    
    // Update quick label text
    const quickLabelText = document.querySelector('.quick-label-switch-container span[data-text="quickLabel"]');
    if (quickLabelText) {
        quickLabelText.textContent = getText('quickLabel');
    }
    
    // Update defect mark instruction
    const defectMarkInstruction = document.querySelector('#defectMarkInstruction span[data-text="doubleClickToPlaceDefectMark"]');
    if (defectMarkInstruction) {
        defectMarkInstruction.textContent = getText('doubleClickToPlaceDefectMark');
    }
    
    // Update label size text
    const labelSizeText = document.querySelector('.zoom-controls span[data-text="labelSize"]');
    if (labelSizeText) {
        labelSizeText.textContent = getText('labelSize');
    }
    
    // Update defect size text
    const defectSizeText = document.querySelector('.zoom-controls span[data-text="defectSize"]');
    if (defectSizeText) {
        defectSizeText.textContent = getText('defectSize');
    }
    
    // Update button titles
    const allLabelsDetailBtn = document.querySelector('.action-btn[data-action="all-labels-detail"]');
    if (allLabelsDetailBtn) {
        allLabelsDetailBtn.title = getText('allLabelsDetail');
    }
    
    const allDefectsDetailBtn = document.querySelector('.action-btn[data-action="all-defects-detail"]');
    if (allDefectsDetailBtn) {
        allDefectsDetailBtn.title = getText('allDefectsDetail');
    }
    
    const zoomTo100Btn = document.querySelector('#zoomTo100Btn');
    if (zoomTo100Btn) {
        zoomTo100Btn.title = getText('zoomTo100AndCenter');
    }
    
    const closeFloorPlanBtn = document.querySelector('#closeFloorPlanBtn');
    if (closeFloorPlanBtn) {
        closeFloorPlanBtn.title = getText('close');
    }
    
    // Update floor plan content texts
    const previousFloorPlanDataFound = document.querySelector('#labelsDataReminder h4[data-text="previousFloorPlanDataFound"]');
    if (previousFloorPlanDataFound) {
        previousFloorPlanDataFound.textContent = getText('previousFloorPlanDataFound');
    }
    
    const previousFloorPlanDataDescription = document.querySelector('#labelsDataReminder p[data-text="previousFloorPlanDataDescription"]');
    if (previousFloorPlanDataDescription) {
        previousFloorPlanDataDescription.textContent = getText('previousFloorPlanDataDescription');
    }
    
    const previousFile = document.querySelector('#labelsDataReminder .previous-file-info strong[data-text="previousFile"]');
    if (previousFile) {
        previousFile.textContent = getText('previousFile');
    }
    
    const openPreviousFloorPlanBtn = document.querySelector('#openPreviousFloorPlanBtn span[data-text="openPreviousFloorPlan"]');
    if (openPreviousFloorPlanBtn) {
        openPreviousFloorPlanBtn.textContent = getText('openPreviousFloorPlan');
    }
    
    const clickToUploadPDFFloorPlan = document.querySelector('#uploadPlaceholder p[data-text="clickToUploadPDFFloorPlan"]');
    if (clickToUploadPDFFloorPlan) {
        clickToUploadPDFFloorPlan.textContent = getText('clickToUploadPDFFloorPlan');
    }
    
    const chooseFileBtn = document.querySelector('#uploadFloorPlanBtn span[data-text="chooseFile"]');
    if (chooseFileBtn) {
        chooseFileBtn.textContent = getText('chooseFile');
    }
    
    // Update quick label instruction
    const quickLabelInstruction = document.querySelector('#quickLabelInstruction span[data-text="doubleClickToPlaceLabel"]');
    if (quickLabelInstruction) {
        quickLabelInstruction.textContent = getText('doubleClickToPlaceLabel');
    }
    
    // Update label modal texts
    const newLabelTitle = document.querySelector('.label-modal-header h4[data-text="newLabel"]');
    if (newLabelTitle) {
        newLabelTitle.textContent = getText('newLabel');
    }
    
    const inspectionNoRequired = document.querySelector('label[data-text="inspectionNoRequired"]');
    if (inspectionNoRequired) {
        inspectionNoRequired.textContent = getText('inspectionNoRequired');
    }
    
    const floorOptional = document.querySelector('label[data-text="floorOptional"]');
    if (floorOptional) {
        floorOptional.textContent = getText('floorOptional');
    }
    
    const areaNameOptional = document.querySelector('label[data-text="areaNameOptional"]');
    if (areaNameOptional) {
        areaNameOptional.textContent = getText('areaNameOptional');
    }
    
    const roomNoOptional = document.querySelector('label[data-text="roomNoOptional"]');
    if (roomNoOptional) {
        roomNoOptional.textContent = getText('roomNoOptional');
    }
    
    const inspectionDateOptional = document.querySelector('label[data-text="inspectionDateOptional"]');
    if (inspectionDateOptional) {
        inspectionDateOptional.textContent = getText('inspectionDateOptional');
    }
    
    // Update placeholders
    const enterFloorNumber = document.querySelector('input[data-placeholder="enterFloorNumber"]');
    if (enterFloorNumber) {
        enterFloorNumber.placeholder = getText('enterFloorNumber');
    }
    
    const enterAreaName = document.querySelector('input[data-placeholder="enterAreaName"]');
    if (enterAreaName) {
        enterAreaName.placeholder = getText('enterAreaName');
    }
    
    const enterRoomNumber = document.querySelector('input[data-placeholder="enterRoomNumber"]');
    if (enterRoomNumber) {
        enterRoomNumber.placeholder = getText('enterRoomNumber');
    }
    
    // Update form notes
    const onlyInspectionNoRequired = document.querySelector('.form-note small[data-text="onlyInspectionNoRequired"]');
    if (onlyInspectionNoRequired) {
        onlyInspectionNoRequired.textContent = getText('onlyInspectionNoRequired');
    }
    
    const otherFieldsOptional = document.querySelector('.form-note small[data-text="otherFieldsOptional"]');
    if (otherFieldsOptional) {
        otherFieldsOptional.textContent = getText('otherFieldsOptional');
    }
    
    // Update buttons
    const labelCancelBtn = document.querySelector('#labelCancelBtn[data-text="cancel"]');
    if (labelCancelBtn) {
        labelCancelBtn.textContent = getText('cancel');
    }
    
    const labelCreateBtn = document.querySelector('#labelCreateBtn[data-text="create"]');
    if (labelCreateBtn) {
        labelCreateBtn.textContent = getText('create');
    }
    
    const assignToNewRecordBtn = document.querySelector('#assignToNewRecordBtn[data-text="saveAndAssignToNewRecord"]');
    if (assignToNewRecordBtn) {
        assignToNewRecordBtn.textContent = getText('saveAndAssignToNewRecord');
    }
    
    // Update session restore modal texts
    const restorePreviousSession = document.querySelector('#sessionRestoreModal h3 span[data-text="restorePreviousSession"]');
    if (restorePreviousSession) {
        restorePreviousSession.textContent = getText('restorePreviousSession');
    }
    
    const sessionRestoreDescription = document.querySelector('#sessionRestoreModal p[data-text="sessionRestoreDescription"]');
    if (sessionRestoreDescription) {
        sessionRestoreDescription.textContent = getText('sessionRestoreDescription');
    }
    
    const previousFloorPlanPDFAndLabels = document.querySelector('#sessionRestoreModal li span[data-text="previousFloorPlanPDFAndLabels"]');
    if (previousFloorPlanPDFAndLabels) {
        previousFloorPlanPDFAndLabels.textContent = getText('previousFloorPlanPDFAndLabels');
    }
    
    const previouslyLoadedPhotosAndAssignments = document.querySelector('#sessionRestoreModal li span[data-text="previouslyLoadedPhotosAndAssignments"]');
    if (previouslyLoadedPhotosAndAssignments) {
        previouslyLoadedPhotosAndAssignments.textContent = getText('previouslyLoadedPhotosAndAssignments');
    }
    
    const defectEntriesAndViewState = document.querySelector('#sessionRestoreModal li span[data-text="defectEntriesAndViewState"]');
    if (defectEntriesAndViewState) {
        defectEntriesAndViewState.textContent = getText('defectEntriesAndViewState');
    }
    
    const previousTaskData = document.querySelector('#sessionRestoreModal li span[data-text="previousTaskData"]');
    if (previousTaskData) {
        previousTaskData.textContent = getText('previousTaskData');
    }
    
    const startFreshBtn = document.querySelector('#startFreshBtn span[data-text="startFresh"]');
    if (startFreshBtn) {
        startFreshBtn.textContent = getText('startFresh');
    }
    
    const restoreSessionBtn = document.querySelector('#restoreSessionBtn span[data-text="openPrevious"]');
    if (restoreSessionBtn) {
        restoreSessionBtn.textContent = getText('openPrevious');
    }
    
    // Update session language toggle text
    const sessionLanguageToggleText = document.getElementById('sessionLanguageToggleText');
    if (sessionLanguageToggleText) {
        sessionLanguageToggleText.textContent = getText('languageToggleText');
    }
}

function updateDetailTableContainers() {
    // Update all labels detail table container title
    const labelsDetailTableContainer = document.querySelector('[data-action="all-labels-detail"]');
    if (labelsDetailTableContainer) {
        const titleElement = labelsDetailTableContainer.querySelector('.modal-title');
        if (titleElement) {
            titleElement.textContent = getText('allLabelsDetailTableContainer');
        }
    }
    
    // Update all defects detail table container title
    const defectsDetailTableContainer = document.querySelector('[data-action="all-defects-detail"]');
    if (defectsDetailTableContainer) {
        const titleElement = defectsDetailTableContainer.querySelector('.modal-title');
        if (titleElement) {
            titleElement.textContent = getText('allDefectsDetailTableContainer');
        }
    }
}

function initializeLanguageSystem() {
    // Load saved language preference, default to English if none saved
    const savedLanguage = localStorage.getItem('selectedLanguage');
    if (savedLanguage && languages[savedLanguage]) {
        currentLanguage = savedLanguage;
    } else {
        // Default to English if no saved preference
        currentLanguage = 'en-GB';
    }
    
    // Set initial language toggle state
    const languageToggle = document.getElementById('languageToggle');
    if (languageToggle) {
        languageToggle.checked = currentLanguage === 'en-GB';
        
        // Add event listener for language toggle
        languageToggle.addEventListener('change', function() {
            const newLanguage = this.checked ? 'en-GB' : 'zh-TW';
            setLanguage(newLanguage);
        });
    }
    
    // Initialize session restore modal language toggle
    const sessionLanguageToggle = document.getElementById('sessionLanguageToggle');
    if (sessionLanguageToggle) {
        sessionLanguageToggle.checked = currentLanguage === 'en-GB';
        
        // Add event listener for session language toggle
        sessionLanguageToggle.addEventListener('change', function() {
            const newLanguage = this.checked ? 'en-GB' : 'zh-TW';
            setLanguage(newLanguage);
        });
    }
    
    // Update all texts with current language
    updateAllTexts();
    
    window.logger.log('Language system initialized with:', currentLanguage);
}

// å…¨å±€å‡½æ•¸å®šç¾©
// æ›´æ–°æ‰€æœ‰æ¨™ç±¤çš„å¤§å° - å…¨å±€å‡½æ•¸
window.updateAllLabelSizes = function() {
    window.logger.log('=== UPDATE ALL LABEL SIZES ===');
    
    // å˜—è©¦ç²å– labelLayer
    let labelLayer = window.labelLayer || document.getElementById('labelLayer');
    if (!labelLayer) {
        window.logger.warn('Label layer not found, skipping size update');
        return;
    }
    
    // ç¢ºä¿ labels è®Šæ•¸å­˜åœ¨ - æª¢æŸ¥å¤šå€‹å¯èƒ½çš„ä¾†æº
    let labels = window.labels;
    if (typeof labels === 'undefined' || !Array.isArray(labels)) {
        // å˜—è©¦å¾å…¨å±€è®Šæ•¸ç²å–
        labels = window.labels;
        if (typeof labels === 'undefined' || !Array.isArray(labels)) {
        window.logger.warn('Labels array not found, skipping size update');
        return;
        }
    }
    
    window.logger.log('Found label layer:', labelLayer);
    window.logger.log('Found labels array:', labels.length, 'labels');
    window.logger.log('Current label size scale:', window.labelSizeScale);
    
    const labelElements = labelLayer.querySelectorAll('.floor-plan-label');
    window.logger.log('Found label elements:', labelElements.length);
    labelElements.forEach((labelElement, index) => {
        const labelId = labelElement.dataset.labelId;
        const labelData = labels.find(l => l.id == labelId);
        
        window.logger.log(`Processing label ${index + 1}:`, { labelId, labelData: !!labelData });
        
        if (labelData) {
            // ä½¿ç”¨èˆ‡ updateSingleLabelPosition ç›¸åŒçš„ä¸­å¿ƒé»è¨ˆç®—é‚è¼¯
            // ç²å–æ¨™ç±¤çš„ç•«å¸ƒåº§æ¨™ï¼ˆé€™æ˜¯æ¨™ç±¤çš„å¯¦éš›ä¸­å¿ƒé»ä½ç½®ï¼‰
            const canvasX = labelData.canvasPosition ? labelData.canvasPosition.x : (labelData.x || 0);
            const canvasY = labelData.canvasPosition ? labelData.canvasPosition.y : (labelData.y || 0);
            
            // è¨ˆç®—è¢å¹•ä¸­å¿ƒé»ä½ç½®ï¼ˆèˆ‡ updateSingleLabelPosition ç›¸åŒçš„é‚è¼¯ï¼‰
            const screenCenterX = canvasX * (window.currentScale || 1) + (window.translateX || 0);
            const screenCenterY = canvasY * (window.currentScale || 1) + (window.translateY || 0);
            
            window.logger.log(`Label ${labelId} canvas center:`, { x: canvasX, y: canvasY });
            window.logger.log(`Label ${labelId} screen center:`, { x: screenCenterX, y: screenCenterY });
            
            // æ›´æ–°æ¨™ç±¤æ•¸æ“šä¸­çš„å­—é«”å¤§å°
            labelData.baseFontSize = window.labelSizeScale;
            // é‡æ–°è¨ˆç®—ç¸®æ”¾å¾Œçš„å­—é«”å¤§å°
            const scaledFontSize = window.labelSizeScale * (window.currentScale || 1);
            labelElement.style.fontSize = scaledFontSize + 'px';
            
            // å‹•æ…‹æ›´æ–°paddingï¼Œç¢ºä¿æ¨™ç±¤å½¢ç‹€ä¿æŒå›ºå®š
            const basePaddingX = 12;
            const basePaddingY = 8;
            const scaledPaddingX = Math.max(4, basePaddingX / (window.currentScale || 1));
            const scaledPaddingY = Math.max(4, basePaddingY / (window.currentScale || 1));
            labelElement.style.padding = `${scaledPaddingY}px ${scaledPaddingX}px`;
            
            window.logger.log(`Updated label ${labelId} font size to:`, scaledFontSize + 'px');
            
            // ç­‰å¾…å­—é«”å¤§å°æ›´æ–°å¾Œé‡æ–°è¨ˆç®—ä½ç½®
            setTimeout(() => {
                // ç²å–æ›´æ–°å¾Œçš„æ¨™ç±¤å°ºå¯¸
                const labelWidth = labelElement.offsetWidth;
                const labelHeight = labelElement.offsetHeight;
                
                // ä½¿ç”¨å¯¦éš›å°ºå¯¸ï¼Œå¦å‰‡ä¼°ç®—
                const finalWidth = labelWidth > 0 ? labelWidth : Math.max(100, scaledFontSize * 8);
                const finalHeight = labelHeight > 0 ? labelHeight : Math.max(30, scaledFontSize * 2);
                
                // é‡æ–°å®šä½æ¨™ç±¤ï¼Œä½¿å…¶ä¸­å¿ƒä½æ–¼è¨ˆç®—çš„é»ï¼ˆèˆ‡ updateSingleLabelPosition ç›¸åŒçš„é‚è¼¯ï¼‰
                labelElement.style.left = (screenCenterX - finalWidth / 2) + 'px';
                labelElement.style.top = (screenCenterY - finalHeight / 2) + 'px';
                
                window.logger.log(`Label ${labelId} repositioned to center:`, { 
                    left: labelElement.style.left, 
                    top: labelElement.style.top,
                    center: { x: screenCenterX, y: screenCenterY },
                    dimensions: { width: finalWidth, height: finalHeight }
                });
            }, 10);
        }
    });
    
    // ä¿å­˜æ›´æ–°å¾Œçš„æ¨™ç±¤æ•¸æ“š
    if (typeof window.saveLabelsToStorage === 'function') {
        window.saveLabelsToStorage();
    }
    
    window.logger.log('Label size update completed');
};

// æ›´æ–°æ‰€æœ‰ç¼ºé™·æ¨™è¨˜çš„å¤§å° - å…¨å±€å‡½æ•¸
window.updateAllDefectMarkSizes = function() {
    window.logger.log('=== UPDATE ALL DEFECT MARK SIZES ===');
    
    // å˜—è©¦ç²å– labelLayer
    let labelLayer = window.labelLayer || document.getElementById('labelLayer');
    if (!labelLayer) {
        window.logger.warn('Label layer not found, skipping size update');
        return;
    }
    
    // ç¢ºä¿ defectMarks è®Šæ•¸å­˜åœ¨ - æª¢æŸ¥å¤šå€‹å¯èƒ½çš„ä¾†æº
    let defectMarks = window.defectMarks;
    if (typeof defectMarks === 'undefined' || !Array.isArray(defectMarks)) {
        // å˜—è©¦å¾å…¨å±€è®Šæ•¸ç²å–
        defectMarks = window.defectMarks;
        if (typeof defectMarks === 'undefined' || !Array.isArray(defectMarks)) {
        window.logger.warn('Defect marks array not found, skipping size update');
        return;
        }
    }
    
    window.logger.log('Found label layer:', labelLayer);
    window.logger.log('Found defect marks array:', defectMarks.length, 'defect marks');
    window.logger.log('Current defect mark size scale:', window.defectMarkSizeScale);
    
    const defectElements = labelLayer.querySelectorAll('.defect-mark-dot, .defect-mark-textbox');
    window.logger.log('Found defect elements:', defectElements.length);
    
    defectElements.forEach((element, index) => {
        const defectId = element.dataset.defectMarkId || element.dataset.defectId;
        const defectData = defectMarks.find(d => d.id == defectId);
        
        window.logger.log(`Processing defect ${index + 1}:`, { defectId, defectData: !!defectData });
        
        if (defectData) {
            // æ›´æ–°ç¼ºé™·æ¨™è¨˜æ•¸æ“šä¸­çš„å¤§å°
            defectData.size = window.defectMarkSizeScale;
            
            if (element.classList.contains('defect-mark-dot')) {
                // æ›´æ–°ç´…é»å¤§å°
                const scaledSize = window.defectMarkSizeScale * (window.currentScale || 1);
                const scaledFontSize = Math.max(8, scaledSize * 0.5); // å­—é«”å¤§å°ç‚ºç¸®æ”¾å¾Œåœ“é»å¤§å°çš„50%
                element.style.width = scaledSize + 'px';
                element.style.height = scaledSize + 'px';
                element.style.fontSize = scaledFontSize + 'px';
                element.style.borderRadius = (scaledSize / 2) + 'px';
                window.logger.log(`Updated defect dot ${defectId} size to:`, scaledSize + 'px', 'font size:', scaledFontSize + 'px');
            } else if (element.classList.contains('defect-mark-textbox')) {
                // æ›´æ–°æ–‡å­—æ¡†å¤§å°
                const scaledSize = window.defectMarkSizeScale * (window.currentScale || 1);
                const scaledFontSize = Math.max(8, scaledSize * 0.4); // æ–‡å­—æ¡†å­—é«”å¤§å°ç‚ºç¸®æ”¾å¾Œåœ“é»å¤§å°çš„40%
                const scaledPadding = 5 * (window.currentScale || 1); // ç¸®æ”¾ padding
                
                element.style.fontSize = scaledFontSize + 'px';
                element.style.padding = scaledPadding + 'px';
                element.style.borderRadius = '4px';
                element.style.width = 'auto';
                element.style.height = 'auto';
                element.style.minWidth = 'fit-content';
                element.style.minHeight = 'fit-content';
                element.style.display = 'flex';
                element.style.alignItems = 'center';
                element.style.justifyContent = 'center';
                
                window.logger.log(`Updated defect textbox ${defectId} font size to:`, scaledFontSize + 'px');
            }
            
            // å¤§å°æ›´æ–°å®Œæˆï¼Œä½ç½®å°‡åœ¨å¾ŒçºŒçš„ updateAllDefectMarkPositions ä¸­é‡æ–°è¨ˆç®—
        }
    });
    
    // æ›´æ–°æ‰€æœ‰ç¼ºé™·æ¨™è¨˜çš„ä½ç½®å’Œé€£æ¥ç·š
    setTimeout(() => {
        if (typeof window.updateAllDefectMarkPositions === 'function') {
            window.updateAllDefectMarkPositions();
        }
    }, 50);
    
    // ä¿å­˜æ›´æ–°å¾Œçš„ç¼ºé™·æ¨™è¨˜æ•¸æ“š
    if (typeof window.saveDefectMarksToStorage === 'function') {
        window.saveDefectMarksToStorage();
    }
    
    window.logger.log('Defect mark size update completed');
};

// æ¨™ç±¤å¤§å°èª¿æ•´åŠŸèƒ½
window.initLabelSizeAdjustment = function() {
    window.logger.log('=== INITIALIZING LABEL SIZE SLIDER ===');
    const labelSizeSlider = document.getElementById('labelSizeSlider');
    const labelSizeValue = document.getElementById('labelSizeValue');
    
    window.logger.log('Label size slider element:', labelSizeSlider);
    window.logger.log('Label size value element:', labelSizeValue);
    window.logger.log('Floor plan overlay display:', document.getElementById('floorPlanOverlay')?.style.display);
    
    if (!labelSizeSlider || !labelSizeValue) {
        window.logger.log('Label size elements not found:', { slider: !!labelSizeSlider, value: !!labelSizeValue });
        window.logger.log('Retrying in 500ms...');
        setTimeout(() => {
            window.initLabelSizeAdjustment();
        }, 500);
        return;
    }
    
    // å¾localStorageè¼‰å…¥æ¨™ç±¤å¤§å°
    const savedLabelSize = localStorage.getItem('pne_label_size_scale');
    if (savedLabelSize) {
        const size = parseInt(savedLabelSize);
        labelSizeSlider.value = size;
        labelSizeValue.textContent = size + 'px';
        window.logger.log('Loaded label size from localStorage:', size + 'px');
    }
    
    // ç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    if (labelSizeSlider._inputHandler) {
    labelSizeSlider.removeEventListener('input', labelSizeSlider._inputHandler);
    }
    
    // æ¨™ç±¤å¤§å°æ»‘å‹•æ¢äº‹ä»¶
    labelSizeSlider._inputHandler = function() {
        window.logger.log('Label size slider input event triggered!');
        const size = parseInt(this.value);
        labelSizeValue.textContent = size + 'px';
        
        // æ›´æ–°å…¨å±€è®Šé‡
            window.labelSizeScale = size;
        
        // ä¿å­˜åˆ°localStorage
        localStorage.setItem('pne_label_size_scale', size.toString());
        
        // æ›´æ–°æ‰€æœ‰ç¾æœ‰æ¨™ç±¤çš„å¤§å°
        window.updateAllLabelSizes();
        
        window.logger.log('Label size updated:', size + 'px');
    };
    
    window.logger.log('Adding input event listener to label size slider');
    labelSizeSlider.addEventListener('input', labelSizeSlider._inputHandler);
    window.logger.log('Label size slider event listener added successfully');
    
    window.logger.log('Label size adjustment initialized successfully');
};

// ç¼ºé™·æ¨™è¨˜å¤§å°èª¿æ•´åŠŸèƒ½
window.initDefectMarkSizeAdjustment = function() {
    window.logger.log('=== INITIALIZING DEFECT MARK SIZE SLIDER ===');
    const defectSizeSlider = document.getElementById('defectSizeSlider');
    const defectSizeValue = document.getElementById('defectSizeValue');
    
    window.logger.log('Defect mark size slider element:', defectSizeSlider);
    window.logger.log('Defect mark size value element:', defectSizeValue);
    window.logger.log('Floor plan overlay display:', document.getElementById('floorPlanOverlay')?.style.display);
    
    if (!defectSizeSlider || !defectSizeValue) {
        window.logger.log('Defect mark size elements not found:', { slider: !!defectSizeSlider, value: !!defectSizeValue });
        window.logger.log('Retrying in 500ms...');
        setTimeout(() => {
            window.initDefectMarkSizeAdjustment();
        }, 500);
        return;
    }
    
    // å¾localStorageè¼‰å…¥ç¼ºé™·æ¨™è¨˜å¤§å°
    const savedDefectSize = localStorage.getItem('pne_defect_mark_size_scale');
    if (savedDefectSize) {
        const size = parseInt(savedDefectSize);
        defectSizeSlider.value = size;
        defectSizeValue.textContent = size + 'px';
        window.logger.log('Loaded defect mark size from localStorage:', size + 'px');
    }
    
    // ç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    if (defectSizeSlider._inputHandler) {
    defectSizeSlider.removeEventListener('input', defectSizeSlider._inputHandler);
    }
    
    // ç¼ºé™·æ¨™è¨˜å¤§å°æ»‘å‹•æ¢äº‹ä»¶
    defectSizeSlider._inputHandler = function() {
        window.logger.log('Defect mark size slider input event triggered!');
        const size = parseInt(this.value);
        defectSizeValue.textContent = size + 'px';
        
        // æ›´æ–°å…¨å±€è®Šé‡
            window.defectMarkSizeScale = size;
        
        // ä¿å­˜åˆ°localStorage
        localStorage.setItem('pne_defect_mark_size_scale', size.toString());
        
        // æ›´æ–°æ‰€æœ‰ç¾æœ‰ç¼ºé™·æ¨™è¨˜çš„å¤§å°
        window.updateAllDefectMarkSizes();
        
        window.logger.log('Defect mark size updated:', size + 'px');
    };
    
    window.logger.log('Adding input event listener to defect mark size slider');
    defectSizeSlider.addEventListener('input', defectSizeSlider._inputHandler);
    window.logger.log('Defect mark size slider event listener added successfully');
    
    window.logger.log('Defect mark size adjustment initialized successfully');
};

// æ¸¬è©¦æ»‘å¡ŠåŠŸèƒ½çš„å‡½æ•¸
window.testSliders = function() {
    window.logger.log('=== TESTING SLIDERS ===');
    
    const labelSlider = document.getElementById('labelSizeSlider');
    const labelValue = document.getElementById('labelSizeValue');
    const defectSlider = document.getElementById('defectSizeSlider');
    const defectValue = document.getElementById('defectSizeValue');
    
    window.logger.log('Label slider:', labelSlider);
    window.logger.log('Label value:', labelValue);
    window.logger.log('Defect slider:', defectSlider);
    window.logger.log('Defect value:', defectValue);
    
    if (labelSlider) {
        window.logger.log('Label slider value:', labelSlider.value);
        window.logger.log('Label slider min:', labelSlider.min);
        window.logger.log('Label slider max:', labelSlider.max);
    }
    
    if (defectSlider) {
        window.logger.log('Defect slider value:', defectSlider.value);
        window.logger.log('Defect slider min:', defectSlider.min);
        window.logger.log('Defect slider max:', defectSlider.max);
    }
    
    // æ¸¬è©¦æ‰‹å‹•è§¸ç™¼äº‹ä»¶
    if (labelSlider) {
        window.logger.log('Testing label slider event...');
        labelSlider.value = '30';
        const event = new Event('input', { bubbles: true });
        labelSlider.dispatchEvent(event);
    }
    
    if (defectSlider) {
        window.logger.log('Testing defect slider event...');
        defectSlider.value = '25';
        const event = new Event('input', { bubbles: true });
        defectSlider.dispatchEvent(event);
    }
};

// æ¸¬è©¦ç¼ºé™·æ¨™è¨˜æ»‘æ¡¿çš„å°ˆç”¨å‡½æ•¸
window.testDefectSlider = function() {
    window.logger.log('=== TESTING DEFECT MARK SLIDER ===');
    
    const defectSlider = document.getElementById('defectSizeSlider');
    const defectValue = document.getElementById('defectSizeValue');
    
    window.logger.log('Defect slider element:', defectSlider);
    window.logger.log('Defect value element:', defectValue);
    
    if (defectSlider) {
        window.logger.log('Current defect slider value:', defectSlider.value);
        window.logger.log('Current defect mark size scale:', window.defectMarkSizeScale);
        
        // æ¸¬è©¦è¨­ç½®æ–°å€¼
        defectSlider.value = '35';
        window.logger.log('Set defect slider to 35');
        
        // æ‰‹å‹•è§¸ç™¼inputäº‹ä»¶
        const event = new Event('input', { bubbles: true });
        defectSlider.dispatchEvent(event);
        
        window.logger.log('After event - defect slider value:', defectSlider.value);
        window.logger.log('After event - defect mark size scale:', window.defectMarkSizeScale);
        window.logger.log('After event - defect value text:', defectValue.textContent);
    } else {
        window.logger.error('Defect slider not found!');
    }
};

// ç¸®æ”¾å’Œå¹³ç§»äº‹ä»¶è¨­ç½®åŠŸèƒ½ - å…¨å±€å®šç¾©ï¼Œç¢ºä¿åœ¨æ‰€æœ‰åœ°æ–¹éƒ½å¯ç”¨
window.setupZoomAndPanEvents = function() {
    const floorPlanViewer = document.getElementById('floorPlanViewer');
    if (!floorPlanViewer) {
        window.logger.error('setupZoomAndPanEvents: floorPlanViewer not found');
        return;
    }
    
    window.logger.log('setupZoomAndPanEvents: Setting up pan and zoom events');
    
    // ä½¿ç”¨å…¨å±€è®Šæ•¸æˆ–å‰µå»ºå®ƒå€‘
    if (typeof window.isPanning === 'undefined') window.isPanning = false;
    if (typeof window.lastX === 'undefined') window.lastX = 0;
    if (typeof window.lastY === 'undefined') window.lastY = 0;
    if (typeof window.isLabelCreationMode === 'undefined') window.isLabelCreationMode = false;
    if (typeof window.isDefectMarkCreationMode === 'undefined') window.isDefectMarkCreationMode = false;
    if (typeof window.translateX === 'undefined') window.translateX = 0;
    if (typeof window.translateY === 'undefined') window.translateY = 0;
    if (typeof window.currentScale === 'undefined') window.currentScale = 1.0;
    
    // ç¸®æ”¾äº‹ä»¶
    floorPlanViewer.onwheel = function(event) {
        // æª¢æŸ¥å¿«é€Ÿæ¨™ç±¤æ¨¡å¼ç‹€æ…‹
        const quickLabelSwitch = document.getElementById('quickLabelSwitch');
        const quickLabelMode = quickLabelSwitch ? quickLabelSwitch.checked : false;
        
        // å¦‚æœæ­£åœ¨å‰µå»ºæ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜ï¼Œæˆ–å¿«é€Ÿæ¨™ç±¤æ¨¡å¼å•Ÿç”¨ï¼Œä¸å…è¨±ç¸®æ”¾
        if (window.isLabelCreationMode || window.isDefectMarkCreationMode || quickLabelMode) return;
        
        event.preventDefault();
        const delta = -event.deltaY; // up: positive
        const zoomFactor = delta > 0 ? 1.05 : 0.95;

        const rect = floorPlanViewer.getBoundingClientRect();
        const cursorX = event.clientX - rect.left;
        const cursorY = event.clientY - rect.top;

        // Convert cursor to canvas-local coords before scaling
        const canvasXBefore = (cursorX - window.translateX) / window.currentScale;
        const canvasYBefore = (cursorY - window.translateY) / window.currentScale;

        // æ›´æ–°å…¨å±€è®Šé‡
        window.currentScale = Math.max(0.1, Math.min(10, window.currentScale * zoomFactor));

        // After new scale, compute new translate so cursor remains at same canvas point
        window.translateX = cursorX - canvasXBefore * window.currentScale;
        window.translateY = cursorY - canvasYBefore * window.currentScale;

        if (typeof window.applyTransform === 'function') {
            window.applyTransform();
        }
        
        // ä¿å­˜è¦–åœ–ç‹€æ…‹
        if (typeof saveCurrentViewState === 'function') {
            saveCurrentViewState();
        }
        
        // åŒæ™‚ä¿å­˜åˆ°localStorageä½œç‚ºå‚™ä»½
        try {
            const viewState = {
                scale: window.currentScale || 1.0,
                translateX: window.translateX || 0,
                translateY: window.translateY || 0,
                timestamp: Date.now()
            };
            localStorage.setItem('pne_current_view_state', JSON.stringify(viewState));
        } catch (error) {
            window.logger.error('Failed to save view state to localStorage:', error);
        }
    };
    
    // å¹³ç§»äº‹ä»¶
    floorPlanViewer.onmousedown = function(event) {
        window.logger.log('Pan mousedown event triggered');
        
        // æª¢æŸ¥å¿«é€Ÿæ¨™ç±¤æ¨¡å¼ç‹€æ…‹
        const quickLabelSwitch = document.getElementById('quickLabelSwitch');
        const quickLabelMode = quickLabelSwitch ? quickLabelSwitch.checked : false;
        
        // å¦‚æœæ­£åœ¨å‰µå»ºæ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜ï¼Œæˆ–å¿«é€Ÿæ¨™ç±¤æ¨¡å¼å•Ÿç”¨ï¼Œä¸å…è¨±æ‹–æ‹½
        if (window.isLabelCreationMode || window.isDefectMarkCreationMode || quickLabelMode) {
            window.logger.log('Pan blocked: label or defect mark creation mode active, or quick label mode enabled');
            return;
        }
        
        window.isPanning = true;
        window.lastX = event.clientX;
        window.lastY = event.clientY;
        window.logger.log('Pan started:', { isPanning: window.isPanning, lastX: window.lastX, lastY: window.lastY });
        if (!window.isLabelCreationMode && !window.isDefectMarkCreationMode && !quickLabelMode) {
            floorPlanViewer.style.cursor = 'grabbing';
        }
    };
    
    // æ»‘é¼ ç§»å‹•äº‹ä»¶
    window.onmousemove = function(event) {
        // æª¢æŸ¥å¿«é€Ÿæ¨™ç±¤æ¨¡å¼ç‹€æ…‹
        const quickLabelSwitch = document.getElementById('quickLabelSwitch');
        const quickLabelMode = quickLabelSwitch ? quickLabelSwitch.checked : false;
        
        if (!window.isPanning || window.isLabelCreationMode || window.isDefectMarkCreationMode || quickLabelMode) return;
        const dx = event.clientX - window.lastX;
        const dy = event.clientY - window.lastY;
        window.lastX = event.clientX;
        window.lastY = event.clientY;
        // æ›´æ–°å…¨å±€è®Šé‡
        window.translateX += dx;
        window.translateY += dy;
        window.logger.log('Pan move:', { dx, dy, translateX: window.translateX, translateY: window.translateY });
        if (typeof window.applyTransform === 'function') {
            window.applyTransform();
        } else {
            window.logger.error('applyTransform function not available');
        }
        
        // ä¿å­˜è¦–åœ–ç‹€æ…‹
        if (typeof saveCurrentViewState === 'function') {
            saveCurrentViewState();
        }
        
        // åŒæ™‚ä¿å­˜åˆ°localStorageä½œç‚ºå‚™ä»½
        try {
            const viewState = {
                scale: window.currentScale || 1.0,
                translateX: window.translateX || 0,
                translateY: window.translateY || 0,
                timestamp: Date.now()
            };
            localStorage.setItem('pne_current_view_state', JSON.stringify(viewState));
        } catch (error) {
            window.logger.error('Failed to save view state to localStorage:', error);
        }
    };
    
    // æ»‘é¼ é‡‹æ”¾äº‹ä»¶
    window.onmouseup = function() {
        window.logger.log('Pan mouseup event triggered');
        window.isPanning = false;
        
        // æª¢æŸ¥å¿«é€Ÿæ¨™ç±¤æ¨¡å¼ç‹€æ…‹
        const quickLabelSwitch = document.getElementById('quickLabelSwitch');
        const quickLabelMode = quickLabelSwitch ? quickLabelSwitch.checked : false;
        
        if (!window.isLabelCreationMode && !window.isDefectMarkCreationMode && !quickLabelMode) {
            floorPlanViewer.style.cursor = 'grab';
        }
    };
    
    // è§¸æ§æ¿æ”¯æŒ - å…©æŒ‡ç§»å‹•å¹³ç§»
    let lastTouchDistance = 0;
    let lastTouchCenterX = 0;
    let lastTouchCenterY = 0;
    let isTwoFingerPanning = false;
    
    // è§¸æ§é–‹å§‹äº‹ä»¶
    floorPlanViewer.addEventListener('touchstart', function(event) {
        // æª¢æŸ¥å¿«é€Ÿæ¨™ç±¤æ¨¡å¼ç‹€æ…‹
        const quickLabelSwitch = document.getElementById('quickLabelSwitch');
        const quickLabelMode = quickLabelSwitch ? quickLabelSwitch.checked : false;
        
        // å¦‚æœæ­£åœ¨å‰µå»ºæ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜ï¼Œæˆ–å¿«é€Ÿæ¨™ç±¤æ¨¡å¼å•Ÿç”¨ï¼Œä¸å…è¨±è§¸æ§æ“ä½œ
        if (window.isLabelCreationMode || window.isDefectMarkCreationMode || quickLabelMode) return;
        
        if (event.touches.length === 2) {
            // å…©æŒ‡è§¸æ§ - æº–å‚™å¹³ç§»
            event.preventDefault();
            isTwoFingerPanning = true;
            
            const touch1 = event.touches[0];
            const touch2 = event.touches[1];
            
            // è¨ˆç®—å…©æŒ‡ä¸­å¿ƒé»
            lastTouchCenterX = (touch1.clientX + touch2.clientX) / 2;
            lastTouchCenterY = (touch1.clientY + touch2.clientY) / 2;
            
            // è¨ˆç®—å…©æŒ‡è·é›¢ï¼ˆç”¨æ–¼ç¸®æ”¾æª¢æ¸¬ï¼‰
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            
            window.logger.log('Two finger touch start:', {
                centerX: lastTouchCenterX,
                centerY: lastTouchCenterY,
                distance: lastTouchDistance
            });
        }
    });
    
    // è§¸æ§ç§»å‹•äº‹ä»¶
    floorPlanViewer.addEventListener('touchmove', function(event) {
        // æª¢æŸ¥å¿«é€Ÿæ¨™ç±¤æ¨¡å¼ç‹€æ…‹
        const quickLabelSwitch = document.getElementById('quickLabelSwitch');
        const quickLabelMode = quickLabelSwitch ? quickLabelSwitch.checked : false;
        
        // å¦‚æœæ­£åœ¨å‰µå»ºæ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜ï¼Œæˆ–å¿«é€Ÿæ¨™ç±¤æ¨¡å¼å•Ÿç”¨ï¼Œä¸å…è¨±è§¸æ§æ“ä½œ
        if (window.isLabelCreationMode || window.isDefectMarkCreationMode || quickLabelMode) return;
        
        if (event.touches.length === 2 && isTwoFingerPanning) {
            event.preventDefault();
            
            const touch1 = event.touches[0];
            const touch2 = event.touches[1];
            
            // è¨ˆç®—ç•¶å‰å…©æŒ‡ä¸­å¿ƒé»
            const currentTouchCenterX = (touch1.clientX + touch2.clientX) / 2;
            const currentTouchCenterY = (touch1.clientY + touch2.clientY) / 2;
            
            // è¨ˆç®—å…©æŒ‡è·é›¢è®ŠåŒ–
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            const currentTouchDistance = Math.sqrt(dx * dx + dy * dy);
            
            // æª¢æŸ¥æ˜¯å¦ç‚ºç¸®æ”¾æ‰‹å‹¢ï¼ˆè·é›¢è®ŠåŒ–è¼ƒå¤§ï¼‰
            const distanceChange = Math.abs(currentTouchDistance - lastTouchDistance);
            const distanceChangeThreshold = 10; // ç¸®æ”¾æª¢æ¸¬é–¾å€¼
            
            if (distanceChange > distanceChangeThreshold) {
                // ç¸®æ”¾æ‰‹å‹¢
                const zoomFactor = currentTouchDistance > lastTouchDistance ? 1.02 : 0.98;
                
                const rect = floorPlanViewer.getBoundingClientRect();
                const centerX = currentTouchCenterX - rect.left;
                const centerY = currentTouchCenterY - rect.top;
                
                // Convert center to canvas-local coords before scaling
                const canvasXBefore = (centerX - window.translateX) / window.currentScale;
                const canvasYBefore = (centerY - window.translateY) / window.currentScale;
                
                // æ›´æ–°å…¨å±€è®Šé‡
                window.currentScale = Math.max(0.1, Math.min(10, window.currentScale * zoomFactor));
                
                // After new scale, compute new translate so center remains at same canvas point
                window.translateX = centerX - canvasXBefore * window.currentScale;
                window.translateY = centerY - canvasYBefore * window.currentScale;
                
                if (typeof window.applyTransform === 'function') {
                    window.applyTransform();
                }
                
                // ä¿å­˜è¦–åœ–ç‹€æ…‹
                if (typeof saveCurrentViewState === 'function') {
                    saveCurrentViewState();
                }
                
                // åŒæ™‚ä¿å­˜åˆ°localStorageä½œç‚ºå‚™ä»½
                try {
                    const viewState = {
                        scale: window.currentScale || 1.0,
                        translateX: window.translateX || 0,
                        translateY: window.translateY || 0,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('pne_current_view_state', JSON.stringify(viewState));
                } catch (error) {
                    window.logger.error('Failed to save view state to localStorage:', error);
                }
                
                lastTouchDistance = currentTouchDistance;
            } else {
                // å¹³ç§»æ‰‹å‹¢
                const deltaX = currentTouchCenterX - lastTouchCenterX;
                const deltaY = currentTouchCenterY - lastTouchCenterY;
                
                // æ›´æ–°å…¨å±€è®Šé‡
                window.translateX += deltaX;
                window.translateY += deltaY;
                
                window.logger.log('Two finger pan:', {
                    deltaX, deltaY,
                    translateX: window.translateX,
                    translateY: window.translateY
                });
                
                if (typeof window.applyTransform === 'function') {
                    window.applyTransform();
                }
                
                // ä¿å­˜è¦–åœ–ç‹€æ…‹
                if (typeof saveCurrentViewState === 'function') {
                    saveCurrentViewState();
                }
                
                // åŒæ™‚ä¿å­˜åˆ°localStorageä½œç‚ºå‚™ä»½
                try {
                    const viewState = {
                        scale: window.currentScale || 1.0,
                        translateX: window.translateX || 0,
                        translateY: window.translateY || 0,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('pne_current_view_state', JSON.stringify(viewState));
                } catch (error) {
                    window.logger.error('Failed to save view state to localStorage:', error);
                }
            }
            
            // æ›´æ–°ä¸Šæ¬¡è§¸æ§ä¸­å¿ƒé»
            lastTouchCenterX = currentTouchCenterX;
            lastTouchCenterY = currentTouchCenterY;
        }
    });
    
    // è§¸æ§çµæŸäº‹ä»¶
    floorPlanViewer.addEventListener('touchend', function(event) {
        if (event.touches.length < 2) {
            isTwoFingerPanning = false;
            lastTouchDistance = 0;
            window.logger.log('Two finger touch end');
        }
    });
    
    // è¨­ç½®åˆå§‹æ¸¸æ¨™æ¨£å¼
    const quickLabelSwitch = document.getElementById('quickLabelSwitch');
    const quickLabelMode = quickLabelSwitch ? quickLabelSwitch.checked : false;
    floorPlanViewer.style.cursor = quickLabelMode ? 'crosshair' : 'grab';
};

// Updated category data with new names
const categories = [
    {
        id: 'a',
        name: 'Exposed structural metalwork',
        icon: 'fa-hard-hat',
        color: 'var(--category-a)'
    },
    {
        id: 'b',
        name: 'Structural elements',
        icon: 'fa-cubes',
        color: 'var(--category-b)'
    },
    {
        id: 'c',
        name: 'External building elements',
        icon: 'fa-building',
        color: 'var(--category-c)'
    },
    {
        id: 'd',
        name: 'Suspended objects',
        icon: 'fa-layer-group',
        color: 'var(--category-d)'
    },
    {
        id: 'e',
        name: 'High level internal finishes',
        icon: 'fa-gem',
        color: 'var(--category-e)'
    },
    {
        id: 'f',
        name: 'Heavy metal gates/doors',
        icon: 'fa-door-open',
        color: 'var(--category-f)'
    },
    {
        id: 'g',
        name: 'Window and glass louvers',
        icon: 'fa-window-maximize',
        color: 'var(--category-g)'
    },
    {
        id: 'h',
        name: 'Drainage and Plumbing systems',
        icon: 'fa-faucet',
        color: 'var(--category-h)'
    },
    {
        id: 'i',
        name: 'Fire safety elements',
        icon: 'fa-fire-extinguisher',
        color: 'var(--category-i)'
    },
    {
        id: 'j',
        name: 'Defects',
        icon: 'fa-bug',
        color: 'var(--category-j)'
    }
];

// Defect types organized by category
const defectTypes = {
    a: [
        "The steel column is heavily rusted",
        "The steel beam is heavily rusted",
        "The metal frame is heavily rusted",
        "The metal panel is heavily rusted",
        "The metal roof is leaking",
        "The metal roof is heavily rusted and leaking"
    ],
    b: [
        "Water seepage is observed around the pipe penetrating the wall",
        "Water stains on ceiling",
        "Loose concrete at pipe sleeve",
        "Concrete spalling is observed around the pipe penetrating the ceiling",
        "Water seepage is observed from the concrete wall",
        "Water seepage from the concrete ceiling and the steel bar is exposed",
        "Water leakage is observed from the crack in concrete ceiling",
        "Concrete spalling on ceiling",
        "The vinyl floor mat is cracked and protrudes upward",
        "Water seepage from the ceiling",
        "Water seepage is observed around the drainpipe penetrating the concrete ceiling",
        "The abandoned steel bar is exposed",
        "Concrete spalling is observed in the ceiling",
        "The concrete steel bar is exposed",
        "Water leakage and concrete spalling is observed in the ceiling",
        "The concrete ceiling is cracked and leaking",
        "Water leakage is observed around the drainpipe penetrating the concrete ceiling",
        "Water seepage is observed around the cable tray penetrating the ceiling",
        "The wall tiles is damaged",
        "Water leakage is observed from the glass panel",
        "Water leakage is observed from the ceiling",
        "The abandoned concrete pipe is damaged",
        "Multiple crack have developed across the ceiling",
        "Multiple floor tiles were damaged",
        "Water will accumulate on the floor",
        "Multiple crack have developed on the concrete slab",
        "Hollow areas and cracking were observed on the floor screed"
    ],
    c: [
        "Hollow areas and cracking were observed on the plastered wall",
        "Hollow areas and cracking were observed on the wall tiles",
        "Cracking in wall plastering",
        "The dry wall is damaged"
    ],
    d: [
        "Gauge hanger wire damaged",
        "The gypsum board ceiling protrudes downward",
        "Abandoned object leave in false ceiling",
        "There are a lot of discarded debris in the false ceiling",
        "The tie wire of the false ceiling frame is loose",
        "Ceiling panel is missing",
        "Improper fixing on ceiling",
        "The false ceiling frame is heavily rusted and damaged",
        "The false ceiling panel is damaged"
    ],
    e: [
        "The wall tile is damaged"
    ],
    f: [
        "The metal gate is heavily rusted",
        "The door leaf is damaged",
        "The mortise bolt on the wooden door is missing",
        "The door closer is damaged",
        "The door closer is inoperative",
        "The door closer is missing",
        "The door leaf and frame is damaged",
        "The door coordinator has lost functionality",
        "The welded joint at the hinge of the metal door is fractured",
        "The door frame is damaged",
        "The door hinge is damaged",
        "The door hinge is loose",
        "The door handle is loose",
        "The metal door is stuck and cannot be opened",
        "The door closer is loose",
        "The wooden louver is damaged",
        "The door lock is damaged",
        "The screw is missing from the hinge",
        "The door coordinator is missing",
        "The push bar is loose",
        "The push bar is damaged",
        "The door leaf is loose and difficult to operate"
    ],
    g: [
        "Multiple cracks have developed across the glass block wall",
        "The window gasket has aged",
        "The window lock is inoperative",
        "The window lock is damaged",
        "The window gasket is damaged",
        "Water seepage is observed from the edge of window frame",
        "The window restrictor damaged",
        "Corrosion is observed in the aluminium window frame",
        "The window hinge is damaged",
        "The rivet is rusted",
        "The metal louver is heavily rusted",
        "The glass louver is heavily rusted and damaged"
    ],
    h: [
        "The drainpipe is rusted and water seepage is observed from the connection clamp",
        "The metal trap is rusted",
        "Incipient leakage from the pinholes in the copper pipe",
        "No vent cap installed on the pipe termination",
        "The drainpipe is heavily rusted",
        "The pipe bracket is loose",
        "Water leakage is observed from the water pipe",
        "The metal trap is leaking",
        "Water leakage is observed from the drainpipe",
        "The drainpipe is heavily rusted and leaking",
        "Water leakage is observed from the connection clamp of drainpipe",
        "The parapet wall drain grill is damaged",
        "The metal trap is heavily rusted",
        "The metal trap is heavily rusted and leaking",
        "Incipient leakage is observed from the pinhole in the drainpipe",
        "The drainpipe is heavily rusted and damaged",
        "The drainpipe is rusted",
        "The abandoned drainpipe is rusted",
        "The water supply pipe is heavily rusted",
        "The drainpipe has a reverse slope, causing water to pool instead of flowing out",
        "An abandoned drainpipe in ceiling",
        "An abandoned trap in ceiling",
        "The metal trap is damaged",
        "The water supply pipe is leaking",
        "The water pipe valve is heavily rusted",
        "The metal trap and drainpipe are heavily rusted and leaking",
        "The metal trap and drainpipe are rusted",
        "Water leakage is observed from the valve of A/C water pipe",
        "The push bar of fire door is loose"
    ],
    i: [
        "The smoke detector is obstructed by a plastic bag, impairing its functionality",
        "The glass of the nozzle storage box of the fire hose reel was broken",
        "The fire door leaf is damaged",
        "The mortise bolt on the fire door is missing",
        "The fire door closer is damaged",
        "The fire door closer is inoperative",
        "The fire door closer is missing",
        "The fire door leaf and frame is damaged",
        "The fire door coordinator has lost functionality",
        "The fire door frame is damaged",
        "The fire door hinge is damaged",
        "The fire door hinge is loose",
        "The fire door handle is loose",
        "The fire door closer is loose",
        "The fire door lock is damaged",
        "The screw is missing from the fire door hinge",
        "The fire door coordinator is missing",
        "The push bar of fire door is damaged",
        "The fire door leaf is loose and difficult to operate",
        "The metal louver of the fire door is heavily rusted"
    ]
};

// Store numbers for each category
const categoryNumbers = {};
// Store assigned photos by filename
const assignedPhotos = {};

// Store defect entries as objects
window.defectEntries = window.defectEntries || [];
window.submittedDefectEntries = window.submittedDefectEntries || [];

categories.forEach(category => {
    categoryNumbers[category.id] = [];
    assignedPhotos[category.id] = new Set();
});

// Store submitted data
let submittedData = [];

// Initialize global inspection records (same reference as submittedData)
window.inspectionRecords = submittedData;

// Store selected photos
let selectedPhotos = [];

// Auto create defect mark mode
let autoCreateDefectMarkMode = false;

let allPhotos = [];

// Photo hash storage: Map<filename, contentHash>
// Used to detect duplicate photos based on content hash
let photoHashStorage = new Map();

/**
 * Calculate content hash for a file using SHA-256
 * @param {File} file - The file to calculate hash for
 * @returns {Promise<string>} - The hexadecimal hash string
 */
async function calculateFileHash(file) {
    try {
        const arrayBuffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
    } catch (error) {
        window.logger.error('Error calculating file hash:', error);
        // Fallback: use file name and size as hash if crypto API fails
        return `${file.name}_${file.size}_${file.lastModified}`;
    }
}

/**
 * Check if a photo is a duplicate based on filename and content hash
 * @param {string} filename - The filename to check
 * @param {string} contentHash - The content hash to check
 * @returns {boolean} - True if duplicate (same filename AND same hash), false otherwise
 */
function isDuplicatePhoto(filename, contentHash) {
    const existingHash = photoHashStorage.get(filename);
    // Only block if filename is same AND content hash is same
    return existingHash === contentHash;
}

// Store folders for export
let photoFolders = [];

// Task management - Simplified for single task
let currentTask = null;

// Store submitted filenames
let submittedFilenames = new Set();

// Row ID counter for tracking
let rowIdCounter = 0;

// DOM Elements
const folderNameDisplay = document.getElementById('folderNameDisplay');
const photoGrid = document.getElementById('photoGrid');
const selectedCount = document.getElementById('selectedCount');
const categoriesGrid = document.getElementById('categoriesGrid');
const clearBtn = document.getElementById('clearBtn');
const submitBtn = document.getElementById('submitBtn');
// const exportBtn = document.getElementById('exportBtn'); // Moved to DOMContentLoaded
const dataTableBody = document.getElementById('dataTableBody');
const tableCount = document.getElementById('tableCount');
const locationIdInput = document.getElementById('locationId');
const inspectionDateInput = document.getElementById('inspectionDate');
const roomNoInput = document.getElementById('roomNo');
const sortToggle = document.getElementById('sortToggle');
const globalOverlay = document.getElementById('globalOverlay');
const cancelResetBtn = document.getElementById('cancelResetBtn');
const forceResetBtn = document.getElementById('forceResetBtn');
const defectWindow = document.getElementById('defectWindow');
const defectCategorySelect = document.getElementById('defectCategory');
const defectTypeSelect = document.getElementById('defectTypeSelect');
const defectTypeDirectInput = document.getElementById('defectTypeDirectInput');
const defectSearchInput = document.getElementById('defectSearchInput');
const searchClearBtn = document.getElementById('searchClearBtn');
const defectOptionsList = document.getElementById('defectOptionsList');
const defectCancelBtn = document.getElementById('defectCancelBtn');
// defectAssignBtn moved to setupDefectAssignButton() function
let zoomSlider = null; // Will be initialized in DOMContentLoaded
const imminentDangerSwitch = document.getElementById('imminentDangerSwitch');

// Set default date to today
inspectionDateInput.valueAsDate = new Date();

// Initialize categories
function initCategories() {
    categoriesGrid.innerHTML = '';
    
    categories.forEach(category => {
        const card = document.createElement('div');
        card.className = `category-card ${category.id === 'j' ? 'defects-card' : ''}`;
        
        // Get localized category name
        const categoryKey = `category${category.id.toUpperCase()}`;
        const localizedName = getText(categoryKey);
        
        card.innerHTML = `
            <div class="category-header ${category.id}" data-category="${category.id}" role="button" aria-label="Assign to ${localizedName}">
                <div class="category-header-text">
                    <i class="fas ${category.icon}"></i> ${localizedName}
                </div>
                <span class="count-badge" id="count-${category.id}">0</span>
            </div>
            <div class="category-content" id="result-${category.id}">
                <!-- Numbers will appear here -->
            </div>
            <button class="clear-category-btn" data-category="${category.id}" title="Clear this category" aria-label="Clear ${localizedName}">
                <i class="fas fa-times"></i>
            </button>
        `;
        categoriesGrid.appendChild(card);
        
        // Add click event to category header
        const header = card.querySelector('.category-header');
        header.addEventListener('click', () => {
            if (category.id === 'j') {
                showDefectWindow();
            } else {
                assignToCategory(category.id);
            }
        });
        
        // Add click event to clear category button
        const clearBtn = card.querySelector('.clear-category-btn');
        clearBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            clearCategory(category.id);
        });
    });
}

// Update folder name display based on state
function updateFolderDisplay() {
    window.logger.log('updateFolderDisplay called');
    window.logger.log('folderNameDisplay element:', folderNameDisplay);
    window.logger.log('folderNameDisplay textContent:', folderNameDisplay ? folderNameDisplay.textContent : 'N/A');
    window.logger.log('allPhotos length:', allPhotos.length);
    
    if (folderNameDisplay && folderNameDisplay.textContent && allPhotos.length > 0) {
        folderNameDisplay.classList.remove('empty');
        window.logger.log('Folder display updated - not empty');
    } else {
        if (folderNameDisplay) {
            folderNameDisplay.classList.add('empty');
            window.logger.log('Folder display updated - empty');
        } else {
            window.logger.log('folderNameDisplay element not found');
        }
    }
}

// è‡ªå‹•åˆ†é… Defect No. å‡½æ•¸
function assignDefectNo() {
    try {
        const defectNoInput = document.getElementById('defectNo');
        if (!defectNoInput) return;
        
        // å¾ all defects detail-table-container çš„æ•¸æ“šæº (defectEntries) ä¸­ç²å–æœ€æ–°çš„ç¼ºé™·ç·¨è™Ÿ
        let nextDefectNo = 1; // é»˜èªå¾ 1 é–‹å§‹
        
        if (window.defectEntries && window.defectEntries.length > 0) {
            // æ‰¾åˆ°æ‰€æœ‰æœ‰æ•ˆçš„ç¼ºé™·ç·¨è™Ÿ
            const defectNumbers = window.defectEntries
                .map(entry => {
                    const defectNo = parseInt(entry.defectNo);
                    return isNaN(defectNo) ? 0 : defectNo;
                })
                .filter(num => num > 0);
            
            if (defectNumbers.length > 0) {
                // ç²å–æœ€å¤§çš„ç¼ºé™·ç·¨è™Ÿä¸¦åŠ  1
                const maxDefectNo = Math.max(...defectNumbers);
                nextDefectNo = maxDefectNo + 1;
            }
        }
        
        // è¨­ç½® defect no. åˆ°è¼¸å…¥æ¡†
        defectNoInput.value = nextDefectNo.toString();
        
        window.logger.log('Defect No. assigned:', nextDefectNo, 'based on all defects detail-table-container');
        window.logger.log('Current defectEntries count:', window.defectEntries ? window.defectEntries.length : 0);
        
    } catch (error) {
        window.logger.error('Error assigning defect no.:', error);
    }
}

// é‡æ–°æ’åˆ—ç¼ºé™·ç·¨è™Ÿå‡½æ•¸
function renumberDefectEntries() {
    try {
        window.logger.log('Starting defect renumbering process...');
        
        if (!window.defectEntries || window.defectEntries.length === 0) {
            window.logger.log('No defect entries to renumber');
            return;
        }
        
        // æŒ‰å‰µå»ºé †åºæ’åºï¼ˆä½¿ç”¨idæˆ–æ™‚é–“æˆ³ï¼‰
        const sortedEntries = [...window.defectEntries].sort((a, b) => {
            // å¦‚æœæœ‰idå­—æ®µï¼ŒæŒ‰idæ’åºï¼›å¦å‰‡æŒ‰å…¶ä»–é‚è¼¯æ’åº
            if (a.id && b.id) {
                return a.id - b.id;
            }
            // å¦‚æœæ²’æœ‰idï¼Œå¯ä»¥æŒ‰å…¶ä»–å­—æ®µæ’åºï¼Œé€™è£¡æš«æ™‚ä¿æŒåŸé †åº
            return 0;
        });
        
        // å‰µå»ºèˆŠç·¨è™Ÿåˆ°æ–°ç·¨è™Ÿçš„æ˜ å°„
        const defectNoMapping = {};
        let newDefectNo = 1;
        
        // ç‚ºæ¯å€‹ç¼ºé™·åˆ†é…æ–°çš„é€£çºŒç·¨è™Ÿï¼Œä½†ä¿æŒåŸå§‹çš„æª¢æŸ¥ç·¨è™Ÿ
        sortedEntries.forEach(entry => {
            const oldDefectNo = entry.defectNo;
            const newDefectNoStr = newDefectNo.toString();
            
            // è¨˜éŒ„åŸå§‹æª¢æŸ¥ç·¨è™Ÿï¼Œç¢ºä¿é‡æ–°ç·¨è™Ÿæ™‚ä¸æ”¹è®Š
            const originalInspectionNo = entry.inspectionNo || entry.locationId;
            
            defectNoMapping[oldDefectNo] = newDefectNoStr;
            entry.defectNo = newDefectNoStr;
            
            // ç¢ºä¿æª¢æŸ¥ç·¨è™Ÿä¿æŒä¸è®Š
            if (originalInspectionNo) {
                entry.inspectionNo = originalInspectionNo;
                entry.locationId = originalInspectionNo;
            }
            
            window.logger.log(`Renumbered defect: ${oldDefectNo} -> ${newDefectNoStr}, inspectionNo: ${originalInspectionNo}`);
            newDefectNo++;
        });
        
        // æ›´æ–° submittedDefectEntries
        if (window.submittedDefectEntries && window.submittedDefectEntries.length > 0) {
            window.submittedDefectEntries.forEach(entry => {
                if (defectNoMapping[entry.defectNo]) {
                    // è¨˜éŒ„åŸå§‹æª¢æŸ¥ç·¨è™Ÿ
                    const originalInspectionNo = entry.inspectionNo || entry.locationId;
                    
                    entry.defectNo = defectNoMapping[entry.defectNo];
                    
                    // ç¢ºä¿æª¢æŸ¥ç·¨è™Ÿä¿æŒä¸è®Š
                    if (originalInspectionNo) {
                        entry.inspectionNo = originalInspectionNo;
                        entry.locationId = originalInspectionNo;
                    }
                }
            });
        }
        
        // æ›´æ–°ç¼ºé™·æ¨™è¨˜
        if (window.defectMarks && window.defectMarks.length > 0) {
            window.defectMarks.forEach(mark => {
                if (defectNoMapping[mark.defectNo]) {
                    mark.defectNo = defectNoMapping[mark.defectNo];
                }
            });
            
            // ä¿å­˜æ›´æ–°å¾Œçš„ç¼ºé™·æ¨™è¨˜
            if (typeof saveDefectMarksToStorage === 'function') {
                saveDefectMarksToStorage();
            }
        }
        
        // æ³¨æ„ï¼šæ¨™ç±¤ç·¨è™Ÿä¸æ‡‰è©²è¢«è‡ªå‹•é‡æ–°ç·¨è™Ÿ
        // æ¨™ç±¤çš„ inspectionNo æ‡‰è©²ä¿æŒç”¨æˆ¶è¨­å®šçš„å€¼
        // åªæœ‰ç¼ºé™·æ¨™è¨˜éœ€è¦é‡æ–°ç·¨è™Ÿ
        window.logger.log('Labels numbering preserved - only defect marks are renumbered');
        
        // æ›´æ–°é¡åˆ¥å…§å®¹ä¸­çš„ç¼ºé™·ç·¨è™Ÿ
        if (window.categoryNumbers && window.categoryNumbers.j) {
            window.categoryNumbers.j = window.categoryNumbers.j.map(entry => {
                // åŒ¹é…æ ¼å¼: "ç·¨è™Ÿ) ç¯„åœ_æè¿°"
                const match = entry.match(/^(\d+)\)\s*(.+)$/);
                if (match) {
                    const oldDefectNo = match[1];
                    const restOfEntry = match[2];
                    if (defectNoMapping[oldDefectNo]) {
                        return `${defectNoMapping[oldDefectNo]}) ${restOfEntry}`;
                    }
                }
                return entry;
            });
        }
        
        // æ›´æ–°æª¢æŸ¥è¨˜éŒ„ä¸­çš„ç¼ºé™·ç·¨è™Ÿ
        if (window.submittedData && window.submittedData.length > 0) {
            window.submittedData.forEach(record => {
                if (record.j && record.j !== 'N/A') {
                    const defects = record.j.split('\n');
                    const updatedDefects = defects.map(defect => {
                        const match = defect.match(/^(\*?\s*)(\d+)\)\s*(.+)$/);
                        if (match) {
                            const prefix = match[1]; // å¯èƒ½åŒ…å« "* " å‰ç¶´
                            const oldDefectNo = match[2];
                            const restOfDefect = match[3];
                            if (defectNoMapping[oldDefectNo]) {
                                return `${prefix}${defectNoMapping[oldDefectNo]}) ${restOfDefect}`;
                            }
                        }
                        return defect;
                    });
                    record.j = updatedDefects.join('\n');
                }
            });
        }
        
        // ä¿å­˜æ‰€æœ‰æ›´æ–°å¾Œçš„æ•¸æ“š
        saveDataToStorage();
        
        // é‡æ–°æ¸²æŸ“ç›¸é—œé¡¯ç¤º
        updateCategoryDisplay('j');
        
        // é‡æ–°æ¸²æŸ“ç¼ºé™·æ¨™è¨˜ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (typeof window.redrawDefectMarks === 'function') {
            window.redrawDefectMarks();
        }
        
        // é‡æ–°æ¸²æŸ“æ¨™ç±¤ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (typeof window.redrawLabels === 'function') {
            window.redrawLabels();
        }
        
        // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼
        if (typeof window.updateDefectSummaryTable === 'function') {
            window.updateDefectSummaryTable();
        }
        
        // åŒæ­¥åˆ°æ¨™ç±¤è©³ç´°è¡¨æ ¼
        if (typeof syncDefectsToLabelsDetailTable === 'function') {
            syncDefectsToLabelsDetailTable();
        }
        
        window.logger.log('Defect renumbering completed successfully');
        showNotification(getText('defectRenumbered'), 'success');
        
    } catch (error) {
        window.logger.error('Error during defect renumbering:', error);
        showNotification('é‡æ–°æ’åˆ—ç¼ºé™·ç·¨è™Ÿæ™‚ç™¼ç”ŸéŒ¯èª¤', 'error');
    }
}

// Trigger auto create defect mark workflow
function triggerAutoCreateDefectMark() {
    window.logger.log('=== TRIGGER AUTO CREATE DEFECT MARK WORKFLOW ===');
    
    if (!window.pendingDefectData) {
        window.logger.error('No pending defect data for auto create defect mark');
        return;
    }
    
    window.logger.log('Triggering auto create defect mark workflow with data:', window.pendingDefectData);
    
    // Set waiting state - user must place defect mark before closing floor plan
    window.isWaitingForDefectMarkPlacement = true;
    window.logger.log('Set waiting state for defect mark placement');
    
    // Step 1: Close defect window
    window.logger.log('Step 1: Closing defect window...');
    defectWindow.style.display = 'none';
    window.logger.log('Defect window closed');
    
    // Step 2: Open floor plan overlay
    window.logger.log('Step 2: Opening floor plan overlay...');
    const floorPlanOverlay = document.getElementById('floorPlanOverlay');
    if (floorPlanOverlay) {
        window.logger.log('Floor plan overlay element found:', floorPlanOverlay);
        window.logger.log('Current z-index:', floorPlanOverlay.style.zIndex);
        
        // Use z-index approach to bring floor plan to front
        floorPlanOverlay.style.zIndex = '1000';
        floorPlanOverlay.style.display = 'flex';
        window.logger.log('Floor plan overlay brought to front, z-index:', floorPlanOverlay.style.zIndex);
        
        // Disable close button - user must place defect mark first
        const closeBtn = document.getElementById('closeFloorPlanBtn');
        if (closeBtn) {
            closeBtn.disabled = true;
            closeBtn.style.opacity = '0.5';
            closeBtn.style.cursor = 'not-allowed';
            closeBtn.title = 'Please place the defect mark first';
            window.logger.log('Close button disabled - waiting for defect mark placement');
        }
        
        // åˆå§‹åŒ–æ»‘å¡ŠåŠŸèƒ½
        window.logger.log('Step 2.1: Initializing sliders...');
        setTimeout(() => {
            window.logger.log('Initializing label size adjustment...');
            if (typeof window.initLabelSizeAdjustment === 'function') {
                window.initLabelSizeAdjustment();
                window.logger.log('Label size adjustment initialized');
            } else {
                window.logger.warn('initLabelSizeAdjustment function not found');
            }
            
            window.logger.log('Initializing defect mark size adjustment...');
            if (typeof window.initDefectMarkSizeAdjustment === 'function') {
                window.initDefectMarkSizeAdjustment();
                window.logger.log('Defect mark size adjustment initialized');
            } else {
                window.logger.warn('initDefectMarkSizeAdjustment function not found');
            }
        }, 100);
        
        // Step 3: Show defect mark reminder popup
        window.logger.log('Step 3: Showing defect mark reminder popup...');
        setTimeout(() => {
            window.logger.log('Executing Step 3: Displaying defect mark reminder...');
            showDefectMarkReminder();
        }, 500);
    } else {
        window.logger.error('Floor plan overlay not found');
    }
    
    window.logger.log('=== TRIGGER AUTO CREATE DEFECT MARK WORKFLOW COMPLETED ===');
}

// Show defect mark reminder popup
function showDefectMarkReminder() {
    window.logger.log('=== SHOW DEFECT MARK REMINDER POPUP ===');
    window.logger.log('Showing defect mark reminder popup...');
    
    if (!window.pendingDefectData) {
        window.logger.error('No pending defect data available for reminder');
        window.logger.log('window.pendingDefectData:', window.pendingDefectData);
        return;
    }
    
    window.logger.log('Pending defect data found:', window.pendingDefectData);
    
    // Get popup elements
    const popup = document.getElementById('defectMarkReminderPopup');
    const inspectionNoSpan = document.getElementById('reminderInspectionNo');
    const defectNoSpan = document.getElementById('reminderDefectNo');
    const photoNoSpan = document.getElementById('reminderPhotoNo');
    const defectTypeSpan = document.getElementById('reminderDefectType');
    
    window.logger.log('Popup elements found:', {
        popup: !!popup,
        inspectionNoSpan: !!inspectionNoSpan,
        defectNoSpan: !!defectNoSpan,
        photoNoSpan: !!photoNoSpan,
        defectTypeSpan: !!defectTypeSpan
    });
    
    if (!popup || !inspectionNoSpan || !defectNoSpan || !photoNoSpan || !defectTypeSpan) {
        window.logger.error('Defect mark reminder popup elements not found');
        window.logger.log('Missing elements:', {
            popup: !popup,
            inspectionNoSpan: !inspectionNoSpan,
            defectNoSpan: !defectNoSpan,
            photoNoSpan: !photoNoSpan,
            defectTypeSpan: !defectTypeSpan
        });
        return;
    }
    
    // Fill in the data
    inspectionNoSpan.textContent = window.pendingDefectData.inspectionNo || '-';
    defectNoSpan.textContent = window.pendingDefectData.defectNo || '-';
    photoNoSpan.textContent = window.pendingDefectData.photoNumbers || '-';
    defectTypeSpan.textContent = window.pendingDefectData.defectType || '-';
    
    window.logger.log('Data filled in:', {
        inspectionNo: inspectionNoSpan.textContent,
        defectNo: defectNoSpan.textContent,
        photoNumbers: photoNoSpan.textContent,
        defectType: defectTypeSpan.textContent
    });
    
    // Show the popup
    popup.style.display = 'flex';
    window.logger.log('Popup display style set to:', popup.style.display);
    window.logger.log('Popup computed style:', window.getComputedStyle(popup).display);
    
    window.logger.log('Defect mark reminder popup displayed with data:', {
        inspectionNo: window.pendingDefectData.inspectionNo,
        defectNo: window.pendingDefectData.defectNo,
        photoNumbers: window.pendingDefectData.photoNumbers,
        defectType: window.pendingDefectData.defectType
    });
    window.logger.log('=== SHOW DEFECT MARK REMINDER POPUP COMPLETED ===');
}

// Hide defect mark reminder popup and enable crosshair cursor
function hideDefectMarkReminder() {
    window.logger.log('=== HIDE DEFECT MARK REMINDER ===');
    window.logger.log('Hiding defect mark reminder popup...');
    
    const popup = document.getElementById('defectMarkReminderPopup');
    if (popup) {
        popup.style.display = 'none';
        window.logger.log('Popup hidden successfully');
    } else {
        window.logger.error('Popup element not found');
    }
    
    // Enable crosshair cursor on floor plan elements
    const floorPlanOverlay = document.getElementById('floorPlanOverlay');
    const floorPlanContent = document.querySelector('.floor-plan-content');
    const floorPlanContainer = document.querySelector('.floor-plan-container');
    const labelLayer = document.getElementById('labelLayer');
    const floorPlanCanvas = document.getElementById('floorPlanCanvas');
    
    window.logger.log('Floor plan elements found:', {
        overlay: !!floorPlanOverlay,
        content: !!floorPlanContent,
        container: !!floorPlanContainer,
        labelLayer: !!labelLayer,
        canvas: !!floorPlanCanvas
    });
    
    // Apply crosshair cursor to multiple elements
    const elementsToStyle = [floorPlanOverlay, floorPlanContent, floorPlanContainer, floorPlanCanvas].filter(el => el);
    
    elementsToStyle.forEach((element, index) => {
        if (element) {
            window.logger.log(`Styling element ${index}:`, element.className || element.id);
            window.logger.log('Current classes:', element.className);
            window.logger.log('Current computed cursor style:', window.getComputedStyle(element).cursor);
            
            element.classList.add('crosshair-cursor');
            element.style.cursor = 'crosshair';
            
            window.logger.log('New classes:', element.className);
            window.logger.log('New computed cursor style:', window.getComputedStyle(element).cursor);
        }
    });
    
    // Ensure label layer doesn't interfere with cursor
    if (labelLayer) {
        window.logger.log('Label layer found, ensuring it allows cursor events');
        labelLayer.style.pointerEvents = 'none'; // Keep it as none to avoid interference
        window.logger.log('Label layer pointer-events set to none');
    }
    
    if (elementsToStyle.length === 0) {
        window.logger.error('No floor plan elements found');
        window.logger.log('Available elements with floor-plan in class name:');
        const allElements = document.querySelectorAll('[class*="floor-plan"]');
        allElements.forEach((el, index) => {
            window.logger.log(`Element ${index}:`, el.className, el.tagName);
        });
    }
    
    window.logger.log('Defect mark reminder popup hidden, crosshair cursor enabled');
    window.logger.log('=== HIDE DEFECT MARK REMINDER COMPLETED ===');
}

// Disable crosshair cursor and resume normal cursor
function disableCrosshairCursor() {
    window.logger.log('Disabling crosshair cursor...');
    
    const floorPlanOverlay = document.getElementById('floorPlanOverlay');
    const floorPlanContent = document.querySelector('.floor-plan-content');
    const floorPlanContainer = document.querySelector('.floor-plan-container');
    const floorPlanCanvas = document.getElementById('floorPlanCanvas');
    
    // Remove crosshair cursor from multiple elements
    const elementsToStyle = [floorPlanOverlay, floorPlanContent, floorPlanContainer, floorPlanCanvas].filter(el => el);
    
    elementsToStyle.forEach((element, index) => {
        if (element) {
            window.logger.log(`Removing crosshair from element ${index}:`, element.className || element.id);
            element.classList.remove('crosshair-cursor');
            element.style.cursor = '';
        }
    });
    
    window.logger.log('Crosshair cursor disabled, normal cursor resumed');
}

// Open new defect entries menu and auto fill data
function openNewDefectEntriesMenu() {
    window.logger.log('=== OPEN NEW DEFECT ENTRIES MENU ===');
    
    if (!window.pendingDefectData) {
        window.logger.error('No pending defect data for auto fill');
        return;
    }
    
    window.logger.log('Attempting to open new defect entries menu...');
    window.logger.log('Pending defect data:', window.pendingDefectData);
    
    // Find and click the Add Defect button to open the new defect entries menu
    const addDefectBtn = document.getElementById('addDefectBtn');
    window.logger.log('Looking for Add Defect button...');
    window.logger.log('Add Defect button element:', addDefectBtn);
    
    if (addDefectBtn) {
        window.logger.log('Add Defect button found, clicking...');
        window.logger.log('Button visibility:', addDefectBtn.style.display);
        window.logger.log('Button disabled state:', addDefectBtn.disabled);
        
        addDefectBtn.click();
        window.logger.log('Add Defect button clicked');
        
        // Auto fill the form after a short delay to ensure it's open
        setTimeout(() => {
            window.logger.log('Attempting to auto fill form...');
            autoFillNewDefectEntriesMenu();
        }, 500); // Increased delay to 500ms
    } else {
        window.logger.error('Add Defect button not found');
        window.logger.log('Available buttons with "add" in ID:');
        document.querySelectorAll('[id*="add"]').forEach(btn => {
            window.logger.log('- Button ID:', btn.id, 'Element:', btn);
        });
    }
    
    window.logger.log('=== OPEN NEW DEFECT ENTRIES MENU COMPLETED ===');
}

// Auto fill new defect entries menu with pending defect data - å·²ç§»é™¤æ¨¡æ…‹æ¡†

// Update defect photo numbers display
function updateDefectPhotoNumbers() {
    const defectPhotoNoInput = document.getElementById('defectPhotoNo');
    if (!defectPhotoNoInput) return;
    
    if (selectedPhotos.length === 0) {
        defectPhotoNoInput.value = '';
        return;
    }
    
    // Extract photo numbers from selected photos
    const photoNumbers = selectedPhotos.map(index => {
        const file = allPhotos[index];
        const numberMatch = file.name.match(/\d+/);
        return numberMatch ? numberMatch[0] : '';
    }).filter(num => num !== '').sort((a, b) => parseInt(a) - parseInt(b));
    
    // Format photo numbers same as defects categories content
    if (photoNumbers.length === 0) {
        defectPhotoNoInput.value = '';
    } else if (photoNumbers.length === 1) {
        defectPhotoNoInput.value = photoNumbers[0];
    } else {
        // Group consecutive numbers
        const ranges = [];
        let start = parseInt(photoNumbers[0]);
        let end = start;
        
        for (let i = 1; i < photoNumbers.length; i++) {
            const current = parseInt(photoNumbers[i]);
            if (current === end + 1) {
                end = current;
            } else {
                if (start === end) {
                    ranges.push(start.toString());
                } else {
                    ranges.push(`${start}-${end}`);
                }
                start = current;
                end = current;
            }
        }
        
        // Add the last range
        if (start === end) {
            ranges.push(start.toString());
        } else {
            ranges.push(`${start}-${end}`);
        }
        
        defectPhotoNoInput.value = ranges.join(', ');
    }
}

// Show defect window
function showDefectWindow() {
    if (selectedPhotos.length === 0) {
        showNotification('Please select photos first', 'warning');
        return;
    }
    
    // æª¢æŸ¥æª¢æŸ¥ç·¨è™Ÿæ˜¯å¦å·²å¡«å¯«
    if (!validateInspectionNumber()) {
        return;
    }
    
    // æª¢æŸ¥æ˜¯å¦åœ¨ç¹ªåœ–æ¨¡å¼ä¸‹ï¼ˆæª¢æŸ¥localStorageä¸­æ˜¯å¦æœ‰PDFæ•¸æ“šï¼‰
    const floorPlanOverlay = document.getElementById('floorPlanOverlay');
    const hasPDFData = localStorage.getItem('pne_floorplan_data') || localStorage.getItem('pne_floorplan_base64');
    const hasLabels = localStorage.getItem('pne_floorplan_labels');
    
    // æ›´å¯é çš„ç¹ªåœ–æ¨¡å¼æª¢æ¸¬ï¼šæª¢æŸ¥æ˜¯å¦æœ‰PDFæ•¸æ“šæˆ–æ¨™ç±¤æ•¸æ“š
    const isDrawingMode = hasPDFData || hasLabels;
    
    window.logger.log('Floor plan overlay check:', {
        element: !!floorPlanOverlay,
        display: floorPlanOverlay ? floorPlanOverlay.style.display : 'N/A',
        hasPDFData: !!hasPDFData,
        hasLabels: !!hasLabels,
        isDrawingMode: isDrawingMode
    });
    
    // å¦‚æœåœ¨ç¹ªåœ–æ¨¡å¼ä¸‹ï¼Œå•Ÿç”¨è‡ªå‹•å‰µå»ºç¼ºé™·æ¨™è¨˜æ¨¡å¼
    if (isDrawingMode) {
        autoCreateDefectMarkMode = true;
        window.logger.log('Drawing mode detected: Auto create defect mark mode enabled');
    } else {
        autoCreateDefectMarkMode = false;
        window.logger.log('Normal mode: Auto create defect mark mode disabled');
    }
    
    defectWindow.style.display = 'block';
    // è‡ªå‹•å¸¶å…¥ header å³å´æ¬„ä½è³‡æ–™
    var inspectionNoHeader = document.getElementById('locationId');
    var inspectionDateHeader = document.getElementById('inspectionDate');
    var floorHeader = document.getElementById('floorHeader');
    var areaNameHeader = document.getElementById('areaNameHeader');
    var roomNoHeader = document.getElementById('roomNo');

    if(document.getElementById('inspectionDateDefect')) document.getElementById('inspectionDateDefect').value = inspectionDateHeader ? inspectionDateHeader.value : '';
    if(document.getElementById('defectFloor')) document.getElementById('defectFloor').value = floorHeader ? floorHeader.value : '';
    if(document.getElementById('defectAreaName')) document.getElementById('defectAreaName').value = areaNameHeader ? areaNameHeader.value : '';
    if(document.getElementById('defectRoomNo')) document.getElementById('defectRoomNo').value = roomNoHeader ? roomNoHeader.value : '';
    
    // è‡ªå‹•å¡«å…¥ Inspection no. å¾ header
    if(document.getElementById('defectInspectionNo')) {
        const headerValue = inspectionNoHeader ? inspectionNoHeader.value : '';
        document.getElementById('defectInspectionNo').value = headerValue;
    }
    
    // è‡ªå‹•åˆ†é… Defect No. å¾ defect summary
    assignDefectNo();
    
    // é¡¯ç¤ºé¸ä¸­çš„ç…§ç‰‡ç·¨è™Ÿ
    updateDefectPhotoNumbers();
    
    defectCategorySelect.value = '';
    defectTypeSelect.classList.add('disabled');
    defectTypeSelect.classList.remove('open');
    defectTypeSelect.setAttribute('data-selected', '');
    updateDefectTypeOptions([]);
    defectSearchInput.value = '';
    defectTypeDirectInput.value = '';
    imminentDangerSwitch.checked = false; // Reset to default "No"
    
    // Reset other form fields
    if(document.getElementById('defectDescription')) document.getElementById('defectDescription').value = '';
    if(document.getElementById('defectExistingCondition')) document.getElementById('defectExistingCondition').value = '';
    if(document.getElementById('defectHumidity')) document.getElementById('defectHumidity').value = '';
    if(document.getElementById('defectMoisture')) document.getElementById('defectMoisture').value = '';
    if(document.getElementById('defectChloride')) document.getElementById('defectChloride').value = '';
    if(document.getElementById('defectCarbonation')) document.getElementById('defectCarbonation').value = '';
    if(document.getElementById('defectRemedialWorks')) document.getElementById('defectRemedialWorks').value = '';
    if(document.getElementById('defectPreventiveWorks')) document.getElementById('defectPreventiveWorks').value = '';
    if(document.getElementById('defectRemarks')) document.getElementById('defectRemarks').value = '';
}

// Handle defect category change
defectCategorySelect.addEventListener('change', function() {
    if (this.value) {
        defectTypeSelect.classList.remove('disabled');
        const defects = defectTypes[this.value];
        updateDefectTypeOptions(defects);
    } else {
        defectTypeSelect.classList.add('disabled');
        updateDefectTypeOptions([]);
    }
});

// Handle defect cancel button
defectCancelBtn.addEventListener('click', function() {
    window.logger.log('Defect cancel button clicked');
    
    // é‡ç½® defect no. å­—æ®µ
    const defectNoInput = document.getElementById('defectNo');
    if (defectNoInput) {
        defectNoInput.value = '';
    }
    
    defectWindow.style.display = 'none';
});

// Update defect type options
function updateDefectTypeOptions(defects) {
    defectOptionsList.innerHTML = '';
    
    if (defects.length === 0) {
        const option = document.createElement('span');
        option.className = 'custom-option';
        option.setAttribute('data-value', '');
        option.textContent = 'Select a category first';
        defectOptionsList.appendChild(option);
    } else {
        // Add loading indicator briefly
        const loadingOption = document.createElement('span');
        loadingOption.className = 'custom-option loading';
        loadingOption.textContent = 'Loading options...';
        defectOptionsList.appendChild(loadingOption);
        
        // Remove loading and add options after a brief delay for smooth UX
        setTimeout(() => {
            defectOptionsList.innerHTML = '';
            defects.forEach(defect => {
                const option = document.createElement('span');
                option.className = 'custom-option';
                option.setAttribute('data-value', defect);
                option.textContent = defect;
                defectOptionsList.appendChild(option);
            });
        }, 100);
    }
    
    // Update trigger text only if no value is currently selected
    const triggerSpan = defectTypeSelect.querySelector('.custom-select__trigger span');
    const currentSelected = defectTypeSelect.getAttribute('data-selected');
    if (!currentSelected) {
        if (defects.length > 0) {
            triggerSpan.textContent = `Or select from dropdown (${defects.length} options)`;
        } else {
            triggerSpan.textContent = 'Select a category first';
        }
    }
}

// Initialize custom select functionality
function initCustomSelect() {
    window.logger.log('Initializing custom select...');
    
    // Handle direct input changes
    defectTypeDirectInput.addEventListener('input', function() {
        const value = this.value.trim();
        if (value) {
            // Clear dropdown selection when user types directly
            defectTypeSelect.setAttribute('data-selected', '');
            defectTypeSelect.querySelector('.custom-select__trigger span').textContent = 'Or select from dropdown';
            
            // Clear selected styling from options
            const options = defectOptionsList.querySelectorAll('.custom-option');
            options.forEach(option => {
                option.classList.remove('selected');
            });
        }
    });
    
    // Toggle dropdown
    defectTypeSelect.addEventListener('click', function(e) {
        window.logger.log('Defect type select clicked');
        if (this.classList.contains('disabled')) return;
        
        e.stopPropagation();
        this.classList.toggle('open');
        
        if (this.classList.contains('open')) {
            // Show search container when opening dropdown
            const searchContainer = defectSearchInput.closest('.search-container');
            if (searchContainer) {
                searchContainer.classList.remove('hidden');
            }
            
            // Check if there's a selected value
            const selectedValue = this.getAttribute('data-selected');
            if (selectedValue) {
                // Show only the selected option
                const options = defectOptionsList.querySelectorAll('.custom-option');
                options.forEach(option => {
                    const value = option.getAttribute('data-value');
                    if (value === selectedValue) {
                        option.classList.remove('hidden');
                    } else {
                        option.classList.add('hidden');
                    }
                });
            } else {
                // Show all options if nothing is selected
                filterDefectOptions('');
            }
            
            setTimeout(() => {
                defectSearchInput.focus();
                window.logger.log('Search input focused');
            }, 100);
        }
    });

            // Handle option selection
defectOptionsList.addEventListener('click', function(e) {
    // Don't handle clicks on search input
    if (e.target === defectSearchInput || defectSearchInput.contains(e.target)) {
        return;
    }
    
    const option = e.target.closest('.custom-option');
    if (!option || option.classList.contains('no-results')) return;
    
    const value = option.getAttribute('data-value');
    const text = option.textContent;
    
    // Update trigger text immediately for better UX
    const triggerSpan = defectTypeSelect.querySelector('.custom-select__trigger span');
    triggerSpan.textContent = text;
    
    // Store selected value
    defectTypeSelect.setAttribute('data-selected', value);
    
    // Update direct input field with selected value
    defectTypeDirectInput.value = text;
    
    // Clear search and hide search container first
    defectSearchInput.value = '';
    const searchContainer = defectSearchInput.closest('.search-container');
    if (searchContainer) {
        searchContainer.classList.add('hidden');
    }
    
    // Show only selected option
    showOnlySelectedOption(value, text);
    
    // Close dropdown after a short delay to show the animation
    setTimeout(() => {
        defectTypeSelect.classList.remove('open');
    }, 200);
    
    // Remove any highlighted option
    const highlighted = defectOptionsList.querySelector('.custom-option.highlighted');
    if (highlighted) {
        highlighted.classList.remove('highlighted');
    }
});

    // Handle search - prevent event bubbling
    defectSearchInput.addEventListener('click', function(e) {
        window.logger.log('Search input clicked');
        e.stopPropagation();
        
        // When clicking search input, show all options for easy searching
        const selectedValue = defectTypeSelect.getAttribute('data-selected');
        if (selectedValue) {
            // Show all options when clicking search input
            const options = defectOptionsList.querySelectorAll('.custom-option');
            options.forEach(option => {
                option.classList.remove('hidden');
            });
        }
    });
    
    // Handle search clear button
    searchClearBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        defectSearchInput.value = '';
        defectSearchInput.focus();
        
        // Show all options when clearing search
        const options = defectOptionsList.querySelectorAll('.custom-option');
        options.forEach(option => {
            option.classList.remove('hidden');
        });
        
        // Remove no results message if exists
        const noResultsMsg = defectOptionsList.querySelector('.no-results');
        if (noResultsMsg) {
            noResultsMsg.remove();
        }
    });

    // Debounced search function for better performance
    let searchTimeout;
    defectSearchInput.addEventListener('input', function(e) {
        e.stopPropagation();
        const searchTerm = e.target.value.toLowerCase();
        
        // Show/hide clear button based on input content
        searchClearBtn.style.display = searchTerm ? 'block' : 'none';
        
        // Clear previous timeout
        clearTimeout(searchTimeout);
        
        // When user starts typing, show all options for searching
        const options = defectOptionsList.querySelectorAll('.custom-option');
        options.forEach(option => {
            option.classList.remove('hidden');
        });
        
        // Debounce search to improve performance
        searchTimeout = setTimeout(() => {
            // When user starts typing, show all options that match
            filterDefectOptions(searchTerm);
        }, 100);
    });

    defectSearchInput.addEventListener('keydown', function(e) {
        // Don't interfere with copy/paste operations
        if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'v' || e.key === 'C' || e.key === 'V')) {
            return; // Allow normal copy/paste to work
        }
        
        e.stopPropagation();
        if (e.key === 'Escape') {
            defectTypeSelect.classList.remove('open');
        } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            e.preventDefault();
            navigateOptions(e.key === 'ArrowDown' ? 1 : -1);
        } else if (e.key === 'Enter') {
            e.preventDefault();
            selectHighlightedOption();
        } else if (e.key === 'Tab') {
            // Allow tab navigation
            return;
        }
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', function(e) {
        if (!defectTypeSelect.contains(e.target)) {
            defectTypeSelect.classList.remove('open');
        }
    });

    // Handle keyboard navigation
    defectTypeSelect.addEventListener('keydown', function(e) {
        // Don't interfere with copy/paste operations
        if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'v' || e.key === 'C' || e.key === 'V')) {
            return; // Allow normal copy/paste to work
        }
        
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            this.classList.toggle('open');
            if (this.classList.contains('open')) {
                setTimeout(() => defectSearchInput.focus(), 100);
            }
        }
    });
}

// Keyboard navigation functions
function navigateOptions(direction) {
    const visibleOptions = Array.from(defectOptionsList.querySelectorAll('.custom-option:not(.hidden)'));
    const currentHighlighted = defectOptionsList.querySelector('.custom-option.highlighted');
    let currentIndex = currentHighlighted ? visibleOptions.indexOf(currentHighlighted) : -1;
    
    // Remove current highlight
    if (currentHighlighted) {
        currentHighlighted.classList.remove('highlighted');
    }
    
    // Calculate new index
    let newIndex;
    if (direction > 0) {
        newIndex = currentIndex < visibleOptions.length - 1 ? currentIndex + 1 : 0;
    } else {
        newIndex = currentIndex > 0 ? currentIndex - 1 : visibleOptions.length - 1;
    }
    
    // Highlight new option
    if (visibleOptions[newIndex]) {
        visibleOptions[newIndex].classList.add('highlighted');
        visibleOptions[newIndex].scrollIntoView({ block: 'nearest' });
    }
}

function selectHighlightedOption() {
    const highlighted = defectOptionsList.querySelector('.custom-option.highlighted');
    if (highlighted) {
        highlighted.click();
    }
}

// Show only the selected option in the dropdown
function showOnlySelectedOption(selectedValue, selectedText) {
    const options = defectOptionsList.querySelectorAll('.custom-option');
    
    options.forEach(option => {
        const value = option.getAttribute('data-value');
        if (value === selectedValue) {
            option.classList.remove('hidden');
            option.classList.add('selected');
        } else {
            option.classList.add('hidden');
            option.classList.remove('selected');
        }
    });
}

// Filter defect options based on search term (optimized)
function filterDefectOptions(searchTerm) {
    const options = defectOptionsList.querySelectorAll('.custom-option');
    let visibleCount = 0;
    
    options.forEach(option => {
        const text = option.textContent.toLowerCase();
        const isVisible = text.includes(searchTerm);
        
        if (isVisible) {
            option.classList.remove('hidden');
            visibleCount++;
        } else {
            option.classList.add('hidden');
        }
    });
    
    // Show "no results" message if no options match
    const noResultsMsg = defectOptionsList.querySelector('.no-results');
    if (visibleCount === 0 && searchTerm.length > 0) {
        if (!noResultsMsg) {
            const msg = document.createElement('div');
            msg.className = 'custom-option no-results';
            msg.textContent = 'No matching defect types found';
            msg.style.textAlign = 'center';
            msg.style.color = '#666';
            msg.style.fontStyle = 'italic';
            defectOptionsList.appendChild(msg);
        }
    } else if (noResultsMsg) {
        noResultsMsg.remove();
    }
}



// Format numbers with dashes for consecutive series and commas for non-consecutive
function formatDefectNumbers(numbers) {
    if (numbers.length === 0) return "";
    
    // Convert to numbers and sort numerically
    const sorted = [...numbers].map(n => parseInt(n)).sort((a, b) => a - b);
    
    let result = [];
    let start = sorted[0];
    let end = start;
    
    for (let i = 1; i < sorted.length; i++) {
        if (sorted[i] === end + 1) {
            end = sorted[i];
        } else {
            if (start === end) {
                result.push(start);
            } else {
                result.push(`${start}-${end}`);
            }
            start = sorted[i];
            end = sorted[i];
        }
    }
    
    // Add the last range
    if (start === end) {
        result.push(start);
    } else {
        result.push(`${start}-${end}`);
    }
    
    return result.join(', ');
}

// Format defect numbers preserving leading zeros
function formatDefectNumbersWithLeadingZeros(numberStrings) {
    if (numberStrings.length === 0) return "";
    
    // Create array of objects with original string and numeric value
    const numbersWithInt = numberStrings.map(numStr => ({ 
        original: numStr, 
        numeric: parseInt(numStr, 10) 
    }));
    
    // Sort by numeric value
    numbersWithInt.sort((a, b) => a.numeric - b.numeric);
    
    let result = [];
    let start = numbersWithInt[0];
    let end = start;
    
    for (let i = 1; i < numbersWithInt.length; i++) {
        const current = numbersWithInt[i];
        if (current.numeric === end.numeric + 1) {
            end = current;
        } else {
            if (start === end) {
                result.push(start.original);
            } else {
                result.push(`${start.original}-${end.original}`);
            }
            start = current;
            end = current;
        }
    }
    
    // Add the last range
    if (start === end) {
        result.push(start.original);
    } else {
        result.push(`${start.original}-${end.original}`);
    }
    
    return result.join(', ');
}
// Assign defect to photos - moved to DOMContentLoaded
function setupDefectAssignButton() {
    const defectAssignBtn = document.getElementById('defectAssignBtn');
    if (!defectAssignBtn) {
        window.logger.error('defectAssignBtn element not found');
        return;
    }
    
defectAssignBtn.addEventListener('click', function() {
    // Check if we're in edit mode
    const isEditMode = window.editingDefectId && window.editingDefectNo;
    
    const category = defectCategorySelect.value;
    // Get defect type from direct input first, fallback to dropdown selection
    const defectType = defectTypeDirectInput.value.trim() || defectTypeSelect.getAttribute('data-selected');
    const isImminent = imminentDangerSwitch.checked;
    
    // Get inspection number from header (not from the readonly field)
    const inspectionNo = document.getElementById('locationId').value.trim();
    
    // Get location data from the form fields
    const floor = document.getElementById('defectFloor').value.trim();
    const areaName = document.getElementById('defectAreaName').value.trim();
    const roomNo = document.getElementById('defectRoomNo').value.trim();
    const description = document.getElementById('defectDescription').value.trim();
    const existingCondition = document.getElementById('defectExistingCondition').value.trim();
    const humidity = document.getElementById('defectHumidity').value.trim();
    const moisture = document.getElementById('defectMoisture').value.trim();
    const chloride = document.getElementById('defectChloride').value.trim();
    const carbonation = document.getElementById('defectCarbonation').value.trim();
    const remedialWorks = document.getElementById('defectRemedialWorks').value.trim();
    const preventiveWorks = document.getElementById('defectPreventiveWorks').value.trim();
    const remarks = document.getElementById('defectRemarks').value.trim();
    
    // æ–°å¢ï¼šåŒæ­¥ header æ¬„ä½è³‡æ–™
    const headerInspectionNo = document.getElementById('locationId').value.trim();
    const inspectionDate = document.getElementById('inspectionDate').value.trim();
    
    // Always set pending defect data for double-click creation
    window.logger.log('Setting pendingDefectData for double-click defect mark creation...');
    
        // Find the full category name from the category ID
        const categoryOption = document.querySelector(`#defectCategory option[value="${category}"]`);
        const fullCategoryName = categoryOption ? categoryOption.textContent : category;
        
        // Store defect data for auto create defect mark
    window.pendingDefectData = {
            defectNo: document.getElementById('defectNo').value.trim(),
            inspectionNo: inspectionNo,
            inspectionDate: inspectionDate,
            photoNumbers: document.getElementById('defectPhotoNo').value.trim(),
            categories: fullCategoryName,
            defectType: defectType
        };
        
    window.logger.log('pendingDefectData set:', window.pendingDefectData);

    if (!category) {
        showNotification('Please select a category', 'error');
        return;
    }
    if (!defectType) {
        showNotification('Please enter or select a defect type', 'error');
        return;
    }
    
    // Extract numbers from selected photos
    const numbers = [];
    selectedPhotos.forEach(index => {
        const file = allPhotos[index];
        const fileName = file.name;
        const numberMatch = fileName.match(/\d+/);
        if (numberMatch) {
            // Store the exact string to preserve leading zeros
            numbers.push(numberMatch[0]);
        }
    });
    
    if (numbers.length === 0) {
        showNotification('No numbers found in selected photos', 'warning');
        return;
    }
    
    // Format numbers using the new function that preserves leading zeros
    const formattedNumbers = formatDefectNumbersWithLeadingZeros(numbers);
    const entry = `${formattedNumbers}_${defectType}`;
    
    // Get photo numbers from selected photos
    const photoNumbers = selectedPhotos.map(index => {
        const file = allPhotos[index];
        const numberMatch = file.name.match(/\d+/);
        return numberMatch ? numberMatch[0] : '';
    }).filter(num => num !== '').sort((a, b) => parseInt(a) - parseInt(b));
    
    // Format photo numbers same as defects categories content
    let formattedPhotoNumbers = '';
    if (photoNumbers.length > 0) {
        if (photoNumbers.length === 1) {
            formattedPhotoNumbers = photoNumbers[0];
        } else {
            // Group consecutive numbers
            const ranges = [];
            let start = parseInt(photoNumbers[0]);
            let end = start;
            
            for (let i = 1; i < photoNumbers.length; i++) {
                const current = parseInt(photoNumbers[i]);
                if (current === end + 1) {
                    end = current;
                } else {
                    if (start === end) {
                        ranges.push(start.toString());
                    } else {
                        ranges.push(`${start}-${end}`);
                    }
                    start = current;
                    end = current;
                }
            }
            
            // Add the last range
            if (start === end) {
                ranges.push(start.toString());
            } else {
                ranges.push(`${start}-${end}`);
            }
            
            formattedPhotoNumbers = ranges.join(', ');
        }
    }
    
    // Add to defect entries with enhanced data
    const defectEntry = {
        id: Date.now() + Math.random(), // Unique ID
        range: formattedNumbers,
        description: defectType, // This is the defect type
        category: category,
        numbers: numbers,
        photoNumbers: formattedPhotoNumbers, // Add photo numbers
        imminentDanger: isImminent,
        // New fields for defect summary - match defect-form fields exactly
        defectNo: document.getElementById('defectNo').value.trim(), // Add missing defectNo
        floor: floor,
        areaName: areaName,
        roomNo: roomNo,
        descriptionConstruction: description, // This is the description/construction field
        existingCondition: existingCondition,
        humidity: humidity,
        moisture: moisture,
        chloride: chloride,
        carbonation: carbonation,
        remedialWorks: remedialWorks,
        preventiveWorks: preventiveWorks,
        remarks: remarks,
        // æ–°å¢ header æ¬„ä½
        locationId: headerInspectionNo,
        inspectionDate: inspectionDate,
        inspectionNo: inspectionNo,
        // Add defectType field for detail table
        defectType: defectType
    };
    window.defectEntries.push(defectEntry);
    window.submittedDefectEntries.push(defectEntry);
    // Note: updateDefectSummaryTable() will be called when data is saved in all defects detail-table-container
    
    // å°‡ç¼ºé™·æ•¸æ“šè¤‡è£½åˆ°ç¼ºé™·é¡åˆ¥å…§å®¹ï¼ˆä½¿ç”¨æ ¼å¼åŒ–çš„ç¯„åœå’Œæè¿°ï¼‰
    const defectNo = document.getElementById('defectNo').value.trim();
    const defectCategoryEntry = `${defectNo}) ${formattedNumbers}_${defectType}`;
    if (!categoryNumbers.j.includes(defectCategoryEntry)) {
        categoryNumbers.j.push(defectCategoryEntry);
    }
    
    // Mark photos as assigned
    selectedPhotos.forEach(index => {
        const file = allPhotos[index];
        assignedPhotos.j.add(file.name);
        
        const photoItem = document.querySelector(`.photo-item[data-index="${index}"]`);
        if (photoItem) {
            photoItem.classList.add('assigned');
            const img = photoItem.querySelector('img');
            if (img) {
                img.style.filter = 'grayscale(100%)';
                img.style.opacity = '0.3';
            }
        }
    });
    
    // Also assign the same photos to the selected category (A-I)
    if (category && category !== 'j') {
        const numbersToAssign = [];
        
        selectedPhotos.forEach(index => {
            const file = allPhotos[index];
            const fileName = file.name;
            const numberMatch = fileName.match(/\d+/);
            
            if (numberMatch) {
                const number = numberMatch[0];
                if (!categoryNumbers[category].includes(number)) {
                    categoryNumbers[category].push(number);
                    assignedPhotos[category].add(fileName);
                    numbersToAssign.push(number);
                }
            }
        });
        
        if (numbersToAssign.length > 0) {
            updateCategoryDisplay(category);
            showNotification(`Also assigned ${numbersToAssign.length} numbers to category ${category.toUpperCase()}`, 'info');
        }
    }
    
    updateCategoryDisplay('j');
    
    // Update Inspection Records Defects based on inspection number
    updateInspectionRecordsDefects(inspectionNo, defectEntry);
    
    showNotification(`Defect added to category J`, 'success');
    
    // Clear selection after assignment
    selectedPhotos = [];
    updatePhotoSelection();
    updateSelectedCount();
    
    // Close defect window
    defectWindow.style.display = 'none';
    
    // Check if PDF file has been uploaded AND loaded (drawing mode is available)
    const floorPlanCanvas = document.getElementById('floorPlanCanvas');
    const floorPlanViewer = document.getElementById('floorPlanViewer');
    const hasPDFData = localStorage.getItem('pne_floorplan_data');
    const hasPDFFilename = localStorage.getItem('pne_floorplan_filename');
    
    // More strict check: PDF must be loaded AND canvas must have content AND viewer must be visible
    const isCanvasLoaded = floorPlanCanvas && floorPlanCanvas.width > 0 && floorPlanCanvas.height > 0;
    const isViewerVisible = floorPlanViewer && floorPlanViewer.style.display !== 'none';
    const hasPDFLoaded = isCanvasLoaded && isViewerVisible;
    
    const isDrawingModeAvailable = hasPDFLoaded && (hasPDFData || hasPDFFilename);
    
    window.logger.log('Drawing mode check:', {
        floorPlanCanvas: !!floorPlanCanvas,
        canvasWidth: floorPlanCanvas ? floorPlanCanvas.width : 0,
        canvasHeight: floorPlanCanvas ? floorPlanCanvas.height : 0,
        floorPlanViewer: !!floorPlanViewer,
        viewerDisplay: floorPlanViewer ? floorPlanViewer.style.display : 'N/A',
        hasPDFData: !!hasPDFData,
        hasPDFFilename: !!hasPDFFilename,
        isCanvasLoaded: isCanvasLoaded,
        isViewerVisible: isViewerVisible,
        hasPDFLoaded: hasPDFLoaded,
        isDrawingModeAvailable: isDrawingModeAvailable
    });
    
    if (isDrawingModeAvailable) {
        // Drawing mode: Set pending defect data and open floor plan content for defect mark placement
        window.logger.log('Drawing mode available - setting pending defect data and opening floor plan content');
        
        // Pending defect data is set for double-click creation in drawing mode
        window.logger.log('Pending defect data set for double-click creation:', {
            pendingDefectData: window.pendingDefectData,
            readyForDoubleClick: !!window.pendingDefectData
        });
        
        // Trigger the workflow that will show the reminder popup
        triggerAutoCreateDefectMark();
    } else {
        // Non-drawing mode: Clear pending defect data and only transfer data to detail-table
        window.logger.log('Non-drawing mode - clearing pending defect data and transferring to detail-table only');
        window.pendingDefectData = null; // Clear pending data since we're not in drawing mode
        
        // Update defect summary table to reflect the new data
        if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
        window.logger.log('Non-drawing mode: Updated defect summary table');
        
        showNotification('Defect record created successfully! Data saved to detail table.', 'success');
    }
    
    // Handle edit mode
    if (isEditMode) {
        // Find and update the existing defect entry
        const defectEntryIndex = window.defectEntries.findIndex(entry => 
            String(entry.defectNo) === String(window.editingDefectNo)
        );
        
        if (defectEntryIndex >= 0) {
            // Update the existing entry with new data
            window.defectEntries[defectEntryIndex] = defectEntry;
            
            // Also update in submittedDefectEntries
            const submittedDefectEntryIndex = window.submittedDefectEntries.findIndex(entry => 
                String(entry.defectNo) === String(window.editingDefectNo)
            );
            
            if (submittedDefectEntryIndex >= 0) {
                submittedDefectEntries[submittedDefectEntryIndex] = defectEntry;
            }
            
            // Update corresponding defect mark if it exists
            if (window.defectMarks && window.defectMarks.length > 0) {
                const defectMarkIndex = window.defectMarks.findIndex(mark => 
                    String(mark.defectNo) === String(window.editingDefectNo)
                );
                
                if (defectMarkIndex >= 0) {
                    // Update defect mark data
                    window.defectMarks[defectMarkIndex] = {
                        ...window.defectMarks[defectMarkIndex],
                        defectNo: defectEntry.defectNo,
                        recordDate: defectEntry.inspectionDate,
                        photoNo: defectEntry.photoNumbers,
                        categories: defectEntry.category,
                        defectType: defectEntry.defectType
                    };
                    
                    // Save and redraw defect marks
                    if (typeof saveDefectMarksToStorage === 'function') {
                        saveDefectMarksToStorage();
                    }
                    if (typeof window.redrawDefectMarks === 'function') {
                        window.redrawDefectMarks();
                    }
                }
            }
            
            // Update corresponding label if it exists
            if (window.labels && window.labels.length > 0) {
                const labelIndex = window.labels.findIndex(label => 
                    String(label.defectNo) === String(window.editingDefectNo)
                );
                
                if (labelIndex >= 0) {
                    // Update label data
                    window.labels[labelIndex] = {
                        ...window.labels[labelIndex],
                        defectNo: defectEntry.defectNo,
                        inspectionNo: defectEntry.inspectionNo,
                        inspectionDate: defectEntry.inspectionDate,
                        photoNumbers: defectEntry.photoNumbers,
                        category: defectEntry.category,
                        defectType: defectEntry.defectType
                    };
                    
                    // Save and redraw labels
                    if (typeof window.saveLabelsToStorage === 'function') {
                        window.saveLabelsToStorage();
                    }
                    if (typeof window.redrawLabels === 'function') {
                        window.redrawLabels();
                    }
                    
                    // åŒæ­¥åˆ° defects detail-table-containerï¼ˆæª¢æŸ¥ç¼ºé™·è¨˜éŒ„çš„è®ŠåŒ–ï¼‰
                    syncLabelsToDefectsDetailTable();
                }
            }
            
            // Update defect summary table
            if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
            
            // æ›´æ–°ç…§ç‰‡ç‹€æ…‹
            if (typeof updatePhotoStatusFromLabels === 'function') {
                updatePhotoStatusFromLabels();
            }
            
            // Clear edit mode
            window.editingDefectId = null;
            window.editingDefectNo = null;
            
            showNotification(`ç¼ºé™·è¨˜éŒ„ ${window.editingDefectNo} å·²æ›´æ–°`, 'success');
        } else {
            showNotification('æ‰¾ä¸åˆ°è¦ç·¨è¼¯çš„ç¼ºé™·è¨˜éŒ„', 'error');
        }
    } else {
        // Normal creation mode - update defect summary table
        if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
        showNotification('Defect record created successfully! Data saved to detail table.', 'success');
    }
    
    // Save data to localStorage to persist defect entries
    saveDataToStorage();
    window.logger.log('Saved defect entries to localStorage after assignment');
    
    // é‡ç½® defect no. å­—æ®µ
    const defectNoInput = document.getElementById('defectNo');
    if (defectNoInput) {
        defectNoInput.value = '';
    }
    
    // Clear edit mode flags
    window.editingDefectId = null;
    window.editingDefectNo = null;
});
}




// æ¢å¾©ç…§ç‰‡åˆ†é…ç‹€æ…‹
function restorePhotoAssignmentStatus() {
    window.logger.log('Restoring photo assignment status...');
    
    // éæ­·æ‰€æœ‰ç…§ç‰‡é …ç›®
    const photoItems = document.querySelectorAll('.photo-item');
    console.log('ğŸ“‹ restorePhotoAssignmentStatus:', {
        photoItemsFound: photoItems.length,
        assignedPhotosCategories: Object.keys(assignedPhotos).length,
        totalAssignedPhotos: Object.values(assignedPhotos).reduce((sum, set) => sum + set.size, 0),
        assignedPhotosByCategory: Object.fromEntries(
            Object.entries(assignedPhotos).map(([cat, set]) => [cat, set.size])
        )
    });
    
    let restoredCount = 0;
    const assignedPhotosList = [];
    const notFoundPhotos = [];
    
    // æ”¶é›†æ‰€æœ‰æ‡‰è©²è¢«åˆ†é…çš„ç…§ç‰‡åç¨±
    const allAssignedFilenames = new Set();
    for (const categoryId in assignedPhotos) {
        assignedPhotos[categoryId].forEach(filename => {
            allAssignedFilenames.add(filename);
        });
    }
    console.log('ğŸ“‹ Photos that should be assigned:', Array.from(allAssignedFilenames));
    
    photoItems.forEach((photoItem, index) => {
        const filename = photoItem.dataset.filename;
        if (!filename) return;
        
        // ğŸ”§ æ”¶é›†ç…§ç‰‡è¢«åˆ†é…åˆ°çš„æ‰€æœ‰é¡åˆ¥
        const assignedCategories = [];
        for (const categoryId in assignedPhotos) {
            if (assignedPhotos[categoryId].has(filename)) {
                assignedCategories.push(categoryId);
            }
        }
        
        // å¦‚æœç…§ç‰‡è¢«åˆ†é…åˆ°è‡³å°‘ä¸€å€‹é¡åˆ¥
        if (assignedCategories.length > 0) {
            // ğŸ”§ æª¢æŸ¥ç…§ç‰‡æ˜¯å¦å·²ç¶“ submitted (å·²æäº¤)
            // submitted ç…§ç‰‡çš„ç‹€æ…‹ç”± updatePhotoStatusFromInspectionRecords è™•ç†,ä¸æ‡‰è©²è¢«è¦†è“‹
            const isSubmitted = photoItem.classList.contains('submitted');
            
            photoItem.classList.add('assigned');
            
            // è¨­ç½®ç…§ç‰‡çš„è¦–è¦ºç‹€æ…‹
            const img = photoItem.querySelector('img');
            if (img) {
                img.style.filter = 'grayscale(100%)';
                img.style.opacity = '0.3';
            }
            
            // ğŸ”§ åªæœ‰æœªæäº¤çš„ç…§ç‰‡æ‰é¡¯ç¤ºåˆ†é…çš„é¡åˆ¥
            // å·²æäº¤çš„ç…§ç‰‡æ‡‰è©²é¡¯ç¤º inspection no.,å„ªå…ˆç´š: submitted > assigned
            if (!isSubmitted) {
                const statusDiv = photoItem.querySelector('.photo-status');
                if (statusDiv) {
                    // å‰µå»ºé¡åˆ¥åç¨±æ˜ å°„(ç°¡çŸ­ç‰ˆæœ¬,ç”¨æ–¼ç‹€æ…‹é¡¯ç¤º)
                    const categoryNameMap = {
                        'a': 'A: Metalwork',
                        'b': 'B: Structural',
                        'c': 'C: External',
                        'd': 'D: Suspended',
                        'e': 'E: Internal',
                        'f': 'F: Gates/Doors',
                        'g': 'G: Windows',
                        'h': 'H: Drainage',
                        'i': 'I: Fire Safety',
                        'j': 'J: Defect'
                    };
                    
                    // çµ„åˆé¡åˆ¥åç¨±
                    const categoryNames = assignedCategories
                        .map(cat => categoryNameMap[cat] || cat.toUpperCase())
                        .join(' & ');
                    
                    statusDiv.textContent = categoryNames;
                    statusDiv.style.display = 'flex';
                    statusDiv.style.zIndex = '10';
                    statusDiv.title = `Assigned to: ${categoryNames}`; // Tooltip é¡¯ç¤ºå®Œæ•´ä¿¡æ¯
                    // ä¿æŒåŸä¾†çš„ CSS æ¨£å¼(ç°è‰²èƒŒæ™¯),ä¸è¦†è“‹èƒŒæ™¯è‰²
                }
            }
            
            restoredCount++;
            assignedPhotosList.push(`${filename} (${assignedCategories.join(', ')})`);
        } else {
            // å¦‚æœç…§ç‰‡æœªåˆ†é…ï¼Œç¢ºä¿ç§»é™¤åˆ†é…ç‹€æ…‹
            // ğŸ”§ ä½†ä¸è¦æ¸…é™¤ submitted ç…§ç‰‡çš„ç‹€æ…‹!
            const isSubmitted = photoItem.classList.contains('submitted');
            
            if (!isSubmitted) {
                // åªæ¸…é™¤æœªæäº¤ç…§ç‰‡çš„ç‹€æ…‹
                photoItem.classList.remove('assigned');
                const img = photoItem.querySelector('img');
                if (img) {
                    img.style.filter = '';
                    img.style.opacity = '';
                }
                
                // æ¸…é™¤ status div
                const statusDiv = photoItem.querySelector('.photo-status');
                if (statusDiv) {
                    statusDiv.textContent = '';
                    statusDiv.style.display = 'none';
                }
            }
            // submitted ç…§ç‰‡ä¿æŒåŸç‹€,ä¸åšä»»ä½•ä¿®æ”¹
        }
    });
    
    // æ‰¾å‡ºå“ªäº›ç…§ç‰‡æ‡‰è©²è¢«åˆ†é…ä½†åœ¨ DOM ä¸­æ²’æ‰¾åˆ°
    allAssignedFilenames.forEach(filename => {
        const found = document.querySelector(`.photo-item[data-filename="${filename}"]`);
        if (!found) {
            notFoundPhotos.push(filename);
        }
    });
    
    // è¨ˆç®—å”¯ä¸€ç…§ç‰‡æ•¸é‡(ä¸€å¼µç…§ç‰‡å¯èƒ½è¢«åˆ†é…åˆ°å¤šå€‹é¡åˆ¥)
    const uniquePhotos = new Set();
    for (const categoryId in assignedPhotos) {
        assignedPhotos[categoryId].forEach(filename => {
            uniquePhotos.add(filename);
        });
    }
    
    console.log('âœ… Photos successfully marked as assigned:', assignedPhotosList);
    if (notFoundPhotos.length > 0) {
        console.log('âš ï¸ Photos that should be assigned but not found in DOM:', notFoundPhotos);
    }
    console.log(`âœ… Photo assignment status restored: ${restoredCount} unique photos marked as assigned (${Object.values(assignedPhotos).reduce((sum, set) => sum + set.size, 0)} total assignments)`);
    window.logger.log('Photo assignment status restored');
}

// Load data from storage
async function loadDataFromStorage() {
    console.log('ğŸ” loadDataFromStorage: Starting to load data from IndexedDB');
    const savedData = await window.storageAdapter.getItemDirect('photoNumberExtractorData');
    console.log('ğŸ” loadDataFromStorage: Retrieved savedData from IndexedDB:', !!savedData);
    if (savedData) {
        console.log('ğŸ” loadDataFromStorage: savedData keys:', Object.keys(savedData));
        console.log('ğŸ” loadDataFromStorage: savedData.submittedFilenames:', savedData.submittedFilenames);
    }
    if (savedData) {
        try {
            const parsedData = savedData;
            
            // æª¢æŸ¥æ˜¯å¦ç‚ºæ–°çš„ PNE å…¼å®¹æ ¼å¼
            const isPNEFormat = parsedData.version && parsedData.version.startsWith('7.1');
            window.logger.log('Page reload: Data format detected:', isPNEFormat ? 'PNE-compatible (v7.1+)' : 'Legacy format');
            
            // è¼‰å…¥åŸºæœ¬æ•¸æ“š - å…¼å®¹æ–°èˆŠæ ¼å¼
            submittedData = parsedData.inspectionRecords || parsedData.submittedData || [];
            window.inspectionRecords = submittedData; // è¨­ç½®å…¨å±€è®Šé‡ä¾›å…¶ä»–åŠŸèƒ½ä½¿ç”¨
            console.log('ğŸ” Loaded inspection records:', window.inspectionRecords.length);
            rowIdCounter = parsedData.rowIdCounter || 0;
            photoFolders = parsedData.photoFolders || [];
            
            // Load defect entries for persistence - å…¼å®¹æ–°èˆŠæ ¼å¼
            window.defectEntries = parsedData.photoAssignments?.defectEntries || parsedData.defectEntries || [];
            window.submittedDefectEntries = parsedData.submittedDefectEntries || [];
            console.log('ğŸ” Loading defect data:', {
                defectEntriesLength: window.defectEntries.length,
                submittedDefectEntriesLength: window.submittedDefectEntries.length,
                hasPhotoAssignments: !!parsedData.photoAssignments,
                hasDefectEntries: !!parsedData.defectEntries,
                hasSubmittedDefectEntries: !!parsedData.submittedDefectEntries
            });
            window.logger.log('Page reload: Loaded defect entries from storage:', window.defectEntries.length, 'entries');
            window.logger.log('Page reload: Loaded submittedDefectEntries from storage:', window.submittedDefectEntries.length, 'entries');
            
            // è¼‰å…¥ header æ¬„ä½ - æ–°æ ¼å¼
            if (parsedData.headerFields) {
                const headerFields = parsedData.headerFields;
                const locationId = document.getElementById('locationId');
                const inspectionDate = document.getElementById('inspectionDate');
                const floorHeader = document.getElementById('floorHeader');
                const areaNameHeader = document.getElementById('areaNameHeader');
                const roomNo = document.getElementById('roomNo');
                // æ³¨æ„ï¼šsortToggle å·²ç§»å‹•åˆ°å°å‡ºè¨­ç½®é é¢ï¼Œé€™è£¡ä¸å†è¨­ç½®
                
                if (locationId) locationId.value = headerFields.inspectionNo || '';
                if (inspectionDate) inspectionDate.value = headerFields.inspectionDate || '';
                if (floorHeader) floorHeader.value = headerFields.floor || '';
                if (areaNameHeader) areaNameHeader.value = headerFields.areaName || '';
                if (roomNo) roomNo.value = headerFields.roomNo || '';
                // sortEnabled è¨­ç½®å°‡åœ¨å°å‡ºè¨­ç½®é é¢ä¸­è™•ç†
                
                window.logger.log('Page reload: Loaded header fields from PNE format');
            }
            
            // è¼‰å…¥æª”æ¡ˆè·¯å¾‘è³‡è¨Š - æ–°æ ¼å¼
            if (parsedData.filePaths) {
                const filePaths = parsedData.filePaths;
                if (filePaths.photoFolderPath && folderNameDisplay) {
                    folderNameDisplay.textContent = filePaths.photoFolderPath;
                }
                window.logger.log('Page reload: Loaded file paths from PNE format');
            }
            
            // è¼‰å…¥ç…§ç‰‡çµ±è¨ˆ - æ–°æ ¼å¼
            if (parsedData.totalPhotos !== undefined) {
                window.logger.log('Page reload: Total photos from PNE format:', parsedData.totalPhotos);
            }
            if (parsedData.totalAssignments !== undefined) {
                window.logger.log('Page reload: Total assignments from PNE format:', parsedData.totalAssignments);
            }
            
            // è¼‰å…¥ä»»å‹™æ•¸æ“š - æ–°æ ¼å¼
            if (parsedData.currentTask) {
                currentTask = parsedData.currentTask;
                window.hasTaskData = true;
                console.log('ğŸ“¥ Loaded current task from PNE data:', currentTask.name);
                // æ›´æ–°ä»»å‹™é¡¯ç¤º
                updateTaskDisplay();
                window.logger.log('Page reload: Loaded current task from PNE format');
            }
            
            // Fix: If defectEntries is empty but submittedDefectEntries has data, restore defectEntries
            if (window.defectEntries.length === 0 && window.submittedDefectEntries.length > 0) {
                window.logger.log('Page reload: defectEntries is empty but submittedDefectEntries has data, restoring defectEntries');
                window.defectEntries = [...window.submittedDefectEntries]; // Copy submittedDefectEntries to defectEntries
                window.logger.log('Page reload: Restored defectEntries from submittedDefectEntries:', window.defectEntries.length, 'entries');
            }
            
            // åŒæ™‚æ¸…é™¤ç¼ºé™·æ¨™è¨˜ï¼Œé˜²æ­¢é‡æ–°è¼‰å…¥æ™‚é‡æ–°å¡«å……ç¼ºé™·æ¢ç›®
            if (typeof window.defectMarks !== 'undefined') {
                window.defectMarks = [];
                window.logger.log('Page reload: Cleared defect marks to prevent defect entries re-population');
            }
            
            // æ¸…é™¤ submittedData ä¸­èˆ‡ç¼ºé™·æ¨™è¨˜ç›¸é—œçš„è³‡æ–™ï¼Œé˜²æ­¢ç¼ºé™·æ‘˜è¦è¡¨æ ¼é¡¯ç¤ºç¼ºé™·æ¨™è¨˜è³‡æ–™
            if (submittedData && submittedData.length > 0) {
                const originalLength = submittedData.length;
                submittedData = submittedData.filter(row => {
                    // ä¿ç•™ä¸åŒ…å«ç¼ºé™·è³‡æ–™çš„æª¢æŸ¥è¨˜éŒ„ï¼Œæˆ–åªä¿ç•™ä¾†è‡ªæª¢æŸ¥è¨˜éŒ„çš„ç¼ºé™·è³‡æ–™
                    return !row.j || row.j === 'N/A' || !row.fromDefectMark;
                });
                window.logger.log(`Page reload: Filtered submittedData from ${originalLength} to ${submittedData.length} entries`);
                console.log('ğŸ” Filtered submittedData:', submittedData);
            }
            
            // ç§»é™¤ï¼šä¸å†è¨­ç½® skipDefectMarksLoad æ¨™èªŒï¼Œå…è¨±ç¼ºé™·æ¨™è¨˜æ­£å¸¸è¼‰å…¥
            // window.skipDefectMarksLoad = true;
            // window.logger.log('Page reload: Set skipDefectMarksLoad flag to prevent defect marks reload');
            
            // è¼‰å…¥ç…§ç‰‡åˆ†é…è³‡æ–™ - å„ªå…ˆä½¿ç”¨ PNE æ ¼å¼çš„ photoAssignments
            if (parsedData.photoAssignments) {
                const pa = parsedData.photoAssignments;
                
                // è¼‰å…¥é¡åˆ¥ç·¨è™Ÿ
                if (pa.categoryNumbers) {
                    Object.keys(pa.categoryNumbers).forEach(categoryId => {
                        // ğŸ”§ å³ä½¿ categoryId ä¸å­˜åœ¨,ä¹Ÿè¦å‰µå»ºä¸¦è¼‰å…¥
                        if (!categoryNumbers[categoryId]) {
                            console.log(`âš ï¸ Category ${categoryId} not found in categoryNumbers, creating it`);
                            categoryNumbers[categoryId] = [];
                        }
                        categoryNumbers[categoryId] = [...(pa.categoryNumbers[categoryId] || [])];
                    });
                    window.logger.log('Page reload: Loaded category numbers from photoAssignments');
                }
                
                // è¼‰å…¥å·²åˆ†é…ç…§ç‰‡ - å…¼å®¹æ–°èˆŠæ ¼å¼
                if (pa.assignedPhotos) {
                    if (Array.isArray(pa.assignedPhotos)) {
                        // æ–°æ ¼å¼ï¼šassignedPhotos æ˜¯é™£åˆ—ï¼Œä½†éœ€è¦è½‰æ›ç‚ºç‰©ä»¶æ ¼å¼
                        window.logger.log('Page reload: Converting assigned photos array to object format');
                        // æ¸…ç©ºç¾æœ‰çš„ assignedPhotos
                        Object.keys(assignedPhotos).forEach(key => {
                            assignedPhotos[key].clear();
                        });
                        
                        // å¾æ•¸çµ„æ ¼å¼è½‰æ›ç‚ºç‰©ä»¶æ ¼å¼ï¼ˆé€™è£¡éœ€è¦æ ¹æ“šå¯¦éš›æ•¸æ“šçµæ§‹èª¿æ•´ï¼‰
                        // æš«æ™‚è·³éæ•¸çµ„æ ¼å¼çš„è™•ç†ï¼Œå› ç‚ºæˆ‘å€‘éœ€è¦çŸ¥é“æ•¸çµ„çš„çµæ§‹
                        window.logger.warn('Array format assignedPhotos not yet supported, skipping');
                    } else if (typeof pa.assignedPhotos === 'object') {
                        // èˆŠæ ¼å¼ï¼šassignedPhotos æ˜¯ç‰©ä»¶
                        let totalAssignedPhotos = 0;
                        const skippedCategories = [];
                        Object.keys(pa.assignedPhotos).forEach(categoryId => {
                            // ğŸ”§ å³ä½¿ categoryId ä¸å­˜åœ¨,ä¹Ÿè¦å‰µå»ºä¸¦è¼‰å…¥
                            if (!assignedPhotos[categoryId]) {
                                console.log(`âš ï¸ Category ${categoryId} not found in assignedPhotos, creating it`);
                                assignedPhotos[categoryId] = new Set();
                                skippedCategories.push(categoryId);
                            }
                            assignedPhotos[categoryId] = new Set(pa.assignedPhotos[categoryId] || []);
                            totalAssignedPhotos += assignedPhotos[categoryId].size;
                        });
                        console.log('ğŸ“‹ Loaded assigned photos from photoAssignments:', {
                            totalCategories: Object.keys(pa.assignedPhotos).length,
                            totalAssignedPhotos: totalAssignedPhotos,
                            categoriesWithPhotos: Object.keys(pa.assignedPhotos).filter(k => pa.assignedPhotos[k] && pa.assignedPhotos[k].length > 0),
                            skippedCategories: skippedCategories.length > 0 ? skippedCategories : 'none'
                        });
                        window.logger.log('Page reload: Loaded assigned photos object from photoAssignments (legacy format)');
                    }
                }
                
                // è¼‰å…¥ç¼ºé™·æ¢ç›®
                if (Array.isArray(pa.defectEntries) && pa.defectEntries.length > 0) {
                    window.defectEntries = [...pa.defectEntries];
                    window.logger.log('Page reload: Loaded defect entries from photoAssignments');
                }
            } else {
                // å‘å¾Œç›¸å®¹ï¼šè®€å–é ‚å±¤æ¬„ä½
            if (parsedData.assignedPhotos) {
                Object.keys(parsedData.assignedPhotos).forEach(categoryId => {
                    // ğŸ”§ å³ä½¿ categoryId ä¸å­˜åœ¨,ä¹Ÿè¦å‰µå»ºä¸¦è¼‰å…¥
                    if (!assignedPhotos[categoryId]) {
                        console.log(`âš ï¸ Category ${categoryId} not found in assignedPhotos (legacy), creating it`);
                        assignedPhotos[categoryId] = new Set();
                    }
                    assignedPhotos[categoryId] = new Set(parsedData.assignedPhotos[categoryId]);
                });
                    window.logger.log('Page reload: Loaded assigned photos from storage (legacy)');
            }
            if (parsedData.categoryNumbers) {
                Object.keys(parsedData.categoryNumbers).forEach(categoryId => {
                    // ğŸ”§ å³ä½¿ categoryId ä¸å­˜åœ¨,ä¹Ÿè¦å‰µå»ºä¸¦è¼‰å…¥
                    if (!categoryNumbers[categoryId]) {
                        console.log(`âš ï¸ Category ${categoryId} not found in categoryNumbers (legacy), creating it`);
                        categoryNumbers[categoryId] = [];
                    }
                    categoryNumbers[categoryId] = [...parsedData.categoryNumbers[categoryId]];
                });
                    window.logger.log('Page reload: Loaded category numbers from storage (legacy)');
                }
            }
            
            // è‹¥å·²ç”¨ FSA handle è¼‰å…¥ç…§ç‰‡ï¼Œéœ€è¦åˆä½µ IndexedDB ä¸­çš„é¡å¤–ç…§ç‰‡ï¼ˆä¾‹å¦‚é€šé Add photos æ·»åŠ çš„ï¼‰
            const alreadyLoadedPhotos = Array.isArray(allPhotos) && allPhotos.length > 0 && window.loadedFromHandles === true;
            console.log('ğŸ” alreadyLoadedPhotos check:', {
                isArray: Array.isArray(allPhotos),
                length: allPhotos ? allPhotos.length : 0,
                loadedFromHandles: window.loadedFromHandles,
                alreadyLoadedPhotos: alreadyLoadedPhotos
            });
            
            // è¼‰å…¥å·²æäº¤çš„æª”æ¡ˆåç¨±
            if (parsedData.submittedFilenames) {
                submittedFilenames = new Set(parsedData.submittedFilenames);
                console.log('ğŸ” Page reload: Loaded submitted filenames:', submittedFilenames.size, 'files:', Array.from(submittedFilenames));
            } else {
                console.log('ğŸ” Page reload: No submittedFilenames found in parsedData');
                console.log('ğŸ” parsedData keys:', Object.keys(parsedData));
            }
            
            // è¼‰å…¥ç…§ç‰‡å…ƒè³‡æ–™
            console.log('ğŸ” Checking photoMetadata:', {
                exists: !!parsedData.photoMetadata,
                isArray: Array.isArray(parsedData.photoMetadata),
                length: parsedData.photoMetadata ? parsedData.photoMetadata.length : 0,
                sample: parsedData.photoMetadata && parsedData.photoMetadata.length > 0 ? {
                    name: parsedData.photoMetadata[0].name,
                    hasDataURL: !!parsedData.photoMetadata[0].dataURL,
                    dataURLLength: parsedData.photoMetadata[0].dataURL ? parsedData.photoMetadata[0].dataURL.length : 0
                } : null
            });
            
            if (parsedData.photoMetadata) {
                window.logger.log('Loading photo metadata from IndexedDB:', parsedData.photoMetadata.length);
                
                // å¾å…ƒè³‡æ–™é‡å»ºç…§ç‰‡ç‰©ä»¶ï¼ˆåŒ…å« dataURLï¼‰
                const photosFromStorage = parsedData.photoMetadata.map(metadata => {
                    // æª¢æŸ¥ dataURL çš„é¡å‹å’Œå…§å®¹
                    let dataURL = metadata.dataURL || '';
                    if (typeof dataURL === 'object') {
                        window.logger.warn(`Invalid dataURL type for ${metadata.name}:`, typeof dataURL);
                        dataURL = ''; // é‡ç½®ç‚ºç©ºå­—ç¬¦ä¸²
                    }
                    
                    return {
                    name: metadata.name,
                    size: metadata.size || 0,
                    type: metadata.type || 'image/jpeg',
                        lastModified: metadata.lastModified || Date.now(),
                        webkitRelativePath: metadata.webkitRelativePath || '',
                        dataURL: dataURL // æ¢å¾© dataURL ä»¥é¡¯ç¤ºç…§ç‰‡
                    };
                });
                
                if (alreadyLoadedPhotos) {
                    // å¦‚æœå·²å¾ FSA handle è¼‰å…¥ç…§ç‰‡ï¼Œéœ€è¦åˆä½µ IndexedDB ä¸­çš„ç…§ç‰‡
                    console.log('ğŸ”„ Merging photos from FSA handle with IndexedDB...');
                    console.log('ğŸ“Š Current allPhotos count:', allPhotos.length);
                    console.log('ğŸ“Š photosFromStorage count:', photosFromStorage.length);
                    const existingPhotoNames = new Set(allPhotos.map(p => p.name));
                    console.log('ğŸ“Š Existing photo names:', Array.from(existingPhotoNames));
                    
                    // æ‰¾å‡º IndexedDB ä¸­æœ‰ä½† FSA handle æ²’æœ‰çš„ç…§ç‰‡ï¼ˆé€šé Add photos æ·»åŠ çš„ï¼‰
                    const additionalPhotos = photosFromStorage.filter(p => !existingPhotoNames.has(p.name) && p.dataURL);
                    console.log('ğŸ“Š Additional photos found:', additionalPhotos.length);
                    if (additionalPhotos.length > 0) {
                        console.log('ğŸ“‹ Additional photo names:', additionalPhotos.map(p => p.name));
                    }
                    
                    if (additionalPhotos.length > 0) {
                        console.log(`âœ… Found ${additionalPhotos.length} additional photos in IndexedDB (added via Add photos)`);
                        
                        // æª¢æŸ¥é€™äº›ç…§ç‰‡çš„ dataURL
                        additionalPhotos.forEach((photo, idx) => {
                            console.log(`ğŸ” Additional photo ${idx + 1}/${additionalPhotos.length}:`, {
                                name: photo.name,
                                hasDataURL: !!photo.dataURL,
                                dataURLType: typeof photo.dataURL,
                                dataURLLength: photo.dataURL ? photo.dataURL.length : 0,
                                dataURLPrefix: photo.dataURL ? photo.dataURL.substring(0, 30) : 'N/A'
                            });
                        });
                        
                        allPhotos.push(...additionalPhotos);
                        console.log('ğŸ“Š Total photos after merge:', allPhotos.length);
                        
                        // é©—è­‰åˆä½µå¾Œçš„ç…§ç‰‡æ˜¯å¦é‚„æœ‰ dataURL
                        console.log('ğŸ” Verifying dataURL after merge...');
                        const photosAfterMerge = allPhotos.slice(-12); // æª¢æŸ¥æœ€å¾Œ 12 å¼µï¼ˆå‰›æ·»åŠ çš„ï¼‰
                        photosAfterMerge.forEach((photo, idx) => {
                            console.log(`ğŸ” allPhotos[${allPhotos.length - 12 + idx}]:`, {
                                name: photo.name,
                                hasDataURL: !!photo.dataURL,
                                dataURLType: typeof photo.dataURL,
                                dataURLLength: photo.dataURL ? photo.dataURL.length : 0
                            });
                        });
                        
                        // é‡æ–°æ¸²æŸ“æ‰€æœ‰ç…§ç‰‡
                        setTimeout(async () => {
                            try {
                                // æª¢æŸ¥æœ€å¾Œä¸€å¼µç…§ç‰‡ï¼ˆé¿å…ç´¢å¼•è¶Šç•Œï¼‰
                                const lastPhotoIndex = allPhotos.length - 1;
                                console.log('ğŸ” Before renderPhotos - checking last photo:',{
                                    index: lastPhotoIndex,
                                    name: allPhotos[lastPhotoIndex]?.name,
                                    hasDataURL: !!allPhotos[lastPhotoIndex]?.dataURL,
                                    dataURLLength: allPhotos[lastPhotoIndex]?.dataURL ? allPhotos[lastPhotoIndex].dataURL.length : 0
                                });
                                const lazyObserver = initLazyLoading();
                                await renderPhotos(allPhotos, lazyObserver);
                                console.log('âœ… Photos re-rendered with additional photos from IndexedDB');
                                
                                // ğŸ”§ ç…§ç‰‡æ¸²æŸ“å®Œæˆå¾Œ,æ¢å¾©ç…§ç‰‡åˆ†é…ç‹€æ…‹
                                setTimeout(() => {
                                    console.log('ğŸ”„ Restoring photo assignment status after merge and render...');
                                    
                                    // å…ˆæ›´æ–°ç…§ç‰‡æäº¤ç‹€æ…‹ (submitted)
                                    if (typeof updatePhotoStatusFromInspectionRecords === 'function') {
                                        updatePhotoStatusFromInspectionRecords();
                                        window.logger.log('Photo submission status updated from inspection records');
                                    }
                                    
                                    // ç„¶å¾Œæ¢å¾©ç…§ç‰‡åˆ†é…ç‹€æ…‹ (assigned) - å¿…é ˆåœ¨ updatePhotoStatusFromInspectionRecords ä¹‹å¾Œ
                                    if (typeof restorePhotoAssignmentStatus === 'function') {
                                        restorePhotoAssignmentStatus();
                                        window.logger.log('Photo assignment status restored after merge');
                                    }
                                    
                                    // ğŸ”§ ä¸èª¿ç”¨ updatePhotoStatusFromLabels,å› ç‚ºå®ƒæœƒè¦†è“‹ restorePhotoAssignmentStatus çš„è¨­ç½®
                                    // updatePhotoStatusFromLabels æœƒæ¸…é™¤æ‰€æœ‰ assigned class ä¸¦é‡æ–°è¨­ç½®
                                    // æˆ‘å€‘çš„ restorePhotoAssignmentStatus å·²ç¶“æ­£ç¢ºè™•ç†äº†å¤šé¡åˆ¥åˆ†é…çš„é¡¯ç¤º
                                }, 300);
                            } catch (error) {
                                window.logger.error('Error re-rendering photos:', error);
                            }
                        }, 100);
                    } else {
                        console.log('âš ï¸ No additional photos to merge');
                        
                        // å³ä½¿æ²’æœ‰é¡å¤–ç…§ç‰‡éœ€è¦åˆä½µï¼Œä¹Ÿéœ€è¦ç¢ºä¿ç…§ç‰‡å·²ç¶“æ¸²æŸ“
                        // æª¢æŸ¥ç…§ç‰‡æ˜¯å¦å·²ç¶“åœ¨ DOM ä¸­é¡¯ç¤º
                        const photoItems = document.querySelectorAll('.photo-item');
                        if (photoItems.length === 0 && allPhotos.length > 0) {
                            console.log('ğŸ” No photos rendered yet, triggering renderPhotos...');
                            setTimeout(async () => {
                                try {
                                    const lazyObserver = initLazyLoading();
                                    await renderPhotos(allPhotos, lazyObserver);
                                    console.log('âœ… Photos rendered after merge check');
                                    
                                    // æ¢å¾©ç…§ç‰‡åˆ†é…ç‹€æ…‹
                                    setTimeout(() => {
                                        if (typeof updatePhotoStatusFromInspectionRecords === 'function') {
                                            updatePhotoStatusFromInspectionRecords();
                                        }
                                        if (typeof restorePhotoAssignmentStatus === 'function') {
                                            restorePhotoAssignmentStatus();
                                        }
                                    }, 300);
                                } catch (error) {
                                    console.error('âŒ Error rendering photos after merge check:', error);
                                }
                            }, 100);
                        } else {
                            console.log('ğŸ” Photos already rendered, count:', photoItems.length);
                        }
                    }
                } else {
                    // æ²’æœ‰å¾ FSA handle è¼‰å…¥ï¼Œç›´æ¥ä½¿ç”¨ IndexedDB çš„ç…§ç‰‡
                    allPhotos = photosFromStorage;
                    const photosWithDataURL = allPhotos.filter(p => p.dataURL && p.dataURL.trim() !== '');
                    console.log('ğŸ” Photos loaded from IndexedDB:', {
                        total: allPhotos.length,
                        withDataURL: photosWithDataURL.length,
                        withoutDataURL: allPhotos.length - photosWithDataURL.length,
                        samplePhoto: allPhotos.length > 0 ? {
                            name: allPhotos[0].name,
                            hasDataURL: !!allPhotos[0].dataURL,
                            dataURLPrefix: allPhotos[0].dataURL ? allPhotos[0].dataURL.substring(0, 50) + '...' : 'N/A'
                        } : null
                    });
                    window.logger.log('Loaded photos with dataURL:', photosWithDataURL.length, 'of', allPhotos.length);
                    
                    // æ¸²æŸ“è¼‰å…¥çš„ç…§ç‰‡ - ä¿®å¾©ï¼šæ”¾å¯¬æ¢ä»¶ï¼Œç¸½æ˜¯å˜—è©¦æ¸²æŸ“æœ‰ç…§ç‰‡çš„æƒ…æ³
                    if (allPhotos.length > 0) {
                        window.logger.log('Rendering loaded photos from storage...');
                        console.log('ğŸ” About to render photos, allPhotos:', allPhotos.length);
                        console.log('ğŸ” Photos with dataURL:', allPhotos.filter(p => p.dataURL).length);
                        setTimeout(async () => {
                            try {
                                const lazyObserver = initLazyLoading();
                                await renderPhotos(allPhotos, lazyObserver);
                                window.logger.log('Photos rendered successfully from storage');
                                console.log('âœ… Photos rendered successfully');
                                
                                // ğŸ”§ ç…§ç‰‡æ¸²æŸ“å®Œæˆå¾Œ,æ¢å¾©ç…§ç‰‡åˆ†é…ç‹€æ…‹
                                setTimeout(() => {
                                    console.log('ğŸ”„ Restoring photo assignment status after render...');
                                    
                                    // å…ˆæ›´æ–°ç…§ç‰‡æäº¤ç‹€æ…‹ (submitted)
                                    if (typeof updatePhotoStatusFromInspectionRecords === 'function') {
                                        updatePhotoStatusFromInspectionRecords();
                                        window.logger.log('Photo submission status updated from inspection records');
                                    }
                                    
                                    // ç„¶å¾Œæ¢å¾©ç…§ç‰‡åˆ†é…ç‹€æ…‹ (assigned) - å¿…é ˆåœ¨ updatePhotoStatusFromInspectionRecords ä¹‹å¾Œ
                                    if (typeof restorePhotoAssignmentStatus === 'function') {
                                        restorePhotoAssignmentStatus();
                                        window.logger.log('Photo assignment status restored after render');
                                    }
                                    
                                    // ğŸ”§ ä¸èª¿ç”¨ updatePhotoStatusFromLabels,å› ç‚ºå®ƒæœƒè¦†è“‹ restorePhotoAssignmentStatus çš„è¨­ç½®
                                    // updatePhotoStatusFromLabels æœƒæ¸…é™¤æ‰€æœ‰ assigned class ä¸¦é‡æ–°è¨­ç½®
                                    // æˆ‘å€‘çš„ restorePhotoAssignmentStatus å·²ç¶“æ­£ç¢ºè™•ç†äº†å¤šé¡åˆ¥åˆ†é…çš„é¡¯ç¤º
                                }, 300);
                            } catch (error) {
                                window.logger.error('Error rendering photos from storage:', error);
                                console.error('âŒ Error rendering photos:', error);
                            }
                        }, 100);
                    } else {
                        console.log('âš ï¸ No photos to render - allPhotos is empty');
                    }
                }
            } else if (!alreadyLoadedPhotos && parsedData.allPhotoFilenames) {
                // å‘å¾Œç›¸å®¹ï¼šè¼‰å…¥èˆŠç‰ˆæœ¬çš„ç…§ç‰‡æª”æ¡ˆåç¨±
                window.logger.log('Loading allPhotoFilenames (legacy):', parsedData.allPhotoFilenames);
                allPhotos = parsedData.allPhotoFilenames.map(filename => ({
                    name: filename,
                    size: 0,
                    type: 'image/jpeg'
                }));
            } else {
                console.log('âš ï¸ No photoMetadata or allPhotoFilenames found in savedData');
            }
            
            // è¼‰å…¥æ¨“å±¤å¹³é¢åœ–æ•¸æ“š
            if (parsedData.floorPlanLabels) {
                // ç¢ºä¿ window.labels å­˜åœ¨
                if (typeof window.labels === 'undefined') {
                    window.labels = [];
                }
                
                // åˆä½µæ¨™ç±¤æ•¸æ“šï¼Œé¿å…è¦†è“‹æ–°å‰µå»ºçš„æ¨™ç±¤
                const existingLabels = window.labels || [];
                const storedLabels = parsedData.floorPlanLabels || [];
                
                // å¦‚æœç¾æœ‰æ¨™ç±¤ç‚ºç©ºï¼Œç›´æ¥ä½¿ç”¨å­˜å„²çš„æ¨™ç±¤
                if (existingLabels.length === 0) {
                    window.labels = storedLabels;
                    window.logger.log('Loaded floor plan labels from storage (no existing labels):', window.labels.length);
                } else {
                    // åˆä½µæ¨™ç±¤ï¼Œé¿å…é‡è¤‡
                    const mergedLabels = [...existingLabels];
                    storedLabels.forEach(storedLabel => {
                        const exists = mergedLabels.some(existing => existing.id === storedLabel.id);
                        if (!exists) {
                            mergedLabels.push(storedLabel);
                        }
                    });
                    window.labels = mergedLabels;
                    window.logger.log('Merged floor plan labels from storage:', {
                        existing: existingLabels.length,
                        stored: storedLabels.length,
                        merged: window.labels.length
                    });
                }
                
                // æ¨™ç±¤æ•¸æ“šè¼‰å…¥å¾Œï¼ŒåŒæ­¥åˆ°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼ï¼ˆåªé¡¯ç¤ºï¼‰
                if (typeof syncLabelsToInspectionRecords === 'function') {
                    syncLabelsToInspectionRecords();
                    window.logger.log('Synced labels to inspection records after loading from storage');
                }
                
                // æª¢æŸ¥æ¨“å±¤å¹³é¢åœ– canvas æ˜¯å¦å·²ç¶“æº–å‚™å¥½ï¼Œå¦‚æœæº–å‚™å¥½äº†æ‰é‡æ–°æ¸²æŸ“æ¨™ç±¤
                const floorPlanCanvas = document.getElementById('floorPlanCanvas');
                if (floorPlanCanvas && floorPlanCanvas.width > 0) {
                    // Canvas å·²ç¶“æº–å‚™å¥½ï¼Œç«‹å³æ¸²æŸ“æ¨™ç±¤
                    if (typeof window.redrawLabels === 'function') {
                        window.redrawLabels();
                        window.logger.log('Redrawn labels on floor plan after loading from storage (canvas ready)');
                    }
                } else {
                    // Canvas é‚„æ²’æº–å‚™å¥½ï¼Œè¨­ç½®æ¨™èªŒä»¥ä¾¿ç¨å¾Œæ¸²æŸ“
                    window.logger.log('Floor plan canvas not ready yet, labels will be rendered when drawing mode opens');
                    window.pendingLabelsRedraw = true;
                }
            }
            
            // è¼‰å…¥ç¼ºé™·æ¨™è¨˜æ•¸æ“š
            if (parsedData.floorPlanDefectMarks && typeof window.defectMarks !== 'undefined') {
                window.defectMarks = parsedData.floorPlanDefectMarks;
                window.logger.log('Loaded floor plan defect marks from storage:', window.defectMarks.length);
                
                // æª¢æŸ¥æ¨“å±¤å¹³é¢åœ– canvas æ˜¯å¦å·²ç¶“æº–å‚™å¥½ï¼Œå¦‚æœæº–å‚™å¥½äº†æ‰é‡æ–°æ¸²æŸ“ç¼ºé™·æ¨™è¨˜
                const floorPlanCanvas = document.getElementById('floorPlanCanvas');
                if (floorPlanCanvas && floorPlanCanvas.width > 0) {
                    // Canvas å·²ç¶“æº–å‚™å¥½ï¼Œç«‹å³æ¸²æŸ“ç¼ºé™·æ¨™è¨˜
                if (typeof window.redrawDefectMarks === 'function') {
                    window.redrawDefectMarks();
                        window.logger.log('Redrawn defect marks on floor plan after loading from storage (canvas ready)');
                    }
                } else {
                    // Canvas é‚„æ²’æº–å‚™å¥½ï¼Œè¨­ç½®æ¨™èªŒä»¥ä¾¿ç¨å¾Œæ¸²æŸ“
                    window.logger.log('Floor plan canvas not ready yet, defect marks will be rendered when drawing mode opens');
                    window.pendingDefectMarksRedraw = true;
                }
            }
            
            // è¼‰å…¥æ¨“å±¤å¹³é¢åœ–è¦–åœ–ç‹€æ…‹ - æ–°æ ¼å¼
            if (parsedData.floorPlanViewState) {
                const viewState = parsedData.floorPlanViewState;
                window.currentScale = viewState.scale || 1.0;
                window.translateX = viewState.translateX || 0;
                window.translateY = viewState.translateY || 0;
                window.baseScale = viewState.baseScale || 1.0;
                window.labelSizeScale = viewState.labelSizeScale || 24;
                window.defectMarkSizeScale = viewState.defectMarkSizeScale || 24;
                
                // è¨­ç½®æ¨™è¨˜ï¼Œè¡¨ç¤ºéœ€è¦åœ¨ PDF è¼‰å…¥å¾Œæ‡‰ç”¨è¦–åœ–ç‹€æ…‹
                window.pendingViewStateRestore = true;
                
                window.logger.log('Page reload: Loaded floor plan view state from PNE format');
            }
            
            // è¼‰å…¥åµŒå…¥çš„ PDF æ•¸æ“š - æ–°æ ¼å¼
            if (parsedData.embeddedPDF && parsedData.embeddedPDF.hasEmbeddedPDF) {
                window.logger.log('Page reload: Found embedded PDF data in PNE format');
                
                // å°‡åµŒå…¥çš„ PDF æ•¸æ“šä¿å­˜åˆ° localStorage
                localStorage.setItem('pne_floorplan_base64', parsedData.embeddedPDF.base64Data);
                localStorage.setItem('pne_floorplan_data', JSON.stringify(parsedData.embeddedPDF.metadata));
                localStorage.setItem('pne_floorplan_filename', parsedData.embeddedPDF.filename);
                
                window.logger.log('Page reload: Embedded PDF data restored to localStorage');
            }
            
            window.logger.log('Page reload: Loaded defect marks from storage');
            
            // ä¸å¾ submittedData é‡å»ºè¡¨æ ¼ï¼Œè€Œæ˜¯å¾æ¨™ç±¤æ•¸æ“šå‹•æ…‹ç”Ÿæˆæª¢æŸ¥è¨˜éŒ„è¡¨æ ¼
            // æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼å°‡åœ¨æ¨™ç±¤æ•¸æ“šè¼‰å…¥å¾Œé€šé syncLabelsToInspectionRecords ç”Ÿæˆ
            
            // æ›´æ–°æ‰€æœ‰åˆ†é¡é¡¯ç¤º
            categories.forEach(category => {
                updateCategoryDisplay(category.id);
            });
            
            // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼
            if (typeof window.updateDefectSummaryTable === 'function') {
                window.updateDefectSummaryTable();
            }
            
            // æ›´æ–°åˆ†é¡è¨˜éŒ„è¡¨æ ¼
            if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
                window.updateCategoryTablesFromInspectionRecords();
                window.logger.log('Page reload: Updated category tables from inspection records');
            }
            
            // ğŸ”§ ç…§ç‰‡åˆ†é…ç‹€æ…‹çš„æ¢å¾©ç¾åœ¨åœ¨ renderPhotos å®Œæˆå¾Œæ‰é€²è¡Œ
            // ç¢ºä¿ç…§ç‰‡å…ƒç´ å·²ç¶“æ¸²æŸ“åˆ° DOM ä¸­æ‰èƒ½è¨­ç½®åˆ†é…ç‹€æ…‹
            // (è¦‹ä¸Šé¢ renderPhotos å®Œæˆå¾Œçš„ setTimeout å›èª¿)
            
            // æ›´æ–°ç¼ºé™·åˆ†é¡é¡¯ç¤º
            updateCategoryDisplay('j');
            
            // é¡¯ç¤ºé‡æ–°é¸æ“‡è¨Šæ¯ï¼ˆå¦‚æœæœ‰æäº¤çš„è³‡æ–™ä¸”è³‡æ–™å¤¾åç¨±å­˜åœ¨ï¼‰
            // ä½†æ˜¯è¦é¿å…åœ¨ç…§ç‰‡å·²ç¶“æ¸²æŸ“æ™‚é¡¯ç¤ºä¸å¿…è¦çš„ reselection è¨Šæ¯
            const photoItems = document.querySelectorAll('.photo-item');
            const hasPhotosRendered = photoItems.length > 0;
            
            if (folderNameDisplay.textContent && 
                folderNameDisplay.textContent !== '' && 
                submittedData.length > 0 &&
                !folderNameDisplay.textContent.includes('Selected Files') &&
                !hasPhotosRendered) {
                showReselectMessage();
            } else {
                // å¦‚æœæ²’æœ‰æäº¤çš„è³‡æ–™ï¼Œé¡¯ç¤ºæ­£å¸¸ç©ºç‹€æ…‹
                if (submittedData.length === 0 && !(Array.isArray(allPhotos) && allPhotos.length > 0 && window.loadedFromHandles === true)) {
                    photoGrid.innerHTML = `
                        <div class="empty-preview">
                            <i class="fas fa-images fa-4x"></i>
                            <p>Select a folder to preview photos</p>
                            <button id="centerFolderBtn" class="center-folder-btn" onclick="selectPhotoFolder()">
                                <i class="fas fa-folder-open"></i> Select Photo Folder
                            </button>
                        </div>
                    `;
                }
            }
            
            // æ›´æ–°è³‡æ–™å¤¾é¡¯ç¤º
            updateFolderDisplay();
            
            // æ›´æ–° Add photos æŒ‰éˆ•å¯è¦‹æ€§
            updateAddPhotosButtonVisibility();
            
            // é¡¯ç¤ºè¼‰å…¥æˆåŠŸè¨Šæ¯
            if (parsedData.lastSaved) {
                const lastSavedDate = new Date(parsedData.lastSaved);
                const timeDiff = Date.now() - lastSavedDate.getTime();
                const hoursDiff = Math.floor(timeDiff / (1000 * 60 * 60));
                
                if (hoursDiff < 24) {
                    showNotification(`Data loaded successfully. Last saved: ${hoursDiff} hours ago`, 'success');
                } else {
                    const daysDiff = Math.floor(hoursDiff / 24);
                    showNotification(`Data loaded successfully. Last saved: ${daysDiff} days ago`, 'success');
                }
            }
            
            // è¼‰å…¥ç•¶å‰ä»»å‹™æ•¸æ“š
            if (parsedData.currentTask) {
                currentTask = parsedData.currentTask;
                window.logger.log('Loaded current task from storage:', currentTask.name);
                // Update task display after loading
                updateTaskDisplay();
            }
            
            window.logger.log('Enhanced data loaded from localStorage successfully');
            
        } catch (e) {
            window.logger.error('Failed to parse saved data', e);
            showNotification('Failed to load saved data. Starting fresh.', 'error');
        }
    } else {
        // æ²’æœ‰ä¿å­˜çš„è³‡æ–™ï¼Œé¡¯ç¤ºæ­£å¸¸ç©ºç‹€æ…‹
        if (!(Array.isArray(allPhotos) && allPhotos.length > 0 && window.loadedFromHandles === true)) {
        photoGrid.innerHTML = `
            <div class="empty-preview">
                <i class="fas fa-images fa-4x"></i>
                <p>Select a folder to preview photos</p>
                <button id="centerFolderBtn" class="center-folder-btn" onclick="selectPhotoFolder()">
                    <i class="fas fa-folder-open"></i> Select Photo Folder
                </button>
            </div>
        `;}
        
        // æ›´æ–° Add photos æŒ‰éˆ•å¯è¦‹æ€§
        updateAddPhotosButtonVisibility();
    }
    
    // æ³¨æ„ï¼šä¸å†æ¸…é™¤åˆ†é¡å…§å®¹ï¼Œå› ç‚ºç¾åœ¨æœƒå¾ localStorage è¼‰å…¥
    window.logger.log('Data loading completed. Categories content preserved from localStorage');
}

// Clear all categories content on page reload
function clearCategoriesOnPageReload() {
    window.logger.log('Clearing all categories content on page reload');
    
    // Clear all category numbers
    categories.forEach(category => {
        categoryNumbers[category.id] = [];
    });
    
    // Clear all assigned photos
    categories.forEach(category => {
        assignedPhotos[category.id] = new Set();
    });
    
    // Clear defect entries
    window.defectEntries.length = 0;
    
    // Remove assigned class from all photos (but keep submitted class)
    document.querySelectorAll('.photo-item').forEach(item => {
        if (item.classList.contains('assigned') && !item.classList.contains('submitted')) {
            item.classList.remove('assigned');
            const img = item.querySelector('img');
            if (img) {
                img.style.filter = '';
                img.style.opacity = '';
            }
            
            // Always show photo number (extracted from filename)
            const photoNumberDiv = item.querySelector('.photo-number');
            if (photoNumberDiv) {
                const filename = item.dataset.filename;
                const numberMatch = filename.match(/\d+/);
                const number = numberMatch ? numberMatch[0] : '';
                photoNumberDiv.textContent = number;
            }
        }
    });
    
    // Update all category displays
    categories.forEach(category => {
        updateCategoryDisplay(category.id);
    });
    
    // Update defect summary table after clearing categories
    if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
    
    window.logger.log('All categories content cleared on page reload');
}

// Show folder reselection message
function showReselectMessage() {
    // Show if we have submitted data OR defect entries (indicating previous work)
    if (submittedData.length === 0 && window.defectEntries.length === 0) {
        return;
    }
    
    photoGrid.innerHTML = '';
    const message = document.createElement('div');
    message.className = 'overlay-message';
    
    const isFolderSupported = isWebkitDirectorySupported();
    const buttonText = isFolderSupported ? 'Re-select Folder' : 'Re-select Photos';
    const buttonIcon = isFolderSupported ? 'fa-folder-open' : 'fa-images';
    
    message.innerHTML = `
        <h3><i class="fas fa-exclamation-circle"></i> ${isFolderSupported ? 'Folder' : 'Photo'} Reselection Required</h3>
        <p>Photos from the previous session are not displayed.</p>
        <p>Please reselect the ${isFolderSupported ? 'folder' : 'photos'} to view images.</p>
        <p>${isFolderSupported ? 'Folder' : 'Session'}: ${folderNameDisplay.textContent}</p>
        <button class="overlay-btn" id="reselectFolderBtn" style="margin-top: 15px;">
            <i class="fas ${buttonIcon}"></i> ${buttonText}
        </button>
    `;
    photoGrid.appendChild(message);

    // Add event listener for the button
    const reselectBtn = message.querySelector('#reselectFolderBtn');
    reselectBtn.addEventListener('click', () => {
        selectPhotoFolder();
    });
}

// Reset photo preview state
async function resetPhotoState() {
    // Clear photo arrays
    allPhotos = [];
    selectedPhotos = [];
    submittedFilenames = new Set();
    
    // Reset category assignments
    categories.forEach(category => {
        assignedPhotos[category.id] = new Set();
    });
    
    // Reset UI elements
    folderNameDisplay.textContent = '';
    updateFolderDisplay();
    
    // Show empty preview
    renderPhotos([]);
    selectedCount.textContent = '0';
    
    // Update button visibility
    updateAddPhotosButtonVisibility();
    
    // Clear saved photo data from storage
    const savedData = await window.storageAdapter.getItemDirect('photoNumberExtractorData');
    if (savedData) {
        delete savedData.allPhotoFilenames;
        await window.storageAdapter.setItemDirect('photoNumberExtractorData', savedData);
    }
}

// Handle folder selection - moved to PNE dropdown menu

// Handle cancel button
cancelResetBtn.addEventListener('click', () => {
    globalOverlay.style.display = 'none';
});

// Handle force reset button
forceResetBtn.addEventListener('click', () => {
    // Clear the table and reset state
    clearTable();
    // Hide the overlay
    globalOverlay.style.display = 'none';
    // Now proceed with folder selection
    selectPhotoFolder();
});

// Resize image function (supports various sizes up to 1200px long edge)
function resizeImage(file) {
    return new Promise((resolve, reject) => {
        window.logger.log(`Processing image: ${file.name} (${file.size} bytes)`);
        
        // Check if this is a metadata object with dataURL (from PNE file)
        if (file.dataURL) {
            window.logger.log(`Using existing dataURL for: ${file.name}`);
            resolve(file.dataURL);
            return;
        }
        
        // Check file size (limit to 10MB to prevent memory issues)
        if (file.size > 10 * 1024 * 1024) {
            reject(new Error(`File ${file.name} is too large (${Math.round(file.size / 1024 / 1024)}MB). Please use images smaller than 10MB.`));
            return;
        }
        
        // Check if file is a proper File object
        if (!(file instanceof File) && !(file instanceof Blob)) {
            window.logger.error(`Invalid file object for: ${file.name}`, file);
            reject(new Error(`Invalid file object for: ${file.name}`));
            return;
        }
        
        const reader = new FileReader();
        
        reader.onerror = function() {
            window.logger.error(`Failed to read file: ${file.name}`);
            reject(new Error(`Failed to read file: ${file.name}`));
        };
        
        reader.onload = function(e) {
            window.logger.log(`File read successfully: ${file.name}`);
            const img = new Image();
            
            img.onerror = function() {
                window.logger.error(`Failed to load image: ${file.name}`);
                reject(new Error(`Failed to load image: ${file.name}`));
            };
            
            img.onload = async function() {
                window.logger.log(`Image loaded successfully: ${file.name} (${img.width}x${img.height})`);
                try {
                    // Check if this is a 360 panorama photo
                    const aspectRatio = img.width / img.height;
                    const is360Photo = aspectRatio >= 1.9 && aspectRatio <= 2.1;
                    
                    if (is360Photo) {
                        window.logger.log(`ğŸŒ Detected 360 panorama photo: ${file.name}, preserving full resolution`);
                    }
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    let newWidth = img.width;
                    let newHeight = img.height;
                    let quality = CONFIG.photo.quality || 0.8;
                    
                    // æ‰€æœ‰ç…§ç‰‡ï¼ˆåŒ…æ‹¬ 360 ç…§ç‰‡ï¼‰éƒ½å£“ç¸®åˆ°æœ€å¤§ 1200px
                    const maxWidth = CONFIG.photo.maxWidth || 1200;
                    const maxHeight = CONFIG.photo.maxHeight || 1200;
                    
                    // è¨ˆç®—å£“ç¸®æ¯”ä¾‹ï¼ˆä¿æŒå¯¬é«˜æ¯”ï¼‰
                    const ratio = Math.min(
                        maxWidth / img.width,
                        maxHeight / img.height,
                        1.0 // ä¸æ”¾å¤§ï¼Œåªç¸®å°
                    );
                    
                    if (ratio < 1.0) {
                        newWidth = Math.round(img.width * ratio);
                        newHeight = Math.round(img.height * ratio);
                        window.logger.log(`Resizing ${file.name} from ${img.width}x${img.height} to ${newWidth}x${newHeight} (ratio: ${ratio.toFixed(2)})`);
                    } else {
                        // å¦‚æœåœ–ç‰‡å·²ç¶“å°æ–¼æœ€å¤§å°ºå¯¸ï¼Œä¿æŒåŸå°ºå¯¸
                        window.logger.log(`Keeping original size for ${file.name}: ${newWidth}x${newHeight} (within limits)`);
                    }
                    
                    // Check if dimensions are reasonable
                    if (newWidth <= 0 || newHeight <= 0 || newWidth > 12000 || newHeight > 12000) {
                        reject(new Error(`Invalid image dimensions for ${file.name}`));
                        return;
                    }
                    
                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    
                    // Draw image
                    ctx.drawImage(img, 0, 0, newWidth, newHeight);
                    
                    // Convert to data URL with appropriate quality
                    try {
                        const dataURL = canvas.toDataURL('image/jpeg', quality);
                        window.logger.log(`Image processed successfully: ${file.name} (${is360Photo ? '360 panorama' : 'standard'})`);
                        resolve(dataURL);
                    } catch (canvasError) {
                        window.logger.warn(`Canvas failed for ${file.name}, using original:`, canvasError);
                        // Fallback: return original data URL if canvas fails
                        resolve(e.target.result);
                    }
                } catch (error) {
                    window.logger.warn(`Processing failed for ${file.name}, using original:`, error);
                    // Fallback: return original data URL if processing fails
                    resolve(e.target.result);
                }
            };
            
            img.src = e.target.result;
        };
        
        reader.readAsDataURL(file);
    });
}

// Intersection Observer for lazy loading (simplified since we're not using data-src anymore)
function initLazyLoading() {
    const lazyObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                // Since we're loading images directly, just unobserve
                lazyObserver.unobserve(entry.target);
            }
        });
    }, {
        rootMargin: '100px 0px',
        threshold: 0.1
    });
    
    return lazyObserver;
}

// Check browser support for webkitdirectory
function isWebkitDirectorySupported() {
    const input = document.createElement('input');
    return 'webkitdirectory' in input;
}

// Select multiple files (fallback for Safari/Firefox)
function selectMultipleFiles() {
    window.logger.log('selectMultipleFiles called');
    
    // Show loading indicator
    showNotification('Please select photo files...', 'info', 2000);
    
    const input = document.createElement('input');
    input.type = 'file';
    input.multiple = true;
    input.accept = 'image/*';
    input.style.display = 'none';
    
    // Add user gesture optimization
    input.addEventListener('click', (e) => {
        e.stopPropagation();
    });
    
    input.addEventListener('change', async (e) => {
        window.logger.log('File input change event triggered');
        if (e.target.files.length > 0) {
            window.logger.log('Files selected (Safari/Firefox):', e.target.files.length);
            
            // Helper function to show photo upload loading
            const showPhotoUploadLoading = (message = 'æ­£åœ¨è™•ç†ç…§ç‰‡ï¼Œè«‹ç¨å€™') => {
                const loadingStatus = document.getElementById('photoUploadLoadingStatus');
                const statusTitle = document.getElementById('photoUploadStatusTitle');
                const statusMessage = document.getElementById('photoUploadStatusMessage');
                if (loadingStatus && statusTitle && statusMessage) {
                    statusTitle.textContent = 'ä¸Šå‚³ç…§ç‰‡ä¸­...';
                    statusMessage.textContent = message;
                    loadingStatus.style.display = 'flex';
                }
            };
            
            // Helper function to hide photo upload loading
            const hidePhotoUploadLoading = () => {
                const loadingStatus = document.getElementById('photoUploadLoadingStatus');
                if (loadingStatus) {
                    loadingStatus.style.display = 'none';
                }
            };
            
            // Show processing notification
            showNotification('Processing photos...', 'info', 1000);
            
            // Show loading indicator
            showPhotoUploadLoading('æ­£åœ¨è®€å–ç…§ç‰‡æª”æ¡ˆ...');
            
            // Filter only image files
            const imageFiles = Array.from(e.target.files).filter(file =>
                /\.(jpe?g|png|gif|bmp|webp)$/i.test(file.name)
            );
            
            window.logger.log('Valid image files (Safari/Firefox):', imageFiles.length);
            
            if (imageFiles.length === 0) {
                hidePhotoUploadLoading();
                showNotification('No valid image files selected!', 'error');
                return;
            }
            
            // Set folder name to "Selected Files" for Safari/Firefox
            folderNameDisplay.textContent = `Selected Files (${imageFiles.length})`;
            
            // Sort photos by filename
            const sortedPhotos = imageFiles.sort((a, b) => {
                return a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'});
            });
            
            // Update loading message function
            const updateMessage = (message) => {
                showPhotoUploadLoading(message);
            };
            
            window.logger.log('Starting to process photos one by one (Safari/Firefox)...');
            
            // Process photos one by one with immediate visual feedback
            // IMPORTANT: Set allPhotos BEFORE processing to ensure index alignment
            allPhotos = sortedPhotos;
            await processAndRenderPhotosOneByOne(sortedPhotos, updateMessage);
            
            window.logger.log('Photos processed and displayed successfully (Safari/Firefox)');
            
            updateFolderDisplay();
            
            // Update button visibility
            updateAddPhotosButtonVisibility();
            
            // ç­‰å¾…ä¸€å°æ®µæ™‚é–“ç¢ºä¿æ‰€æœ‰ dataURL éƒ½å·²ç¶“ç”Ÿæˆä¸¦é™„åŠ åˆ° File å°è±¡ä¸Š
            showPhotoUploadLoading('æ­£åœ¨å„²å­˜ç…§ç‰‡è³‡æ–™...');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // ç«‹å³ä¿å­˜ç…§ç‰‡æ•¸æ“šï¼ˆåŒ…å« dataURLï¼‰åˆ° IndexedDB
            console.log('ğŸ’¾ Saving photos after multiple file selection...');
            const photosWithDataURL = allPhotos.filter(p => p.dataURL).length;
            console.log(`ğŸ“Š Photos with dataURL: ${photosWithDataURL} / ${allPhotos.length}`);
            await saveDataToStorage();
            console.log('âœ… Photos saved to IndexedDB');
            
            // Hide loading indicator
            hidePhotoUploadLoading();
            
            showNotification(`Successfully loaded ${imageFiles.length} images!`, 'success');
        } else {
            window.logger.log('No files selected');
            showNotification('No files selected', 'warning');
        }
    });
    
    window.logger.log('Appending input to body and clicking');
    document.body.appendChild(input);
    
    // Directly trigger click in Chrome Windows - must be within user activation context
    // Use setTimeout(0) instead of requestAnimationFrame to ensure user activation is preserved
    setTimeout(() => {
        try {
            input.click();
        } catch (error) {
            window.logger.error('Error triggering file input click:', error);
            // Fallback: try with requestAnimationFrame
            requestAnimationFrame(() => {
                try {
                    input.click();
                } catch (e) {
                    window.logger.error('Error in requestAnimationFrame fallback:', e);
                    showNotification('ç„¡æ³•é–‹å•Ÿæª”æ¡ˆé¸æ“‡å°è©±æ¡†ï¼Œè«‹å†è©¦ä¸€æ¬¡', 'error');
                }
            });
        }
        // Clean up immediately after click
        setTimeout(() => {
            if (document.body.contains(input)) {
                document.body.removeChild(input);
            }
        }, 100);
    }, 0);
}

// Actual folder selection function
async function selectPhotoFolder() {
    // Clear all categories and defects content silently
    categories.forEach(category => {
        clearCategory(category.id, true);
    });
    
    // Show loading indicator
    showNotification('Please select a photo folder...', 'info', 2000);
    
    // Helper function to show photo upload loading
    const showPhotoUploadLoading = (message = 'æ­£åœ¨è™•ç†ç…§ç‰‡ï¼Œè«‹ç¨å€™') => {
        const loadingStatus = document.getElementById('photoUploadLoadingStatus');
        const statusTitle = document.getElementById('photoUploadStatusTitle');
        const statusMessage = document.getElementById('photoUploadStatusMessage');
        if (loadingStatus && statusTitle && statusMessage) {
            statusTitle.textContent = 'ä¸Šå‚³ç…§ç‰‡ä¸­...';
            statusMessage.textContent = message;
            loadingStatus.style.display = 'flex';
        }
    };
    
    // Helper function to hide photo upload loading
    const hidePhotoUploadLoading = () => {
        const loadingStatus = document.getElementById('photoUploadLoadingStatus');
        if (loadingStatus) {
            loadingStatus.style.display = 'none';
        }
    };
    
    // Check if webkitdirectory is supported
    if (window.showDirectoryPicker) {
        // Preferred: File System Access API
        try {
            const dirHandle = await window.showDirectoryPicker();
            // Persist handle
            try { await window.storageAdapter.setItem('pne_photos_dir_handle', dirHandle); } catch (e) {}
            folderNameDisplay.textContent = dirHandle.name || 'Selected Folder';
            
            // Show loading indicator
            showPhotoUploadLoading('æ­£åœ¨è®€å–ç…§ç‰‡æª”æ¡ˆ...');
            
            // Iterate files
            const imageFiles = [];
            for await (const [name, handle] of dirHandle.entries()) {
                // Filter out macOS resource fork files (._* files) and only accept valid image files
                if (handle.kind === 'file' && 
                    !name.startsWith('._') && 
                    /\.(jpe?g|png|gif|bmp|webp)$/i.test(name)) {
                    const file = await handle.getFile();
                    imageFiles.push(file);
                }
            }
            if (imageFiles.length === 0) {
                hidePhotoUploadLoading();
                showNotification('No valid image files found in the selected folder!', 'error');
                return;
            }
            
            // Sort photos by filename
            const sortedPhotos = imageFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'}));
            
            // Update loading message function
            const updateMessage = (message) => {
                showPhotoUploadLoading(message);
            };
            
            // Process photos one by one with immediate visual feedback
            // IMPORTANT: Set allPhotos BEFORE processing to ensure index alignment
            allPhotos = sortedPhotos;
            await processAndRenderPhotosOneByOne(sortedPhotos, updateMessage);
            
            updateFolderDisplay();
            updateAddPhotosButtonVisibility();
            
            // ç­‰å¾…ä¸€å°æ®µæ™‚é–“ç¢ºä¿æ‰€æœ‰ dataURL éƒ½å·²ç¶“ç”Ÿæˆä¸¦é™„åŠ åˆ° File å°è±¡ä¸Š
            showPhotoUploadLoading('æ­£åœ¨å„²å­˜ç…§ç‰‡è³‡æ–™...');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // ç«‹å³ä¿å­˜ç…§ç‰‡æ•¸æ“šï¼ˆåŒ…å« dataURLï¼‰åˆ° IndexedDB
            console.log('ğŸ’¾ Saving photos after folder selection...');
            const photosWithDataURL = allPhotos.filter(p => p.dataURL).length;
            console.log(`ğŸ“Š Photos with dataURL: ${photosWithDataURL} / ${allPhotos.length}`);
            await saveDataToStorage();
            console.log('âœ… Photos saved to IndexedDB');
            
            // Hide loading indicator
            hidePhotoUploadLoading();
            
            showNotification('Photos loaded from folder!', 'success');
            return;
        } catch (e) {
            hidePhotoUploadLoading();
            // fallback to input method
        }
    }
    if (isWebkitDirectorySupported()) {
        // Chrome/Edge - use folder selection
        const input = document.createElement('input');
        input.type = 'file';
        input.webkitdirectory = true;
        input.multiple = true;
        input.accept = 'image/*';
        input.style.display = 'none';
        
        // Add user gesture optimization
        input.addEventListener('click', (e) => {
            // Prevent any potential issues with the file dialog
            e.stopPropagation();
        });
        
        input.addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                window.logger.log('Files selected:', e.target.files.length);
                
                // Helper function to show photo upload loading
                const showPhotoUploadLoading = (message = 'æ­£åœ¨è™•ç†ç…§ç‰‡ï¼Œè«‹ç¨å€™') => {
                    const loadingStatus = document.getElementById('photoUploadLoadingStatus');
                    const statusTitle = document.getElementById('photoUploadStatusTitle');
                    const statusMessage = document.getElementById('photoUploadStatusMessage');
                    if (loadingStatus && statusTitle && statusMessage) {
                        statusTitle.textContent = 'ä¸Šå‚³ç…§ç‰‡ä¸­...';
                        statusMessage.textContent = message;
                        loadingStatus.style.display = 'flex';
                    }
                };
                
                // Helper function to hide photo upload loading
                const hidePhotoUploadLoading = () => {
                    const loadingStatus = document.getElementById('photoUploadLoadingStatus');
                    if (loadingStatus) {
                        loadingStatus.style.display = 'none';
                    }
                };
                
                // Show processing notification
                showNotification('Processing photos...', 'info', 1000);
                
                // Show loading indicator
                showPhotoUploadLoading('æ­£åœ¨è®€å–ç…§ç‰‡æª”æ¡ˆ...');
                
                const path = e.target.files[0].webkitRelativePath;
                const folder = path.split('/')[0];
                folderNameDisplay.textContent = folder;
                
                // Filter only image files, excluding macOS resource fork files (._* files)
                const imageFiles = Array.from(e.target.files).filter(file =>
                    !file.name.startsWith('._') && 
                    /\.(jpe?g|png|gif|bmp|webp)$/i.test(file.name)
                );
                
                window.logger.log('Valid image files:', imageFiles.length);
                
                if (imageFiles.length === 0) {
                    hidePhotoUploadLoading();
                    showNotification('No valid image files found in the selected folder!', 'error');
                    return;
                }
                
                // Sort photos by filename
                const sortedPhotos = imageFiles.sort((a, b) => {
                    return a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'});
                });
                
                // Update loading message function
                const updateMessage = (message) => {
                    showPhotoUploadLoading(message);
                };
                
                window.logger.log('Starting to process photos one by one...');
                
                // Process photos one by one with immediate visual feedback
                // IMPORTANT: Set allPhotos BEFORE processing to ensure index alignment
                allPhotos = sortedPhotos;
                await processAndRenderPhotosOneByOne(sortedPhotos, updateMessage);
                
                window.logger.log('Photos processed and displayed successfully');
                
                updateFolderDisplay();
                
                // Update button visibility
                updateAddPhotosButtonVisibility();
                
                // ç­‰å¾…ä¸€å°æ®µæ™‚é–“ç¢ºä¿æ‰€æœ‰ dataURL éƒ½å·²ç¶“ç”Ÿæˆä¸¦é™„åŠ åˆ° File å°è±¡ä¸Š
                showPhotoUploadLoading('æ­£åœ¨å„²å­˜ç…§ç‰‡è³‡æ–™...');
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // ç«‹å³ä¿å­˜ç…§ç‰‡æ•¸æ“šï¼ˆåŒ…å« dataURLï¼‰åˆ° IndexedDB
                console.log('ğŸ’¾ Saving photos after folder selection...');
                const photosWithDataURL = allPhotos.filter(p => p.dataURL).length;
                console.log(`ğŸ“Š Photos with dataURL: ${photosWithDataURL} / ${allPhotos.length}`);
                await saveDataToStorage();
                console.log('âœ… Photos saved to IndexedDB');
                
                // Hide loading indicator
                hidePhotoUploadLoading();
                
                showNotification(`Successfully loaded ${imageFiles.length} images from folder: ${folder}`, 'success');
            } else {
                showNotification('No files selected', 'warning');
            }
        });
        
        // Optimize file dialog trigger
        document.body.appendChild(input);
        
        // Directly trigger click in Chrome Windows - must be within user activation context
        // Use setTimeout(0) instead of requestAnimationFrame to ensure user activation is preserved
        setTimeout(() => {
            try {
                input.click();
            } catch (error) {
                window.logger.error('Error triggering file input click:', error);
                // Fallback: try with requestAnimationFrame
                requestAnimationFrame(() => {
                    try {
                        input.click();
                    } catch (e) {
                        window.logger.error('Error in requestAnimationFrame fallback:', e);
                        showNotification('ç„¡æ³•é–‹å•Ÿæª”æ¡ˆé¸æ“‡å°è©±æ¡†ï¼Œè«‹å†è©¦ä¸€æ¬¡', 'error');
                    }
                });
            }
            // Clean up immediately after click
            setTimeout(() => {
                if (document.body.contains(input)) {
                    document.body.removeChild(input);
                }
            }, 100);
        }, 0);
    } else {
        // Safari/Firefox - directly use multiple file selection
        window.logger.log('Browser does not support folder selection, using multiple file selection');
        selectMultipleFiles();
    }
}

// Process and render photos one by one with immediate visual feedback
async function processAndRenderPhotosOneByOne(photos, updateLoadingMessage) {
    window.logger.log('processAndRenderPhotosOneByOne called with', photos.length, 'photos');
    
    // Clear the grid first
    photoGrid.innerHTML = '';
    
    if (photos.length === 0) {
        window.logger.log('No photos to process');
        return;
    }
    
    // Initialize variables
    selectedPhotos = [];
    updateSelectedCount();
    
    // Process each photo one by one
    for (let i = 0; i < photos.length; i++) {
        const file = photos[i];
        
        try {
            // Update loading message
            if (updateLoadingMessage) {
                updateLoadingMessage(`æ­£åœ¨è™•ç†ç¬¬ ${i + 1}/${photos.length} å¼µç…§ç‰‡: ${file.name}`);
            }
            
            window.logger.log(`Processing photo ${i + 1}/${photos.length}: ${file.name}`);
            
            // Calculate and store content hash for duplicate detection
            if (!file.contentHash) {
                try {
                    file.contentHash = await calculateFileHash(file);
                    // Store hash for future duplicate detection
                    photoHashStorage.set(file.name, file.contentHash);
                    window.logger.log(`Calculated hash for ${file.name}: ${file.contentHash.substring(0, 16)}...`);
                } catch (error) {
                    window.logger.error(`Error calculating hash for ${file.name}:`, error);
                }
            } else {
                // Hash already exists, just store it
                photoHashStorage.set(file.name, file.contentHash);
            }
            
            // Resize/compress the image
            let resizedImageURL;
            if (file.dataURL && typeof file.dataURL === 'string' && file.dataURL.trim() !== '') {
                resizedImageURL = file.dataURL;
                window.logger.log(`Using existing dataURL for: ${file.name}`);
            } else {
                // Compress and resize the image
                window.logger.log(`Compressing and resizing: ${file.name}`);
                resizedImageURL = await resizeImage(file);
                file.dataURL = resizedImageURL; // Save for future use
            }
            
            // Create photo item element
            const photoItem = document.createElement('div');
            photoItem.className = 'photo-item';
            photoItem.dataset.index = i;
            photoItem.dataset.filename = file.name;
            photoItem.setAttribute('role', 'gridcell');
            photoItem.setAttribute('aria-label', `Photo ${i + 1}`);
            // Disable native drag and drop to allow custom drag selection
            photoItem.draggable = false;
            
            // Check if this photo is already assigned to any category
            let isAssigned = false;
            for (const cat in assignedPhotos) {
                if (assignedPhotos[cat].has(file.name)) {
                    isAssigned = true;
                    photoItem.classList.add('assigned');
                    break;
                }
            }
            
            // Check if this photo has been submitted
            let isSubmitted = false;
            if (submittedFilenames && submittedFilenames.has(file.name)) {
                isSubmitted = true;
            } else if (window.labels && Array.isArray(window.labels)) {
                for (const label of window.labels) {
                    if (label.submitted && label.photoFilenames && label.photoFilenames.includes(file.name)) {
                        isSubmitted = true;
                        break;
                    }
                }
            }
            
            if (isSubmitted) {
                photoItem.classList.add('submitted');
            }
            
            // Extract number from filename
            const numberMatch = file.name.match(/\d+/);
            const number = numberMatch ? numberMatch[0] : 'N/A';
            
            // Add "new" icon for newly added photos
            const newIconHtml = file.isNewlyAdded ? '<div class="new-icon">new</div>' : '';
            
            photoItem.innerHTML = `
                <img src="${resizedImageURL}" alt="${file.name}">
                <div class="photo-number">${number}</div>
                <div class="photo-status" id="status-${i}"></div>
                ${newIconHtml}
            `;
            
            // Disable image dragging to prevent native drag behavior
            const imgEl = photoItem.querySelector('img');
            if (imgEl) {
                imgEl.draggable = false;
                imgEl.style.userSelect = 'none';
                imgEl.style.webkitUserDrag = 'none';
            }
            
            // Save webkitRelativePath if available
            if (file.webkitRelativePath) {
                photoItem.dataset.webkitRelativePath = file.webkitRelativePath;
            }
            
            // Set status text if submitted
            if (isSubmitted) {
                const statusDiv = photoItem.querySelector('.photo-status');
                if (statusDiv) {
                    let locationId = null;
                    if (submittedData && submittedData.length > 0) {
                        for (const row of submittedData) {
                            if (row.photoFilenames && row.photoFilenames.includes(file.name)) {
                                locationId = row.locationId;
                                break;
                            }
                        }
                    }
                    if (!locationId && window.labels && Array.isArray(window.labels)) {
                        for (const label of window.labels) {
                            if (label.submitted && label.photoFilenames && label.photoFilenames.includes(file.name)) {
                                locationId = label.inspectionNo || label.locationId;
                                break;
                            }
                        }
                    }
                    if (locationId) {
                        statusDiv.textContent = `${locationId}`;
                        statusDiv.style.display = 'flex';
                    }
                }
            }
            
            // Set status text if assigned to category
            if (isAssigned && !isSubmitted) {
                const statusDiv = photoItem.querySelector('.photo-status');
                if (statusDiv) {
                    for (const cat in assignedPhotos) {
                        if (assignedPhotos[cat].has(file.name)) {
                            const categoryName = categories.find(catObj => catObj.id === cat)?.name || cat.toUpperCase();
                            statusDiv.textContent = `Assigned to ${categoryName}`;
                            statusDiv.style.display = 'flex';
                            break;
                        }
                    }
                }
            }
            
            // Double-click to preview
            if (imgEl) {
                imgEl.addEventListener('dblclick', async (e) => {
                    e.stopPropagation();
                    try {
                        await showPhotoPreviewPopup(file, photoItem);
                    } catch (err) {
                        console.error('Failed to open photo preview popup:', err);
                    }
                });
            }
            
            // Add click event listener
            photoItem.addEventListener('click', (event) => {
                if (photoItem.classList.contains('assigned') || photoItem.classList.contains('submitted')) {
                    return;
                }
                
                const currentIndex = parseInt(photoItem.dataset.index);
                
                // Handle selection with shift key (range selection)
                if (event.shiftKey && selectedPhotos.length > 0) {
                    const lastIndex = selectedPhotos[selectedPhotos.length - 1];
                    const start = Math.min(lastIndex, currentIndex);
                    const end = Math.max(lastIndex, currentIndex);
                    
                    for (let j = start; j <= end; j++) {
                        const item = photoGrid.querySelector(`[data-index="${j}"]`);
                        if (item && !item.classList.contains('assigned') && !item.classList.contains('submitted')) {
                            item.classList.add('selected');
                            if (!selectedPhotos.includes(j)) {
                                selectedPhotos.push(j);
                            }
                        }
                    }
                }
                // Handle selection with ctrl/cmd key (multi-select)
                else if (event.ctrlKey || event.metaKey) {
                    if (selectedPhotos.includes(currentIndex)) {
                        // Deselect if already selected
                        selectedPhotos = selectedPhotos.filter(idx => idx !== currentIndex);
                        photoItem.classList.remove('selected');
                    } else {
                        // Add to selection
                        selectedPhotos.push(currentIndex);
                        photoItem.classList.add('selected');
                    }
                }
                // Normal single selection (clear others)
                else {
                    // Clear all previous selections
                    document.querySelectorAll('.photo-item.selected').forEach(item => {
                        item.classList.remove('selected');
                    });
                    selectedPhotos = [currentIndex];
                    photoItem.classList.add('selected');
                }
                
                updateSelectedCount();
            });
            
            // Immediately append to grid for visual feedback
            photoGrid.appendChild(photoItem);
            
            // Use requestAnimationFrame to allow UI to update
            await new Promise(resolve => requestAnimationFrame(resolve));
            
            window.logger.log(`Photo ${i + 1}/${photos.length} processed and displayed: ${file.name}`);
            
        } catch (error) {
            window.logger.error(`Error processing photo ${file.name}:`, error);
            // Continue with next photo even if one fails
        }
    }
    
    // Initialize lazy loading observer after all photos are added
    const lazyObserver = initLazyLoading();
    if (lazyObserver && photoGrid) {
        const images = photoGrid.querySelectorAll('img[data-lazy]');
        images.forEach(img => lazyObserver.observe(img));
    }
    
    window.logger.log('All photos processed and displayed');
}

// Render only new photos without re-rendering existing ones
async function renderNewPhotosOnly(newPhotos, lazyObserver) {
    window.logger.log('renderNewPhotosOnly called with', newPhotos.length, 'new photos');
    
    if (newPhotos.length === 0) {
        window.logger.log('No new photos to render');
        return;
    }
    
    // Get current photo count to determine starting index
    const currentPhotoCount = document.querySelectorAll('.photo-item').length;
    window.logger.log('Current photo count:', currentPhotoCount);
    
    // Process new photos
    for (let i = 0; i < newPhotos.length; i++) {
        const file = newPhotos[i];
        const index = currentPhotoCount + i;
        
        try {
            window.logger.log(`Creating photo item for new photo: ${file.name}`);
            // Use the dataURL that was already created during add photos process
            const resizedImageURL = file.dataURL;
            window.logger.log(`Got resized URL for new photo: ${file.name}`);
            
            const photoItem = document.createElement('div');
            photoItem.className = 'photo-item';
            photoItem.dataset.index = index;
            photoItem.dataset.filename = file.name;
            photoItem.setAttribute('role', 'gridcell');
            photoItem.setAttribute('aria-label', `Photo ${index + 1}`);
            // Disable native drag and drop to allow custom drag selection
            photoItem.draggable = false;
            
            // Check if this photo is already assigned to any category
            let isAssigned = false;
            for (const cat in assignedPhotos) {
                if (assignedPhotos[cat].has(file.name)) {
                    isAssigned = true;
                    photoItem.classList.add('assigned');
                    break;
                }
            }
            
            // Check if this photo has been submitted - validate against current labels data
            let isSubmitted = false;
            if (window.labels && Array.isArray(window.labels)) {
                // Check if photo is in any submitted label
                for (const label of window.labels) {
                    if (label.submitted && label.photoFilenames && label.photoFilenames.includes(file.name)) {
                        isSubmitted = true;
                        break;
                    }
                }
            } else {
                // Fallback to submittedFilenames if labels data is not available
                isSubmitted = submittedFilenames.has(file.name);
            }
            
            if (isSubmitted) {
                photoItem.classList.add('submitted');
            }
            
            // Extract number from filename
            const numberMatch = file.name.match(/\d+/);
            const number = numberMatch ? numberMatch[0] : 'N/A';
            
            // Add "new" icon for newly added photos
            const newIconHtml = file.isNewlyAdded ? '<div class="new-icon">new</div>' : '';
            window.logger.log(`New photo ${file.name}: isNewlyAdded=${file.isNewlyAdded}, newIconHtml=${newIconHtml ? 'added' : 'not added'}`);
            
            photoItem.innerHTML = `
                <img src="${resizedImageURL}" alt="${file.name}">
                <div class="photo-number">${number}</div>
                <div class="photo-status" id="status-${index}"></div>
                ${newIconHtml}
            `;
            
            // Disable image dragging to prevent native drag behavior
            const imgEl = photoItem.querySelector('img');
            if (imgEl) {
                imgEl.draggable = false;
                imgEl.style.userSelect = 'none';
                imgEl.style.webkitUserDrag = 'none';
            }
            
            // Set status text if submitted
            if (isSubmitted) {
                const statusDiv = photoItem.querySelector('.photo-status');
                if (statusDiv) {
                    // Find the location ID for this photo
                    for (const row of submittedData) {
                        if (row.photoFilenames.includes(file.name)) {
                            statusDiv.textContent = `${row.locationId}`;
                            statusDiv.style.display = 'flex';
                            break;
                        }
                    }
                }
            }
            
            // Set status text if assigned to category
            if (isAssigned) {
                const statusDiv = photoItem.querySelector('.photo-status');
                if (statusDiv && !isSubmitted) {
                    // Find which category this photo is assigned to
                    for (const cat in assignedPhotos) {
                        if (assignedPhotos[cat].has(file.name)) {
                            const categoryName = categories.find(catObj => catObj.id === cat)?.name || cat.toUpperCase();
                            statusDiv.textContent = `Assigned to ${categoryName}`;
                            statusDiv.style.display = 'flex';
                            statusDiv.style.zIndex = '10'; // Ensure status is above placeholder
                            break;
                        }
                    }
                }
            }
            
            // é›™æ“Šç¸®åœ–é–‹å•ŸåŸå°ºå¯¸é è¦½ï¼ˆå«å‹•ç•«ï¼‰
            if (imgEl) {
                imgEl.addEventListener('dblclick', async (e) => {
                    e.stopPropagation();
                    try {
                        await showPhotoPreviewPopup(file, photoItem);
                    } catch (err) {
                        console.error('Failed to open photo preview popup:', err);
                    }
                });
            }
            
            // Add click event listener
            photoItem.addEventListener('click', (event) => {
                // Skip if photo is already assigned or submitted
                if (photoItem.classList.contains('assigned') || photoItem.classList.contains('submitted')) {
                    return;
                }
                
                // Handle selection with shift key
                if (event.shiftKey && selectedPhotos.length > 0) {
                    const lastIndex = selectedPhotos[selectedPhotos.length - 1];
                    const currentIndex = parseInt(photoItem.dataset.index);
                    
                    // Select range
                    const start = Math.min(lastIndex, currentIndex);
                    const end = Math.max(lastIndex, currentIndex);
                    
                    for (let j = start; j <= end; j++) {
                        // Skip already assigned photos
                        const item = document.querySelector(`.photo-item[data-index="${j}"]`);
                        if (item && (item.classList.contains('assigned') || item.classList.contains('submitted'))) {
                            continue;
                        }
                        
                        if (!selectedPhotos.includes(j)) {
                            selectedPhotos.push(j);
                        }
                    }
                } 
                // Handle selection with ctrl/cmd key
                else if (event.ctrlKey || event.metaKey) {
                    const currentIndex = parseInt(photoItem.dataset.index);
                    if (selectedPhotos.includes(currentIndex)) {
                        selectedPhotos = selectedPhotos.filter(i => i !== currentIndex);
                    } else {
                        selectedPhotos.push(currentIndex);
                    }
                }
                // Normal selection
                else {
                    const currentIndex = parseInt(photoItem.dataset.index);
                    selectedPhotos = [currentIndex];
                }
                
                updatePhotoSelection();
                updateSelectedCount();
            });
            
            // Add to lazy loading observer
            if (lazyObserver) {
                lazyObserver.observe(photoItem);
            }
            
            // Append to photo grid
            photoGrid.appendChild(photoItem);
            
            window.logger.log(`New photo item created and added: ${file.name}`);
            
        } catch (error) {
            window.logger.error(`Error creating photo item for ${file.name}:`, error);
        }
    }
    
    window.logger.log('renderNewPhotosOnly completed successfully');
}

// Render photos in the grid with lazy loading and resizing
async function renderPhotos(photos, lazyObserver, isNewPhotos = false) {
    window.logger.log('renderPhotos called with', photos.length, 'photos');
    console.log('ğŸ” renderPhotos called with', photos.length, 'photos');
    
    // Clear the grid
    photoGrid.innerHTML = '';

    // If there are no photos, show reselect message if applicable
    if (photos.length === 0) {
        window.logger.log('No photos to render, showing empty state');
        // Show reselect message if we have submitted data OR defect entries (indicating previous work)
        // ä½†æ˜¯è¦é¿å…åœ¨ PNE æ–‡ä»¶è¼‰å…¥éç¨‹ä¸­é¡¯ç¤ºä¸å¿…è¦çš„ reselection è¨Šæ¯
        const isPNELoading = window.isPNELoading || false;
        const hasPhotosInStorage = window.allPhotos && window.allPhotos.length > 0;
        
        if (folderNameDisplay.textContent && folderNameDisplay.textContent !== '' && 
            (submittedData.length > 0 || window.defectEntries.length > 0) && 
            !isPNELoading && !hasPhotosInStorage) {
            showReselectMessage();
        } else {
            // Show initial empty state
            photoGrid.innerHTML = `
                <div class="empty-preview">
                    <i class="fas fa-images fa-4x"></i>
                    <p>Select a folder to preview photos</p>
                </div>
            `;
        }
        return;
    }

    // Show loading state for large batches
    let loadingDiv = null;
    if (photos.length > 50) {
        photoGrid.innerHTML = `
            <div class="empty-preview">
                <i class="fas fa-spinner fa-spin fa-3x"></i>
                <p>Loading ${photos.length} photos...</p>
                <p>Please wait while we process your images</p>
            </div>
        `;
        loadingDiv = photoGrid.querySelector('.empty-preview');
    }

    selectedPhotos = [];
    updateSelectedCount();

    // Process photos in batches to prevent browser freezing
    const batchSize = 20;
    const totalBatches = Math.ceil(photos.length / batchSize);
    
    window.logger.log(`Processing ${photos.length} photos in ${totalBatches} batches of ${batchSize}`);
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
        const startIndex = batchIndex * batchSize;
        const endIndex = Math.min(startIndex + batchSize, photos.length);
        const batchPhotos = photos.slice(startIndex, endIndex);
        
        window.logger.log(`Processing batch ${batchIndex + 1}/${totalBatches} (photos ${startIndex + 1}-${endIndex})`);
        
        // Process batch
        for (let i = 0; i < batchPhotos.length; i++) {
            const index = startIndex + i;
            const file = batchPhotos[i];
            
            try {
                window.logger.log(`Creating photo item for: ${file.name}`);
                // Check if file already has a valid dataURL, or generate one for new photos
                let resizedImageURL;
                if (file.dataURL && typeof file.dataURL === 'string' && file.dataURL.trim() !== '') {
                    resizedImageURL = file.dataURL;
                    window.logger.log(`Using existing dataURL for: ${file.name}`);
                } else if (file instanceof File) {
                    // For new uploaded photos, generate dataURL
                    window.logger.log(`Generating dataURL for new photo: ${file.name}`);
                    resizedImageURL = await resizeImage(file);
                    file.dataURL = resizedImageURL; // Save for future use
                } else {
                    window.logger.warn(`No valid dataURL for ${file.name}, cannot render photo`);
                    continue; // è·³éé€™å¼µç…§ç‰‡
                }
                
                const photoItem = document.createElement('div');
                photoItem.className = 'photo-item';
                photoItem.dataset.index = index;
                photoItem.dataset.filename = file.name;
                photoItem.setAttribute('role', 'gridcell');
                photoItem.setAttribute('aria-label', `Photo ${index + 1}`);
                // Disable native drag and drop to allow custom drag selection
                photoItem.draggable = false;
                
                // Check if this photo is already assigned to any category
                let isAssigned = false;
                for (const cat in assignedPhotos) {
                    if (assignedPhotos[cat].has(file.name)) {
                        isAssigned = true;
                        photoItem.classList.add('assigned');
                        break;
                    }
                }
                
                // Check if this photo has been submitted - prioritize submittedFilenames over labels data
                let isSubmitted = false;
                
                // First check submittedFilenames (most reliable for PNE file loaded data)
                if (submittedFilenames && submittedFilenames.has(file.name)) {
                    isSubmitted = true;
                    console.log(`ğŸ” Photo ${file.name} marked as submitted via submittedFilenames`);
                } else if (window.labels && Array.isArray(window.labels)) {
                    // Fallback to labels data if submittedFilenames doesn't have this photo
                    for (const label of window.labels) {
                        if (label.submitted && label.photoFilenames && label.photoFilenames.includes(file.name)) {
                            isSubmitted = true;
                            window.logger.log(`Photo ${file.name} marked as submitted via labels data`);
                            break;
                        }
                    }
                }
                
                if (isSubmitted) {
                    photoItem.classList.add('submitted');
                }
                
                // Extract number from filename
                const numberMatch = file.name.match(/\d+/);
                const number = numberMatch ? numberMatch[0] : 'N/A';
                
                // Add "new" icon for newly added photos
                const newIconHtml = file.isNewlyAdded ? '<div class="new-icon">new</div>' : '';
                window.logger.log(`Photo ${file.name}: isNewlyAdded=${file.isNewlyAdded}, newIconHtml=${newIconHtml ? 'added' : 'not added'}`);
                
                photoItem.innerHTML = `
                    <img src="${resizedImageURL}" alt="${file.name}">
                    <div class="photo-number">${number}</div>
                    <div class="photo-status" id="status-${index}"></div>
                    ${newIconHtml}
                `;
                
                // Disable image dragging to prevent native drag behavior
                const imgEl = photoItem.querySelector('img');
                if (imgEl) {
                    imgEl.draggable = false;
                    imgEl.style.userSelect = 'none';
                    imgEl.style.webkitUserDrag = 'none';
                }
                
                // ä¿å­˜ç›¸å°è·¯å¾‘ä»¥ä¾¿é è¦½æ™‚å˜—è©¦è®€åŸå§‹æª”
                if (file.webkitRelativePath) {
                    photoItem.dataset.webkitRelativePath = file.webkitRelativePath;
                }
                
                // é›™æ“Šç¸®åœ–é–‹å•ŸåŸå°ºå¯¸é è¦½ï¼ˆå«å‹•ç•«ï¼‰
                if (imgEl) {
                    imgEl.addEventListener('dblclick', async (e) => {
                        e.stopPropagation();
                        try {
                            await showPhotoPreviewPopup(file, photoItem);
                        } catch (err) {
                            console.error('Failed to open photo preview popup:', err);
                        }
                    });
                }
                
                // Set status text if submitted
                if (isSubmitted) {
                    const statusDiv = photoItem.querySelector('.photo-status');
                    if (statusDiv) {
                        // Find the location ID for this photo
                        let locationId = null;
                        
                        // First try to find from submittedData (if available)
                        if (submittedData && submittedData.length > 0) {
                            console.log(`ğŸ” Looking for ${file.name} in submittedData:`, submittedData.length, 'records');
                        for (const row of submittedData) {
                                console.log(`ğŸ” Checking row:`, row.locationId, 'photos:', row.photoFilenames);
                                if (row.photoFilenames && row.photoFilenames.includes(file.name)) {
                                    locationId = row.locationId;
                                    console.log(`ğŸ” Found locationId in submittedData: ${locationId}`);
                                break;
                            }
                        }
                        } else {
                            console.log(`ğŸ” submittedData is empty or null:`, submittedData);
                        }
                        
                        // If not found in submittedData, try to find from window.labels
                        if (!locationId && window.labels && Array.isArray(window.labels)) {
                            console.log(`ğŸ” Looking for ${file.name} in window.labels:`, window.labels.length, 'labels');
                            for (const label of window.labels) {
                                console.log(`ğŸ” Checking label:`, label.inspectionNo || label.locationId, 'submitted:', label.submitted, 'photos:', label.photoFilenames);
                                if (label.submitted && label.photoFilenames && label.photoFilenames.includes(file.name)) {
                                    locationId = label.inspectionNo || label.locationId;
                                    console.log(`ğŸ” Found locationId in window.labels: ${locationId}`);
                                    break;
                                }
                            }
                        } else {
                            console.log(`ğŸ” window.labels is empty or null:`, window.labels);
                        }
                        
                        if (locationId) {
                            statusDiv.textContent = `${locationId}`;
                            statusDiv.style.display = 'flex';
                            statusDiv.style.visibility = 'visible';
                            statusDiv.style.opacity = '1';
                            statusDiv.style.zIndex = '10';
                            photoItem.classList.add('submitted');
                            // ğŸ”§ å¼·åˆ¶è§¸ç™¼é‡æ’ä»¥ç¢ºä¿æ¨£å¼ç”Ÿæ•ˆ
                            void statusDiv.offsetHeight;
                            console.log(`ğŸ” Photo ${file.name} status set to: ${locationId}`);
                            console.log(`ğŸ” DOM check - statusDiv.textContent: "${statusDiv.textContent}"`);
                            console.log(`ğŸ” DOM check - statusDiv.style.display: "${statusDiv.style.display}"`);
                            console.log(`ğŸ” DOM check - statusDiv.offsetHeight: ${statusDiv.offsetHeight}`);
                        } else {
                            // Fallback: just show empty status without location ID
                            statusDiv.textContent = '';
                            statusDiv.style.display = 'flex';
                            statusDiv.style.visibility = 'visible';
                            statusDiv.style.opacity = '1';
                            statusDiv.style.zIndex = '10';
                            photoItem.classList.add('submitted');
                            console.log(`ğŸ” Photo ${file.name} status set to: Submitted (no location ID found)`);
                        }
                    }
                }
                
                // Set status text if assigned to category
                if (isAssigned) {
                    const statusDiv = photoItem.querySelector('.photo-status');
                    if (statusDiv && !isSubmitted) {
                        // Find which category this photo is assigned to
                        for (const cat in assignedPhotos) {
                            if (assignedPhotos[cat].has(file.name)) {
                                const categoryName = categories.find(catObj => catObj.id === cat)?.name || cat.toUpperCase();
                                statusDiv.textContent = `Assigned to ${categoryName}`;
                                statusDiv.style.display = 'flex';
                                statusDiv.style.zIndex = '10'; // Ensure status is above placeholder
                                break;
                            }
                        }
                    }
                }
                
                photoItem.addEventListener('click', (event) => {
                    // Skip if photo is already assigned or submitted
                    if (photoItem.classList.contains('assigned') || photoItem.classList.contains('submitted')) {
                        return;
                    }
                    
                    // Handle selection with shift key
                    if (event.shiftKey && selectedPhotos.length > 0) {
                        const lastIndex = selectedPhotos[selectedPhotos.length - 1];
                        const currentIndex = parseInt(photoItem.dataset.index);
                        
                        // Select range
                        const start = Math.min(lastIndex, currentIndex);
                        const end = Math.max(lastIndex, currentIndex);
                        
                        for (let j = start; j <= end; j++) {
                            // Skip already assigned photos
                            const item = document.querySelector(`.photo-item[data-index="${j}"]`);
                            if (item && (item.classList.contains('assigned') || item.classList.contains('submitted'))) {
                                continue;
                            }
                            
                            if (!selectedPhotos.includes(j)) {
                                selectedPhotos.push(j);
                            }
                        }
                    } 
                    // Handle selection with ctrl/cmd key
                    else if (event.ctrlKey || event.metaKey) {
                        const index = parseInt(photoItem.dataset.index);
                        if (selectedPhotos.includes(index)) {
                            selectedPhotos = selectedPhotos.filter(j => j !== index);
                        } else {
                            selectedPhotos.push(index);
                        }
                    } 
                    // Single selection
                    else {
                        selectedPhotos = [parseInt(photoItem.dataset.index)];
                    }
                    
                    // Update UI
                    updatePhotoSelection();
                    updateSelectedCount();
                });
                
                // Append to grid
                photoGrid.appendChild(photoItem);
                
                // Observe for lazy loading
                lazyObserver.observe(photoItem);
                
            } catch (error) {
                window.logger.warn(`Failed to process image: ${file.name}`, error);
                // Continue with next image instead of breaking
            }
        }
        
        // Update loading message for large batches
        if (loadingDiv && batchIndex < totalBatches - 1) {
            const progress = Math.round(((batchIndex + 1) / totalBatches) * 100);
            loadingDiv.innerHTML = `
                <i class="fas fa-spinner fa-spin fa-3x"></i>
                <p>Loading ${photos.length} photos... ${progress}%</p>
                <p>Please wait while we process your images</p>
            `;
        }
        
        // Allow browser to breathe between batches
        if (batchIndex < totalBatches - 1) {
            await new Promise(resolve => setTimeout(resolve, 10));
        }
    }
    
    // Clear loading message if it exists
    if (loadingDiv) {
        loadingDiv.remove();
    }
    
    window.logger.log('renderPhotos completed successfully');
    
    // ğŸ”§ ç…§ç‰‡ç‹€æ…‹åŒæ­¥å·²ç§»è‡³ loadDataFromStorage çš„ setTimeout ä¸­è™•ç†
    // é€™è£¡ä¸å†èª¿ç”¨ updatePhotoStatusFromInspectionRecords,é¿å…è¦†è“‹ assigned ç‹€æ…‹
    // setTimeout(() => {
    //     if (typeof updatePhotoStatusFromInspectionRecords === 'function') {
    //         updatePhotoStatusFromInspectionRecords();
    //     }
    // }, 100);
    
    // æª¢æŸ¥ä¸¦æ·»åŠ  360 åœ–æ¨™
    setTimeout(() => {
        if (typeof addAll360Badges === 'function') {
            addAll360Badges();
        }
    }, 500);
}

// Update photo selection UI
function updatePhotoSelection() {
    document.querySelectorAll('.photo-item').forEach(item => {
        const index = parseInt(item.dataset.index);
        if (selectedPhotos.includes(index)) {
            item.classList.add('selected');
        } else {
            item.classList.remove('selected');
        }
    });
    
    // Update defect photo numbers if defect window is open
    if (defectWindow && defectWindow.style.display === 'block') {
        updateDefectPhotoNumbers();
    }
}

// Photo drag selection functionality
class PhotoDragSelector {
    constructor() {
        this.isDragging = false;
        this.startPhoto = null;
        this.endPhoto = null;
        this.dragStartPosition = null;
        this.potentialStartPhoto = null;
        this.selectedPhotos = new Set();
        this.globalEventsAttached = false;
        this.dragIndicator = null;
        
        this.init();
    }
    
    init() {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.attachEventListeners());
        } else {
            this.attachEventListeners();
        }
    }
    
    attachEventListeners() {
        const photoGrid = document.getElementById('photoGrid');
        if (!photoGrid) return;
        
        // é˜²æ­¢é‡è¤‡æ·»åŠ äº‹ä»¶ç›£è½å™¨
        if (photoGrid.dataset.dragSelectorAttached) return;
        photoGrid.dataset.dragSelectorAttached = 'true';
        
        // ä½¿ç”¨äº‹ä»¶å§”è¨—åœ¨ç…§ç‰‡ç¶²æ ¼ç´šåˆ¥ç›£è½äº‹ä»¶
        photoGrid.addEventListener('mousedown', (e) => {
            const photoItem = e.target.closest('.photo-item');
            if (photoItem && photoItem.closest('#photoGrid') === photoGrid) {
                this.handleMouseDown(e, photoItem);
            }
        });
        
        photoGrid.addEventListener('mousemove', (e) => {
            // å¦‚æœå·²ç¶“åœ¨æ‹–æ‹½ä¸­ï¼Œç¹¼çºŒè™•ç†æ‹–æ‹½
            if (this.isDragging) {
                const photoItem = e.target.closest('.photo-item');
                if (photoItem && photoItem.closest('#photoGrid') === photoGrid) {
                    this.handleMouseMove(e, photoItem);
                }
            }
            // å¦‚æœé‚„æ²’æœ‰é–‹å§‹æ‹–æ‹½ï¼Œä½†è¨˜éŒ„äº† mousedown ä½ç½®ï¼Œæª¢æŸ¥æ˜¯å¦æ‡‰è©²é–‹å§‹æ‹–æ‹½
            else if (this.dragStartPosition && this.potentialStartPhoto) {
                const moveDistance = Math.sqrt(
                    Math.pow(e.clientX - this.dragStartPosition.x, 2) + 
                    Math.pow(e.clientY - this.dragStartPosition.y, 2)
                );
                // å¦‚æœç§»å‹•è·é›¢è¶…é 5 åƒç´ ï¼Œèªç‚ºæ˜¯æ‹–æ‹½è€Œä¸æ˜¯é»æ“Š
                if (moveDistance > 5) {
                    // ç«‹å³é˜»æ­¢é»˜èªè¡Œç‚ºï¼Œé˜²æ­¢ç…§ç‰‡è¢«æ‹–å‹•
                    e.preventDefault();
                    e.stopPropagation();
                    this.startDragSelection(e, this.potentialStartPhoto);
                }
            }
        });
        
        photoGrid.addEventListener('mouseup', (e) => {
            // å¦‚æœæ­£åœ¨æ‹–æ‹½ï¼Œè™•ç†æ‹–æ‹½çµæŸ
            if (this.isDragging) {
                const photoItem = e.target.closest('.photo-item');
                if (photoItem && photoItem.closest('#photoGrid') === photoGrid) {
                    this.handleMouseUp(e, photoItem);
                }
            }
            // æ¸…é™¤æ‹–æ‹½é–‹å§‹ä½ç½®ï¼Œå…è¨±æ­£å¸¸çš„é»æ“Šäº‹ä»¶è™•ç†
            this.dragStartPosition = null;
            this.potentialStartPhoto = null;
        });
        
        // é˜²æ­¢é»˜èªçš„æ–‡æœ¬é¸æ“‡è¡Œç‚º
        photoGrid.addEventListener('selectstart', (e) => {
            if (this.isDragging) {
                e.preventDefault();
            }
        });
        
        // å…¨å±€é¼ æ¨™äº‹ä»¶ï¼ˆè™•ç†è·¨ç…§ç‰‡æ‹–æ‹½ï¼‰
        if (!this.globalEventsAttached) {
            document.addEventListener('mousemove', (e) => {
                this.handleGlobalMouseMove(e);
            });
            document.addEventListener('mouseup', (e) => {
                this.handleGlobalMouseUp(e);
            });
            
            this.globalEventsAttached = true;
        }
    }
    
    handleMouseDown(e, photoItem) {
        // åªè™•ç†å·¦éµ
        if (e.button !== 0) return;
        
        // è·³éå·²åˆ†é…æˆ–å·²æäº¤çš„ç…§ç‰‡
        if (photoItem.classList.contains('assigned') || photoItem.classList.contains('submitted')) {
            return;
        }
        
        // æª¢æŸ¥æ˜¯å¦æŒ‰ä½äº† Ctrl/Cmd éµï¼ˆå¤šé¸æ¨¡å¼ï¼‰
        if (e.ctrlKey || e.metaKey) {
            return; // è®“ç¾æœ‰çš„å¤šé¸é‚è¼¯è™•ç†
        }
        
        // æª¢æŸ¥æ˜¯å¦æŒ‰ä½äº† Shift éµï¼ˆç¯„åœé¸æ“‡ï¼‰
        if (e.shiftKey) {
            return; // è®“ç¾æœ‰çš„ç¯„åœé¸æ“‡é‚è¼¯è™•ç†
        }
        
        // è¨˜éŒ„ mousedown ä½ç½®ï¼Œç”¨æ–¼å€åˆ†é»æ“Šå’Œæ‹–æ‹½
        this.dragStartPosition = {
            x: e.clientX,
            y: e.clientY
        };
        this.potentialStartPhoto = photoItem;
        
        // é˜»æ­¢é»˜èªçš„æ‹–å‹•è¡Œç‚ºï¼Œé˜²æ­¢ç…§ç‰‡è¢«æ‹–å‹•å‡ºå»
        e.preventDefault();
        
        // ä¸ç«‹å³é˜»æ­¢äº‹ä»¶å‚³æ’­ï¼Œè®“é»æ“Šäº‹ä»¶å…ˆè™•ç†
        // åªæœ‰åœ¨ mousemove æª¢æ¸¬åˆ°æ‹–æ‹½æ™‚æ‰é–‹å§‹æ‹–æ‹½é¸æ“‡
    }
    
    handleMouseMove(e, photoItem) {
        if (!this.isDragging || !this.startPhoto) return;
        
        // é˜»æ­¢é»˜èªè¡Œç‚ºï¼Œé˜²æ­¢ç…§ç‰‡è¢«æ‹–å‹•
        e.preventDefault();
        e.stopPropagation();
        
        this.endPhoto = photoItem;
        
        // æ›´æ–°é¸æ“‡ç¯„åœ
        this.updateSelectionRange();
    }
    
    handleGlobalMouseMove(e) {
        if (!this.isDragging || !this.startPhoto) return;
        
        // æ‰¾åˆ°é¼ æ¨™ä½ç½®ä¸‹çš„ç…§ç‰‡
        const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
        const photoBelow = elementBelow ? elementBelow.closest('.photo-item') : null;
        
        if (photoBelow && photoBelow.closest('#photoGrid') === document.getElementById('photoGrid')) {
            this.endPhoto = photoBelow;
            this.updateSelectionRange();
        }
    }
    
    handleMouseUp(e, photoItem) {
        if (!this.isDragging) return;
        this.finishSelection();
    }
    
    handleGlobalMouseUp(e) {
        if (this.isDragging) {
            this.finishSelection();
        }
        // æ¸…é™¤æ‹–æ‹½é–‹å§‹ä½ç½®
        this.dragStartPosition = null;
        this.potentialStartPhoto = null;
    }
    
    // é–‹å§‹æ‹–æ‹½é¸æ“‡
    startDragSelection(e, photoItem) {
        this.isDragging = true;
        this.startPhoto = photoItem;
        this.endPhoto = photoItem;
        
        // é˜»æ­¢é»˜èªè¡Œç‚º
        if (e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        // æ¸…é™¤ä¹‹å‰çš„é¸æ“‡
        this.clearSelection();
        
        // é¸æ“‡èµ·å§‹ç…§ç‰‡
        this.selectPhoto(this.startPhoto);
        
        // æ·»åŠ æ‹–æ‹½æ¨£å¼
        this.startPhoto.classList.add('drag-selecting');
        
        // é˜²æ­¢æ–‡æœ¬é¸æ“‡
        document.body.style.userSelect = 'none';
        
        // ä¸é¡¯ç¤ºæ‹–æ‹½æŒ‡ç¤ºå™¨ï¼Œåªä½¿ç”¨ç…§ç‰‡é‚Šæ¡†
        
        window.logger.log('Photo drag selection started:', this.startPhoto.dataset.filename);
    }
    
    updateSelectionRange() {
        if (!this.startPhoto || !this.endPhoto) return;
        
        // æ¸…é™¤ä¹‹å‰çš„é¸æ“‡
        this.clearSelection();
        
        // è¨ˆç®—é¸æ“‡ç¯„åœï¼ˆæŒ‰ç´¢å¼•é †åºï¼‰
        const startIndex = parseInt(this.startPhoto.dataset.index);
        const endIndex = parseInt(this.endPhoto.dataset.index);
        
        const minIndex = Math.min(startIndex, endIndex);
        const maxIndex = Math.max(startIndex, endIndex);
        
        // é¸æ“‡ç¯„åœå…§çš„æ‰€æœ‰ç…§ç‰‡
        for (let i = minIndex; i <= maxIndex; i++) {
            const photoItem = document.querySelector(`.photo-item[data-index="${i}"]`);
            if (photoItem && !photoItem.classList.contains('assigned') && !photoItem.classList.contains('submitted')) {
                this.selectPhoto(photoItem);
                
                // ç‚ºæ‹–æ‹½éç¨‹ä¸­çš„ç…§ç‰‡æ·»åŠ æ‹–æ‹½æ¨£å¼
                if (this.isDragging) {
                    photoItem.classList.add('drag-selecting');
                }
            }
        }
        
        // ä¸éœ€è¦æ›´æ–°æ‹–æ‹½æŒ‡ç¤ºå™¨
    }
    
    selectPhoto(photoItem) {
        const index = parseInt(photoItem.dataset.index);
        this.selectedPhotos.add(index);
        
        // åŒæ­¥åˆ°ç¾æœ‰çš„é¸æ“‡ç³»çµ±
        if (!selectedPhotos.includes(index)) {
            selectedPhotos.push(index);
        }
    }
    
    clearSelection() {
        this.selectedPhotos.forEach(index => {
            const photoItem = document.querySelector(`.photo-item[data-index="${index}"]`);
            if (photoItem) {
                photoItem.classList.remove('selected', 'drag-selecting');
            }
        });
        this.selectedPhotos.clear();
        
        // åŒæ­¥æ¸…é™¤ç¾æœ‰é¸æ“‡ç³»çµ±çš„é¸æ“‡
        selectedPhotos.length = 0;
    }
    
    finishSelection() {
        if (this.isDragging) {
            this.isDragging = false;
            this.startPhoto = null;
            this.endPhoto = null;
            this.dragStartPosition = null;
            
            // ç§»é™¤æ‹–æ‹½æ¨£å¼
            const dragPhotos = document.querySelectorAll('.photo-item.drag-selecting');
            dragPhotos.forEach(photo => photo.classList.remove('drag-selecting'));
            
            // ä¸éœ€è¦ç§»é™¤æ‹–æ‹½æŒ‡ç¤ºå™¨
            
            // æ¢å¾©æ–‡æœ¬é¸æ“‡
            document.body.style.userSelect = '';
            
            // æ›´æ–°é¸æ“‡UI
            updatePhotoSelection();
            updateSelectedCount();
            
            window.logger.log('Photo drag selection finished, selected:', this.selectedPhotos.size, 'photos');
        }
    }
    
    // æ‹–æ‹½åé¥‹æ–¹æ³•å·²ç§»é™¤ï¼Œåªä½¿ç”¨ç…§ç‰‡é‚Šæ¡†é¡¯ç¤ºé¸æ“‡ç‹€æ…‹
}

// å‰µå»ºå…¨å±€å¯¦ä¾‹
window.photoDragSelector = new PhotoDragSelector();

// Update selected photo count
function updateSelectedCount() {
    selectedCount.textContent = selectedPhotos.length;
}

// æª¢æŸ¥æª¢æŸ¥ç·¨è™Ÿæ˜¯å¦å·²å¡«å¯«
function validateInspectionNumber() {
    const locationIdInput = document.getElementById('locationId');
    const inspectionNo = locationIdInput ? locationIdInput.value.trim() : '';
    
    if (!inspectionNo) {
        showNotification(getText('pleaseEnterInspectionNumber') || 'Please enter Inspection No. in header fields before assigning photos', 'warning');
        
        // é«˜äº®é¡¯ç¤ºæª¢æŸ¥ç·¨è™Ÿè¼¸å…¥æ¡†
        if (locationIdInput) {
            locationIdInput.focus();
            locationIdInput.style.border = '2px solid #ff6b6b';
            setTimeout(() => {
                locationIdInput.style.border = '';
            }, 2000);
        }
        
        return false;
    }
    
    return true;
}

// Assign selected photos to a category
function assignToCategory(categoryId) {
    if (selectedPhotos.length === 0) {
        showNotification('Please select photos first', 'warning');
        return;
    }
    
    // æª¢æŸ¥æª¢æŸ¥ç·¨è™Ÿæ˜¯å¦å·²å¡«å¯«
    if (!validateInspectionNumber()) {
        return;
    }
    
    let addedCount = 0;
    
    selectedPhotos.forEach(index => {
        // Check if index is valid and file exists
        if (!allPhotos || index >= allPhotos.length || !allPhotos[index]) {
            window.logger.warn(`Invalid photo index: ${index}, allPhotos length: ${allPhotos ? allPhotos.length : 0}`);
            return; // Skip this photo
        }
        
        const file = allPhotos[index];
        if (!file || !file.name) {
            window.logger.warn(`Invalid file at index ${index}:`, file);
            return; // Skip this photo
        }
        
        const fileName = file.name;
        
        // Extract numbers from filename
        const numberMatch = fileName.match(/\d+/);
        
        if (numberMatch) {
            const number = numberMatch[0];
            if (!categoryNumbers[categoryId].includes(number)) {
                categoryNumbers[categoryId].push(number);
                assignedPhotos[categoryId].add(fileName);
                addedCount++;
                
                // Mark photo as assigned
                const photoItem = document.querySelector(`.photo-item[data-index="${index}"]`);
                if (photoItem) {
                    photoItem.classList.add('assigned');
                    photoItem.querySelector('img').style.filter = 'grayscale(100%)';
                    photoItem.querySelector('img').style.opacity = '0.3';
                    
                    // Update photo number display
                    const photoNumberDiv = photoItem.querySelector('.photo-number');
                    if (photoNumberDiv) {
                        photoNumberDiv.textContent = number;
                    }
                }
            }
        }
    });
    
    if (addedCount > 0) {
        updateCategoryDisplay(categoryId);
        showNotification(`Added ${addedCount} numbers to category ${categoryId.toUpperCase()}`, 'success');
        
        // Clear selection after assignment
        selectedPhotos = [];
        updatePhotoSelection();
        updateSelectedCount();
    } else {
        showNotification('No new numbers added to this category', 'info');
    }
}

// Format defect photo numbers for display in detail tables
function formatDefectPhotoNumbers(photoNumbers) {
    if (!photoNumbers || photoNumbers === 'N/A') {
        return 'N/A';
    }
    
    // Split by comma and filter empty items
    const items = photoNumbers.split(',').map(item => item.trim()).filter(item => item);
    if (items.length === 0) {
        return 'N/A';
    }
    
    // Create photo number items with CSS class for styling
    return items.map(item => {
        return `<div class="defect-item">${item}</div>`;
    }).join('');
}

// Format defect category for display in detail tables
function formatDefectCategory(category) {
    if (!category || category === 'N/A') {
        return 'N/A';
    }
    
    return `<div class="defect-item">${category}</div>`;
}

// Format defect type for display in detail tables
function formatDefectType(defectType) {
    if (!defectType || defectType === 'N/A') {
        return 'N/A';
    }
    
    return `<div class="defect-item">${defectType}</div>`;
}

// Format label items for display in detail tables
function formatLabelItems(labelValue) {
    if (!labelValue || labelValue === 'N/A') {
        return 'N/A';
    }
    
    // Split by comma and filter empty items
    const items = labelValue.split(',').map(item => item.trim()).filter(item => item);
    if (items.length === 0) {
        return 'N/A';
    }
    
    // Create label items with CSS class for styling
    return items.map(item => {
        return `<div class="label-item">${item}</div>`;
    }).join('');
}

// Format numbers into ranges with improved formatting
function formatNumbers(numbers) {
    if (numbers.length === 0) return "";
    
    // Convert to numbers for sorting but keep original strings
    const sorted = [...numbers].sort((a, b) => parseInt(a) - parseInt(b));
    
    let result = [];
    let start = sorted[0];
    let end = start;
    
    for (let i = 1; i < sorted.length; i++) {
        const current = sorted[i];
        const prev = sorted[i-1];
        
        // Check if consecutive
        if (parseInt(current) === parseInt(end) + 1) {
            end = current;
        } else {
            if (start === end) {
                result.push(start);
            } else {
                result.push(`${start}-${end}`);
            }
            start = current;
            end = current;
        }
    }
    
    // Add the last range
    if (start === end) {
        result.push(start);
    } else {
        result.push(`${start}-${end}`);
    }
    
    return result.join(', ');
}

// Format date as "13 May 2025"
function formatDateDisplay(dateString) {
    if (!dateString) return "";
    
    const date = new Date(dateString);
    if (isNaN(date)) return "";
    
    const day = date.getDate();
    const monthNames = [
        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    ];
    const month = monthNames[date.getMonth()];
    const year = date.getFullYear();
    
    return `${day}-${month}-${year}`;
}

// Format date as "13 May 2025" for folder names
function formatFolderDate(dateString) {
    if (!dateString) return "";
    
    const date = new Date(dateString);
    if (isNaN(date)) return "";
    
    const day = date.getDate();
    const monthNames = [
        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    ];
    const month = monthNames[date.getMonth()];
    const year = date.getFullYear();
    
    return `${day}-${month}-${year}`;
}

// Update the display for a category
function updateCategoryDisplay(categoryId) {
    const contentDiv = document.getElementById(`result-${categoryId}`);
    const countBadge = document.getElementById(`count-${categoryId}`);
    const clearBtn = document.querySelector(`.clear-category-btn[data-category="${categoryId}"]`);
    
    // For defects category (J), use different formatting
    if (categoryId === 'j') {
        contentDiv.innerHTML = '';
        
        // é¡¯ç¤ºç¼ºé™·é¡åˆ¥å…§å®¹ï¼ˆå¾ç¼ºé™·è¡¨å–®è¤‡è£½çš„æ•¸æ“šï¼‰ï¼Œè€Œä¸æ˜¯æ‰€æœ‰ç¼ºé™·è©³ç´°è¡¨æ ¼å®¹å™¨çš„è¨˜éŒ„
        if (categoryNumbers.j.length > 0) {
            categoryNumbers.j.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'defect-entry';
                entryDiv.textContent = entry;
                contentDiv.appendChild(entryDiv);
            });
        } else {
            contentDiv.innerHTML = '<div class="empty-state">No defects in category</div>';
        }
        
        // æ›´æ–°è¨ˆæ•¸
        if (countBadge) {
            countBadge.textContent = categoryNumbers.j.length;
        }
        
        return; // æå‰è¿”å›ï¼Œä¸åŸ·è¡Œå¾ŒçºŒçš„ç¼ºé™·è©³ç´°è¡¨æ ¼é‚è¼¯
    }
    
    // For other categories
    contentDiv.textContent = formatNumbers(categoryNumbers[categoryId]);
    countBadge.textContent = categoryNumbers[categoryId].length;
    // Show/hide clear button based on whether category has content
    if (categoryId === 'j' ? categoryNumbers.j.length > 0 : categoryNumbers[categoryId].length > 0) {
        clearBtn.classList.add('visible');
    } else {
        clearBtn.classList.remove('visible');
    }
}

// Clear a specific category - MODIFIED to preserve numbers with defect entries
function clearCategory(categoryId, silent = false) {
    if (categoryId === 'j') {
        // For defects category, clear categoryNumbers.j (defect category content)
        if (categoryNumbers.j.length === 0) {
            if (!silent) {
                showNotification(`Category ${categoryId.toUpperCase()} is already empty`, 'info');
            }
            return;
        }
        
        // If in silent mode (called from selectPhotoFolder), don't clear existing defect category content
        if (silent) {
            window.logger.log('Silent mode: Preserving existing defect category content during photo operations');
            return;
        }
        
        // Clear defect category content (but keep defect entries in detail table)
        categoryNumbers.j = [];
        
        // Remove assigned class from photos
        for (const filename of assignedPhotos[categoryId]) {
            const photoItems = document.querySelectorAll('.photo-item');
            for (const item of photoItems) {
                if (item.dataset.filename === filename) {
                    item.classList.remove('assigned');
                    const img = item.querySelector('img');
                    if (img) {
                        img.style.filter = '';
                        img.style.opacity = '';
                    }
                    
                    // Always show photo number (extracted from filename)
                    const photoNumberDiv = item.querySelector('.photo-number');
                    if (photoNumberDiv) {
                        const filename = item.dataset.filename;
                        const numberMatch = filename.match(/\d+/);
                        const number = numberMatch ? numberMatch[0] : '';
                        photoNumberDiv.textContent = number;
                    }
                }
            }
        }
        
        // Clear assigned photos
        assignedPhotos[categoryId] = new Set();
        
        // Update category display
        updateCategoryDisplay(categoryId);
        
        showNotification(`Category ${categoryId.toUpperCase()} cleared`, 'success');
    } else {
        // For non-defects categories
        if (categoryNumbers[categoryId].length === 0) {
            if (!silent) {
                showNotification(`Category ${categoryId.toUpperCase()} is already empty`, 'info');
            }
            return;
        }

        // Find numbers to preserve (those with defect entries)
        const preservedNumbers = new Set();
        window.defectEntries.forEach(entry => {
            if (entry.category === categoryId) {
                entry.numbers.forEach(num => {
                    // Convert to integer for comparison
                    const numInt = parseInt(num, 10);
                    if (!isNaN(numInt)) {
                        preservedNumbers.add(numInt);
                    }
                });
            }
        });

        // Filter out numbers without defect entries
        const keptNumbers = [];
        const removedNumbers = [];
        categoryNumbers[categoryId].forEach(numStr => {
            const numInt = parseInt(numStr, 10);
            if (!isNaN(numInt) && preservedNumbers.has(numInt)) {
                keptNumbers.push(numStr);
            } else {
                removedNumbers.push(numStr);
            }
        });

        // Update category numbers
        categoryNumbers[categoryId] = keptNumbers;

        // Update assigned photos
        const newAssignedPhotos = new Set();
        for (const filename of assignedPhotos[categoryId]) {
            const numberMatch = filename.match(/\d+/);
            if (numberMatch) {
                const numStr = numberMatch[0];
                const numInt = parseInt(numStr, 10);
                if (preservedNumbers.has(numInt)) {
                    newAssignedPhotos.add(filename);
                }
            }
        }
        assignedPhotos[categoryId] = newAssignedPhotos;

        // Update photo grid for removed numbers
        removedNumbers.forEach(number => {
            // Find photos with this number
            allPhotos.forEach((file, index) => {
                const fileNumber = file.name.match(/\d+/);
                if (fileNumber && fileNumber[0] === number) {
                    const photoItem = document.querySelector(`.photo-item[data-index="${index}"]`);
                    if (photoItem) {
                        // Only remove assignment if not in defects category
                        if (!assignedPhotos.j.has(file.name)) {
                            photoItem.classList.remove('assigned');
                            const img = photoItem.querySelector('img');
                            if (img) {
                                img.style.filter = '';
                                img.style.opacity = '';
                            }
                            
                            // Always show photo number (extracted from filename)
                            const photoNumberDiv = photoItem.querySelector('.photo-number');
                            if (photoNumberDiv) {
                                const filename = photoItem.dataset.filename;
                                const numberMatch = filename.match(/\d+/);
                                const number = numberMatch ? numberMatch[0] : '';
                                photoNumberDiv.textContent = number;
                            }
                        }
                    }
                }
            });
        });

        updateCategoryDisplay(categoryId);
        showNotification(`Category ${categoryId.toUpperCase()} cleared`, 'success');
    }
}

// Clear a specific defect entry
function clearDefectEntry(entryId) {
    window.logger.log('clearDefectEntry called with ID:', entryId);
    window.logger.log('Current defectEntries:', window.defectEntries);
    const entryIndex = window.defectEntries.findIndex(entry => entry.id === entryId);
    if (entryIndex === -1) {
        window.logger.log('Entry not found in defectEntries');
        return;
    }
    
    const entry = window.defectEntries[entryIndex];
    
    // CALL DATA RENEWAL SYSTEM FOR DEFECT DELETION
    // Find the inspection record that contains this defect
    const inspectionRecord = submittedData.find(record => record.locationId === entry.locationId);
    if (inspectionRecord) {
        // Get photo filenames for this defect
        const defectPhotoFilenames = [];
        if (entry.numbers && entry.numbers.length > 0) {
            entry.numbers.forEach(number => {
                allPhotos.forEach(file => {
                    const fileName = file.name;
                    const numberMatch = fileName.match(/\d+/);
                    if (numberMatch && numberMatch[0] === number) {
                        defectPhotoFilenames.push(fileName);
                    }
                });
            });
        }
        
        window.logger.log('Clearing defect entry - photo filenames:', defectPhotoFilenames);
        
        // Remove photos from inspection record
        defectPhotoFilenames.forEach(filename => {
            const index = inspectionRecord.photoFilenames.indexOf(filename);
            if (index > -1) {
                inspectionRecord.photoFilenames.splice(index, 1);
                window.logger.log(`Removed ${filename} from inspection record ${entry.locationId} due to defect deletion`);
            }
        });
        
        // Update folder name
        updateInspectionRecordFolderName(inspectionRecord);
        
        // Update photoFolders
        const folderIndex = photoFolders.findIndex(folder => folder.locationId === entry.locationId);
        if (folderIndex !== -1) {
            defectPhotoFilenames.forEach(filename => {
                const photoIndex = photoFolders[folderIndex].photos.indexOf(filename);
                if (photoIndex > -1) {
                    photoFolders[folderIndex].photos.splice(photoIndex, 1);
                }
            });
            
            // Remove folder if empty
            if (photoFolders[folderIndex].photos.length === 0) {
                photoFolders.splice(folderIndex, 1);
                window.logger.log(`Removed empty folder for ${entry.locationId}`);
            }
        }
        
        // Update photo status in UI
        defectPhotoFilenames.forEach(filename => {
            const photoItems = document.querySelectorAll('.photo-item');
            for (const item of photoItems) {
                if (item.dataset.filename === filename) {
                    const statusDiv = item.querySelector('.photo-status');
                    if (statusDiv) {
                        statusDiv.textContent = '';
                    }
                    // Remove submitted class if no longer in any record
                    const stillInUse = submittedData.some(record => 
                        record.photoFilenames.includes(filename) && record.locationId !== entry.locationId
                    );
                    if (!stillInUse) {
                        item.classList.remove('submitted');
                        submittedFilenames.delete(filename);
                    }
                }
            }
        });
    }
    
    // Release the photo assignments for this defect
    entry.numbers.forEach(number => {
        const numInt = parseInt(number, 10);
        if (isNaN(numInt)) return;
        
        // Find filenames matching this number
        allPhotos.forEach(file => {
            const fileName = file.name;
            const numberMatch = fileName.match(/\d+/);
            if (numberMatch) {
                const fileNumInt = parseInt(numberMatch[0], 10);
                if (fileNumInt === numInt) {
                    // Remove from assigned photos for defects category
                    assignedPhotos.j.delete(fileName);
                    
                    // Also remove from the linked category if exists
                    if (entry.category && entry.category !== 'j') {
                        assignedPhotos[entry.category].delete(fileName);
                        
                        // Remove from category numbers
                        const index = categoryNumbers[entry.category].indexOf(numberMatch[0]);
                        if (index !== -1) {
                            categoryNumbers[entry.category].splice(index, 1);
                        }
                    }
                }
            }
        });
    });
    
    // Remove the entry from both arrays
    window.defectEntries.splice(entryIndex, 1);
    
    // Also remove from submittedDefectEntries if it exists
    const submittedEntryIndex = window.submittedDefectEntries.findIndex(e => String(e.id) === String(entryId));
    if (submittedEntryIndex !== -1) {
        window.submittedDefectEntries.splice(submittedEntryIndex, 1);
    }
    
    // Remove from Inspection Records if it exists
    if (entry.locationId) {
        const inspectionRecord = submittedData.find(row => row.locationId === entry.locationId);
        if (inspectionRecord && inspectionRecord.j && inspectionRecord.j !== 'N/A') {
            const defectStr = `${entry.range}_${entry.description}`;
            const existingDefects = inspectionRecord.j.split('\n');
            const oldDefectPattern = `${entry.range}_${entry.description}`;
            const filteredDefects = existingDefects.filter(defect => {
                const cleanDefect = defect.trim().replace(/^\* /, ''); // Remove asterisk prefix
                return cleanDefect !== oldDefectPattern;
            });
            inspectionRecord.j = filteredDefects.length > 0 ? filteredDefects.join('\n') : 'N/A';
            
            // Update the inspection record's row
            const rowElement = document.querySelector(`tr[data-id="${inspectionRecord.id}"]`);
            if (rowElement) {
                if (rowElement.children.length > 13 && rowElement.children[13]) {
                    rowElement.children[13].textContent = inspectionRecord.j;
                }
                // Check if there are any remaining imminent danger defects
                const hasRemainingImminentDanger = filteredDefects.some(defect => defect.trim().startsWith('* '));
                inspectionRecord.hasImminentDanger = hasRemainingImminentDanger;
                if (rowElement.children.length > 14 && rowElement.children[14]) {
                    rowElement.children[14].textContent = hasRemainingImminentDanger ? 'Yes' : 'No';
                }
            }
        }
    }
    
    // Update displays
    updateCategoryDisplay('j');
    // Update defect summary table to reflect the deletion
    if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
    if (entry.category && entry.category !== 'j') {
        updateCategoryDisplay(entry.category);
    }
    
    // Update photo grid status
    updatePhotoGridAfterDefectRemoval();
    
    // Validate data integrity after deletion
    validateDataIntegrity();
    
    showNotification(`Defect entry cleared${entry.category && entry.category !== 'j' ? ' and linked numbers removed from category ' + entry.category.toUpperCase() : ''}`, 'success');
}

// Update photo grid after defect removal
function updatePhotoGridAfterDefectRemoval() {
    document.querySelectorAll('.photo-item').forEach(item => {
        const filename = item.dataset.filename;
        let isAssigned = false;
        let assignedNumber = null;
        
        // Check if still assigned to any category and get the assigned number
        for (const cat in assignedPhotos) {
            if (assignedPhotos[cat].has(filename)) {
                isAssigned = true;
                // Find the number assigned to this photo
                if (cat === 'j') {
                    // For defects category, find the defect entry that uses this photo
                    for (const entry of defectEntries) {
                        if (entry.numbers && entry.numbers.length > 0) {
                            const numberMatch = filename.match(/\d+/);
                            if (numberMatch && entry.numbers.includes(numberMatch[0])) {
                                assignedNumber = numberMatch[0];
                                break;
                            }
                        }
                    }
                } else {
                    // For other categories, find the number in categoryNumbers
                    const numberMatch = filename.match(/\d+/);
                    if (numberMatch && categoryNumbers[cat].includes(numberMatch[0])) {
                        assignedNumber = numberMatch[0];
                    }
                }
                break;
            }
        }
        
        if (isAssigned) {
            item.classList.add('assigned');
            const img = item.querySelector('img');
            if (img) {
                img.style.filter = 'grayscale(100%)';
                img.style.opacity = '0.3';
            }
            
            // Update photo number display
            const photoNumberDiv = item.querySelector('.photo-number');
            if (photoNumberDiv) {
                photoNumberDiv.textContent = assignedNumber || '';
            }
        } else {
            item.classList.remove('assigned');
            const img = item.querySelector('img');
            if (img) {
                img.style.filter = '';
                img.style.opacity = '';
            }
            
            // Always show photo number (extracted from filename)
            const photoNumberDiv = item.querySelector('.photo-number');
            if (photoNumberDiv) {
                const numberMatch = filename.match(/\d+/);
                const number = numberMatch ? numberMatch[0] : '';
                photoNumberDiv.textContent = number;
            }
        }
        
        // Remove status if no longer submitted
        if (!submittedFilenames.has(filename)) {
            item.classList.remove('submitted');
            const statusDiv = item.querySelector('.photo-status');
            if (statusDiv) {
                statusDiv.textContent = '';
            }
        }
    });
}

// Clear all categories function
function clearAllCategories() {
    // Check if any category has data
    const hasData = Object.values(categoryNumbers).some(numbers => numbers.length > 0) || window.defectEntries.length > 0;
    
    if (!hasData) {
        showNotification('All categories are already empty', 'info');
        return;
    }
    
    // Clear all category numbers
    categories.forEach(category => {
        categoryNumbers[category.id] = [];
    });
    
    // Clear all assigned photos
    categories.forEach(category => {
        assignedPhotos[category.id] = new Set();
    });
    
    // Clear defect entries
    window.defectEntries.length = 0;
    
    // Remove assigned class from all photos
    document.querySelectorAll('.photo-item').forEach(item => {
        // Only remove assigned class, keep submitted class
        if (item.classList.contains('assigned') && !item.classList.contains('submitted')) {
            item.classList.remove('assigned');
            const img = item.querySelector('img');
            if (img) {
                img.style.filter = '';
                img.style.opacity = '';
            }
            
            // Always show photo number (extracted from filename)
            const photoNumberDiv = item.querySelector('.photo-number');
            if (photoNumberDiv) {
                const filename = item.dataset.filename;
                const numberMatch = filename.match(/\d+/);
                const number = numberMatch ? numberMatch[0] : '';
                photoNumberDiv.textContent = number;
            }
        }
    });
    
    // Update all category displays
    categories.forEach(category => {
        updateCategoryDisplay(category.id);
    });
    
    // Update defect summary table
    if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
    
    // Clear selected photos
    selectedPhotos = [];
    updatePhotoSelection();
    updateSelectedCount();
    
    showNotification('All categories cleared successfully', 'success');
}

// Reset header-fields checkboxes to unchecked state
function resetHeaderCheckboxes() {
    const checkboxes = [
        'locationIdCheck',
        'inspectionDateCheck', 
        'floorHeaderCheck',
        'areaNameHeaderCheck',
        'roomNoCheck'
    ];
    
    // Reset all checkboxes to unchecked
    checkboxes.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox) {
            checkbox.checked = false;
        }
    });
    
    // Clear only room number input value (preserve inspection date, floor, and area name)
    // Note: inspection date, floor, and area name are preserved for next entry
    
    // Disable submit button after resetting checkboxes
    if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.style.opacity = '0.5';
        submitBtn.style.cursor = 'not-allowed';
    }
    
    window.logger.log('Header checkboxes and fields reset to initial state');
}

// æ–°å¢å‡½æ•¸ï¼šæ¸…é™¤æ‰€æœ‰ header fieldsï¼ˆåªåœ¨ç¹ªåœ–æ¨¡å¼ä¸‹ä½¿ç”¨ï¼‰
function clearAllHeaderFields() {
    const headerFields = [
        'locationId',
        'inspectionDate',
        'floorHeader', 
        'areaNameHeader',
        'roomNo'
    ];
    
    // æ¸…é™¤æ‰€æœ‰ header fields çš„å€¼
    headerFields.forEach(id => {
        const field = document.getElementById(id);
        if (field) {
            field.value = '';
        }
    });
    
    // é‡ç½®æ‰€æœ‰ checkboxes
    resetHeaderCheckboxes();
    
    window.logger.log('All header fields cleared (drawing mode)');
}

// Header checkbox validation function
function checkHeaderCheckboxes() {
    const checkboxes = [
        'locationIdCheck',
        'inspectionDateCheck', 
        'floorHeaderCheck',
        'areaNameHeaderCheck',
        'roomNoCheck'
    ];
    
    const allChecked = checkboxes.every(id => {
        const checkbox = document.getElementById(id);
        return checkbox && checkbox.checked;
    });
    
    // Enable/disable submit button based on checkbox state
    if (submitBtn) {
        submitBtn.disabled = !allChecked;
        submitBtn.style.opacity = allChecked ? '1' : '0.5';
        submitBtn.style.cursor = allChecked ? 'pointer' : 'not-allowed';
    }
    
    return allChecked;
}

// Initialize header checkboxes
function initHeaderCheckboxes() {
    const checkboxes = [
        'locationIdCheck',
        'inspectionDateCheck', 
        'floorHeaderCheck',
        'areaNameHeaderCheck',
        'roomNoCheck'
    ];
    
    checkboxes.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox) {
            checkbox.addEventListener('change', checkHeaderCheckboxes);
        }
    });
    
    // Initial check and disable submit button
    checkHeaderCheckboxes();
    
    // Ensure submit button is initially disabled
    if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.style.opacity = '0.5';
        submitBtn.style.cursor = 'not-allowed';
    }
}

// Add photos functionality
let addPhotosBtn = null;
let addPhotosFileInput = null;

// Show/hide Add photos button - always show to allow adding more photos
function updateAddPhotosButtonVisibility() {
    // Get the button element each time to ensure it exists
    addPhotosBtn = document.getElementById('addPhotosBtn');
    if (addPhotosBtn) {
        addPhotosBtn.style.display = 'inline-block';
        window.logger.log('Add photos button is now visible');
    } else {
        window.logger.log('Add photos button not found');
    }
}

// Add photos button click handler - moved to DOMContentLoaded

// Submit data to table
submitBtn.addEventListener('click', () => {
    // æª¢æŸ¥æ˜¯å¦ç‚ºç·¨è¼¯æ¨¡å¼ï¼ˆå¾ Add More Photos é€²å…¥ï¼‰
    const isEditMode = window.currentEditingLabel && window.currentEditingLabel.isEditMode;
    
    if (isEditMode) {
        console.log('ğŸ“ Edit mode detected, will merge data with existing label');
    }
    
    // Check if all header checkboxes are checked
    if (!checkHeaderCheckboxes()) {
        showNotification('Please check all header fields before submitting', 'error');
        return;
    }
    
    // Get location and date values
    const locationId = locationIdInput.value.trim();
    const inspectionDate = inspectionDateInput.value;
    const roomNo = roomNoInput.value.trim();
    // æ–°å¢ï¼šå–å¾— header çš„ Floor èˆ‡ Area Name
    const floor = document.getElementById('floorHeader').value.trim();
    const areaName = document.getElementById('areaNameHeader').value.trim();
    
    // Validate location ID
    if (!locationId) {
        showNotification('Please enter a location ID', 'error');
        locationIdInput.focus();
        return;
    }
    
    // Check for duplicate inspection number (skip if from label assignment)
    if (checkInspectionNoDuplicate(locationId, -1, isHeaderFromLabelAssignment)) {
        showNotification('This Inspection No. already exists in the labels detail table. Please use a different number.', 'error');
        locationIdInput.focus();
        return;
    }
    
    // Validate inspection date
    if (!inspectionDate) {
        showNotification('Please select an inspection date', 'error');
        inspectionDateInput.focus();
        return;
    }
    
    // Format date as "13 May 2025"
    const formattedDate = formatDateDisplay(inspectionDate);
    const folderDate = formatFolderDate(inspectionDate);
    
    // Check if any category has data
    const hasData = Object.values(categoryNumbers).some(numbers => numbers.length > 0) || window.defectEntries.length > 0;
    
    if (!hasData) {
        showNotification('No data to submit!', 'warning');
        return;
    }
    
    // Check for imminent danger in defect entries
    const hasImminentDanger = window.defectEntries.some(entry => entry.imminentDanger);
    
    // Get all assigned photo filenames (across all categories)
    const allAssignedFilenames = new Set();
    Object.values(assignedPhotos).forEach(filenames => {
        filenames.forEach(filename => allAssignedFilenames.add(filename));
    });
    
    // Get the photo numbers for folder naming
    const photoNumbers = [];
    for (const filename of allAssignedFilenames) {
        const numberMatch = filename.match(/\d+/);
        if (numberMatch) {
            photoNumbers.push(parseInt(numberMatch[0]));
        }
    }
    
    // Calculate min and max photo numbers
    let minNumber = Math.min(...photoNumbers);
    let maxNumber = Math.max(...photoNumbers);
    
    // Create folder structure if sorting is enabled
    let folderName = '';
    // æª¢æŸ¥æ˜¯å¦å•Ÿç”¨æ’åºï¼ˆå¾å°å‡ºè¨­ç½®é é¢ç²å–ï¼Œé»˜èªå•Ÿç”¨ï¼‰
    const sortPhotosToFolder = document.getElementById('sortPhotosToFolder') ? 
        document.getElementById('sortPhotosToFolder').checked : true;
    
    if (sortPhotosToFolder && allAssignedFilenames.size > 0) {
        folderName = `${locationId}_${folderDate} (${minNumber}-${maxNumber})`;
        
        // Store folder data for export
        photoFolders.push({
            name: folderName,
            photos: Array.from(allAssignedFilenames),
            locationId: locationId
        });
        
        showNotification(`Folder created: ${folderName}`, 'info');
    }
    
    // Mark photos as submitted
    for (const filename of allAssignedFilenames) {
        submittedFilenames.add(filename);
        
        const photoItems = document.querySelectorAll('.photo-item');
        for (const item of photoItems) {
            if (item.dataset.filename === filename) {
                item.classList.add('submitted');
                
                // Remove "new" icon if it exists
                const newIcon = item.querySelector('.new-icon');
                if (newIcon) {
                    newIcon.remove();
                }
                
                // Clear the isNewlyAdded flag from the photo object
                const photoObject = allPhotos.find(photo => photo.name === filename);
                if (photoObject) {
                    photoObject.isNewlyAdded = false;
                }
                item.querySelector('img').style.filter = 'grayscale(100%)';
                item.querySelector('img').style.opacity = '0.3';
                // Add location ID to the photo status
                const statusDiv = item.querySelector('.photo-status');
                if (statusDiv) {
                    statusDiv.textContent = locationId;
                }
            }
        }
    }
    
    // Get formatted data from all categories
    const rowData = {
        id: rowIdCounter++,
        locationId: locationId,
        inspectionDate: formattedDate,
        inspectionDateRaw: inspectionDate, // Store raw date
        floor: floor, // <-- æ–°å¢
        areaName: areaName, // <-- æ–°å¢
        roomNo: roomNo,
        a: formatNumbers(categoryNumbers.a),
        b: formatNumbers(categoryNumbers.b),
        c: formatNumbers(categoryNumbers.c),
        d: formatNumbers(categoryNumbers.d),
        e: formatNumbers(categoryNumbers.e),
        f: formatNumbers(categoryNumbers.f),
        g: formatNumbers(categoryNumbers.g),
        h: formatNumbers(categoryNumbers.h),
        i: formatNumbers(categoryNumbers.i),
        // Use category content data instead of all defect entries
        j: categoryNumbers.j.join('\n'),
        photoFilenames: Array.from(allAssignedFilenames),
        folderName: folderName,
        hasImminentDanger: hasImminentDanger
    };
    
    // å°‡æ•¸æ“šæäº¤åˆ°æ¨™ç±¤è©³ç´°è¡¨æ ¼è€Œä¸æ˜¯æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼
    submitToLabelsDetailTable(rowData);
    
    // ä¸å†æ·»åŠ åˆ°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼
    // submittedData.push(rowData);
    // addTableRow(rowData);
    
    // Clear all categories including defects
    categories.forEach(category => {
        // Remove assigned class from photos (but keep submitted)
        for (const filename of assignedPhotos[category.id]) {
            const photoItems = document.querySelectorAll('.photo-item');
            for (const item of photoItems) {
                if (item.dataset.filename === filename) {
                    item.classList.remove('assigned');
                }
            }
        }
        
        // Clear category data
        categoryNumbers[category.id] = [];
        assignedPhotos[category.id] = new Set();
        
        updateCategoryDisplay(category.id);
    });
    
    // ä¸æ¸…é™¤ç¼ºé™·æ¢ç›®ï¼Œä¿æŒç¼ºé™·è©³ç´°è¡¨æ ¼çš„æ•¸æ“š
    // window.defectEntries.length = 0;
    // submittedDefectEntries.length = 0;
    
    // ä¸æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼ï¼Œä¿æŒç¾æœ‰æ•¸æ“š
    // if (typeof window.updateDefectSummaryTable === 'function') {
    //     window.updateDefectSummaryTable();
    // }
    
    // Note: updateDefectSummaryTable() is not called here as per requirement
    // Submit button only affects inspection records table, not defect summary table
    
    // Clear location ID for next entry
    locationIdInput.value = '';
    // Clear room number for next entry
    roomNoInput.value = '';
    
    // æª¢æŸ¥æ˜¯å¦åœ¨ç¹ªåœ–æ¨¡å¼ä¸‹ï¼Œå¦‚æœæ˜¯å‰‡æ¸…é™¤æ‰€æœ‰ header fields
    const floorPlanOverlay = document.getElementById('floorPlanOverlay');
    const isDrawingMode = floorPlanOverlay && floorPlanOverlay.style.display === 'flex';
    
    if (isDrawingMode) {
        // ç¹ªåœ–æ¨¡å¼ï¼šæ¸…é™¤æ‰€æœ‰ header fields
        clearAllHeaderFields();
        window.logger.log('Drawing mode detected - all header fields cleared');
    } else {
        // éç¹ªåœ–æ¨¡å¼ï¼šåªé‡ç½® checkboxesï¼ˆä¿æŒç¾æœ‰è¡Œç‚ºï¼‰
        resetHeaderCheckboxes();
        window.logger.log('Non-drawing mode - only checkboxes reset');
    }
    
    // ä¸å†æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼è¨ˆæ•¸ï¼Œåªæ›´æ–°æ–‡ä»¶å¤¾é¡¯ç¤º
    // updateTableCount(); // ç§»é™¤æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼è¨ˆæ•¸æ›´æ–°
    updateFolderDisplay();
    
    // Save data to localStorage
    saveDataToStorage();
    
    // é‡ç½® skipDefectMarksLoad æ¨™èªŒï¼Œå…è¨±ç¼ºé™·æ¨™è¨˜æ­£å¸¸è¼‰å…¥
    window.skipDefectMarksLoad = false;
    window.logger.log('Submit completed: Reset skipDefectMarksLoad flag to allow defect marks loading');
    
    // æ¸…é™¤ç·¨è¼¯æ¨¡å¼æ¨™è¨˜
    if (isEditMode) {
        window.currentEditingLabel = null;
        console.log('âœ… Edit mode cleared');
        showNotification('Data merged with existing label successfully!', 'success');
    } else {
        showNotification('Data submitted to labels detail table!', 'success');
    }
    
    // ä¸å†æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼ï¼Œåªæ›´æ–°åˆ†é¡è¡¨æ ¼
    setTimeout(updateCategoryTablesFromInspectionRecords, 100);
});

// æäº¤æ•¸æ“šåˆ°æ¨™ç±¤è©³ç´°è¡¨æ ¼
function submitToLabelsDetailTable(rowData) {
    // æª¢æŸ¥æ˜¯å¦ç‚ºç·¨è¼¯æ¨¡å¼
    const isEditMode = window.currentEditingLabel && window.currentEditingLabel.isEditMode;
    const existingLabel = isEditMode ? window.currentEditingLabel : null;
    
    // å‰µå»ºæ¨™ç±¤è¨˜éŒ„ï¼ˆå¾åˆ†é¡å…§å®¹æäº¤æ™‚ï¼Œæ¨™è¨˜ç‚ºå·²æäº¤ï¼‰
    const labelRecord = {
        id: existingLabel ? existingLabel.id : (Date.now() + Math.random()),
        inspectionNo: rowData.locationId,
        floor: rowData.floor,
        areaName: rowData.areaName,
        roomNo: rowData.roomNo,
        inspectionDate: rowData.inspectionDateRaw,
        a: isEditMode && existingLabel ? mergePhotoNumbers(existingLabel.a, rowData.a) : rowData.a,
        b: isEditMode && existingLabel ? mergePhotoNumbers(existingLabel.b, rowData.b) : rowData.b,
        c: isEditMode && existingLabel ? mergePhotoNumbers(existingLabel.c, rowData.c) : rowData.c,
        d: isEditMode && existingLabel ? mergePhotoNumbers(existingLabel.d, rowData.d) : rowData.d,
        e: isEditMode && existingLabel ? mergePhotoNumbers(existingLabel.e, rowData.e) : rowData.e,
        f: isEditMode && existingLabel ? mergePhotoNumbers(existingLabel.f, rowData.f) : rowData.f,
        g: isEditMode && existingLabel ? mergePhotoNumbers(existingLabel.g, rowData.g) : rowData.g,
        h: isEditMode && existingLabel ? mergePhotoNumbers(existingLabel.h, rowData.h) : rowData.h,
        i: isEditMode && existingLabel ? mergePhotoNumbers(existingLabel.i, rowData.i) : rowData.i,
        j: isEditMode && existingLabel ? mergeDefectItems(existingLabel.j, rowData.j) : rowData.j,
        // imminentDanger ä¸æ‡‰è©²åœ¨æ¨™ç±¤å±¤é¢è¨­ç½®ï¼Œåªç”±ç¼ºé™·è¡¨å–®æ§åˆ¶
        photoFilenames: isEditMode && existingLabel ? 
            [...new Set([...(existingLabel.photoFilenames || []), ...rowData.photoFilenames])] : 
            rowData.photoFilenames,
        folderName: rowData.folderName,
        // æ¨™è¨˜ç‚ºå·²æäº¤ï¼ˆè—è‰²æ¨™ç±¤ï¼‰
        submitted: true,
        submittedAt: new Date().toISOString()
    };
    
    if (isEditMode) {
        console.log('ğŸ“ Merging data with existing label:', {
            existingLabel,
            newData: rowData,
            mergedLabel: labelRecord
        });
    }

    // æ·»åŠ åˆ°æ¨™ç±¤æ•¸çµ„ï¼ˆè‹¥å·²å­˜åœ¨åŒ inspectionNo çš„æ¨™ç±¤ï¼Œæ”¹ç‚ºæ›´æ–° submitted ç‹€æ…‹ï¼‰
    if (!window.labels) {
        window.labels = [];
    }
    const existingIndex = window.labels.findIndex(l => String(l.inspectionNo) === String(labelRecord.inspectionNo));
    if (existingIndex >= 0) {
        // æ›´æ–°å·²å­˜åœ¨çš„æ¨™ç±¤ç‚ºæäº¤ç‹€æ…‹ï¼Œä¸¦ä¿ç•™æ—¢æœ‰åº§æ¨™/å±¬æ€§å’Œå·²æäº¤çš„ç…§ç‰‡
        const existingLabel = window.labels[existingIndex];
        const existingPhotoFilenames = existingLabel.photoFilenames || [];
        const newPhotoFilenames = labelRecord.photoFilenames || [];
        
        // åˆä½µå·²æäº¤çš„ç…§ç‰‡å’Œæ–°æäº¤çš„ç…§ç‰‡ï¼Œé¿å…é‡è¤‡
        const mergedPhotoFilenames = [...new Set([...existingPhotoFilenames, ...newPhotoFilenames])];
        
        window.labels[existingIndex] = {
            ...existingLabel,
            ...labelRecord,
            photoFilenames: mergedPhotoFilenames, // ä½¿ç”¨åˆä½µå¾Œçš„ç…§ç‰‡åˆ—è¡¨
            submitted: true,
            submittedAt: new Date().toISOString()
        };
        
        window.logger.log(`Updated existing label ${labelRecord.inspectionNo}:`, {
            existingPhotos: existingPhotoFilenames.length,
            newPhotos: newPhotoFilenames.length,
            mergedPhotos: mergedPhotoFilenames.length
        });
    } else {
        window.labels.push(labelRecord);
    }

    // ä¿å­˜åˆ°æœ¬åœ°å­˜å„²
    if (typeof window.saveLabelsToStorage === 'function') {
        window.saveLabelsToStorage();
    }

    // åŒæ™‚ä¿å­˜åˆ°ä¸»æ•¸æ“šå­˜å„²
    saveDataToStorage();

    // é‡æ–°æ¸²æŸ“æ¨™ç±¤ï¼ˆå¦‚æœåœ¨åœ°åœ–ä¸Šï¼‰ï¼Œä»¥äº®è—è‰²é¡¯ç¤ºå·²æäº¤æ¨™ç±¤
    if (typeof window.redrawLabels === 'function') {
        window.redrawLabels();
    }

    // ä¸å†åŒæ­¥åˆ°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼ï¼Œåªæ›´æ–°åˆ†é¡è¡¨æ ¼
    // syncLabelsToInspectionRecords(); // ç§»é™¤æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼åŒæ­¥
    
    // æ›´æ–°åˆ†é¡è¡¨æ ¼
    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}

    // æ›´æ–°ç…§ç‰‡ç‹€æ…‹
    if (typeof updatePhotoStatusFromLabels === 'function') {
        updatePhotoStatusFromLabels();
    }

    window.logger.log('Data submitted to labels detail table:', labelRecord);
}

// èˆŠçš„åŒ¯å‡ºåŠŸèƒ½å·²ç§»é™¤ï¼Œçµ±ä¸€ä½¿ç”¨æ–°çš„åŒ¯å‡ºåŠŸèƒ½

// Reset application state after export
function resetAfterExport() {
    // Clear submitted data
    submittedData = [];
    photoFolders = [];
    submittedFilenames = new Set();
    window.defectEntries.length = 0;
    window.submittedDefectEntries.length = 0;
    
    // Reset photo states
    document.querySelectorAll('.photo-item').forEach(item => {
        item.classList.remove('submitted', 'assigned');
        const img = item.querySelector('img');
        if (img) {
            img.style.filter = '';
            img.style.opacity = '';
        }
        const statusDiv = item.querySelector('.photo-status');
        if (statusDiv) {
            statusDiv.textContent = '';
        }
    });
    
    // Clear the table
    dataTableBody.innerHTML = '<tr><td colspan="13" class="empty-state">No data submitted yet</td></tr>';
    updateTableCount();
    updateFolderDisplay();
    
    // Clear assigned photos
    categories.forEach(category => {
        categoryNumbers[category.id] = [];
        assignedPhotos[category.id] = new Set();
        updateCategoryDisplay(category.id);
    });
    
    // Clear selected photos
    selectedPhotos = [];
    updatePhotoSelection();
    updateSelectedCount();
    
    // Clear folder info
    folderNameDisplay.textContent = '';
    updateFolderDisplay();
    
    // Reset header-fields checkboxes and input values
    resetHeaderCheckboxes();
    
    // Save cleared state to localStorage
    saveDataToStorage();
    
    // Clear photo data from storage
    const savedData = JSON.parse(localStorage.getItem('photoNumberExtractorData') || '{}');
    if (savedData) {
        delete savedData.allPhotoFilenames;
        localStorage.setItem('photoNumberExtractorData', JSON.stringify(savedData));
    }
    
    // åŒæ­¥æ›´æ–°åˆ†é¡è¡¨æ ¼
    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}
    // Note: updateDefectSummaryTable() is called separately in the calling function
}

// Generate defects list without edit and delete buttons
function generateDefectsWithButtons(defectsString, rowId) {
    if (!defectsString || defectsString === 'N/A') {
        return 'N/A';
    }
    
    const defects = defectsString.split('\n').filter(defect => defect.trim());
    if (defects.length === 0) {
        return 'N/A';
    }
    
    return defects.map((defect, index) => {
        const defectId = `${rowId}_defect_${index}`;
        
        // ä½¿ç”¨æ–°çš„ CSS é¡åˆ¥ä¾†åˆ†è¡Œé¡¯ç¤ºç¼ºé™·é …ç›®
        return `
            <div class="defect-item" data-defect-id="${defectId}" data-row-id="${rowId}" data-defect-index="${index}">
                <span class="defect-text">${defect}</span>
            </div>
        `;
    }).join('');
}

// Add a row to the table
function addTableRow(rowData) {
    // Remove empty state if exists
    if (dataTableBody.querySelector('.empty-state')) {
        dataTableBody.innerHTML = '';
    }
    
    const row = document.createElement('tr');
    row.setAttribute('data-id', rowData.id);
    row.innerHTML = `
        <td>${rowData.locationId}</td>
        <td>${rowData.inspectionDate}</td>
        <td>${[rowData.floor || 'N/A', rowData.areaName || 'N/A', rowData.roomNo || 'N/A'].join(', ')}</td>
        <td class="number-cell">${rowData.a ? rowData.a : 'N/A'}</td>
        <td class="number-cell">${rowData.b ? rowData.b : 'N/A'}</td>
        <td class="number-cell">${rowData.c ? rowData.c : 'N/A'}</td>
        <td class="number-cell">${rowData.d ? rowData.d : 'N/A'}</td>
        <td class="number-cell">${rowData.e ? rowData.e : 'N/A'}</td>
        <td class="number-cell">${rowData.f ? rowData.f : 'N/A'}</td>
        <td class="number-cell">${rowData.g ? rowData.g : 'N/A'}</td>
        <td class="number-cell">${rowData.h ? rowData.h : 'N/A'}</td>
        <td class="number-cell">${rowData.i ? rowData.i : 'N/A'}</td>
        <td class="defects-cell">${generateDefectsWithButtons(rowData.j, rowData.id)}</td>
    `;
    dataTableBody.appendChild(row);
}

// Update the table count badge
function updateTableCount() {
    const count = submittedData.length;
    tableCount.textContent = `${count} ${count === 1 ? 'entry' : 'entries'}`;
}

// Show notification
function showNotification(message, type = 'info') {
    // Remove existing notifications
    const existing = document.querySelector('.notification');
    if (existing) existing.remove();
    
    const colors = {
        info: '#388e3c',
        success: '#2e7d32',
        warning: '#f57c00',
        error: '#c62828'
    };
    
    const icons = {
        info: 'info-circle',
        success: 'check-circle',
        warning: 'exclamation-circle',
        error: 'exclamation-triangle'
    };
    
    const icon = icons[type] || 'info-circle';
    
    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.innerHTML = `
        <i class="fas fa-${icon}"></i> ${message}
    `;
    notification.style.backgroundColor = colors[type] || colors.info;
    
    document.body.appendChild(notification);
    
    // ç§»å‹•ç«¯ä½¿ç”¨æ›´é•·çš„é¡¯ç¤ºæ™‚é–“ï¼Œæ¡Œé¢ç«¯ä½¿ç”¨è¼ƒçŸ­æ™‚é–“
    const isMobile = window.MOBILE_DETECTOR && window.MOBILE_DETECTOR.isMobileDevice();
    const displayTime = isMobile ? 3000 : 1000; // ç§»å‹•ç«¯3ç§’ï¼Œæ¡Œé¢ç«¯1ç§’
    
    // Remove after animation completes
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, displayTime);
}

// clearRow function removed - no longer needed as action column is removed

// Clear the entire table
async function clearTable() {
    if (submittedData.length === 0 && window.defectEntries.length === 0) {
        showNotification('Table is already empty', 'info');
        return;
    }
    // Release all submitted photos
    submittedData.forEach(row => {
        row.photoFilenames.forEach(filename => {
            submittedFilenames.delete(filename);
            const photoItems = document.querySelectorAll('.photo-item');
            for (const item of photoItems) {
                if (item.dataset.filename === filename) {
                    item.classList.remove('submitted');
                    const img = item.querySelector('img');
                    if (img) {
                        img.style.filter = '';
                        img.style.opacity = '';
                    }
                    const statusDiv = item.querySelector('.photo-status');
                    if (statusDiv) {
                        statusDiv.textContent = '';
                    }
                    
                    // Always show photo number (extracted from filename)
                    const photoNumberDiv = item.querySelector('.photo-number');
                    if (photoNumberDiv) {
                        const filename = item.dataset.filename;
                        const numberMatch = filename.match(/\d+/);
                        const number = numberMatch ? numberMatch[0] : '';
                        photoNumberDiv.textContent = number;
                    }
                }
            }
        });
    });
    // Clear submitted data and folders
    submittedData = [];
    photoFolders = [];
    submittedFilenames = new Set();
    window.defectEntries = []; // å®Œå…¨é‡ç½®æ•¸çµ„å¼•ç”¨ï¼Œè€Œä¸åªæ˜¯æ¸…ç©ºå…§å®¹
    submittedDefectEntries = [];
    window.logger.log('clearTable: submittedDefectEntries cleared, length:', submittedDefectEntries.length);
    
    // Clear floor plan labels and defect marks
    if (typeof window.labels !== 'undefined') {
        window.labels = [];
        window.logger.log('clearTable: Cleared floor plan labels');
    }
    if (typeof window.defectMarks !== 'undefined') {
        window.defectMarks = [];
        window.logger.log('clearTable: Cleared floor plan defect marks');
    }
    
    // Clear floor plan localStorage
    if (typeof window.saveLabelsToStorage === 'function') {
        window.saveLabelsToStorage();
        window.logger.log('clearTable: Cleared floor plan labels localStorage');
    }
    if (typeof saveDefectMarksToStorage === 'function') {
        saveDefectMarksToStorage();
        window.logger.log('clearTable: Cleared floor plan defect marks localStorage');
    }
    
    // é¡å¤–æ¸…é™¤ç¼ºé™·æ¨™è¨˜çš„ localStorage éµ
    localStorage.removeItem('pne_floorplan_defect_marks');
    window.logger.log('clearTable: Removed pne_floorplan_defect_marks from localStorage');
    
    // è¨­ç½®æ¨™èªŒï¼Œé˜²æ­¢å¾ŒçºŒé‡æ–°è¼‰å…¥ç¼ºé™·æ¨™è¨˜
    window.skipDefectMarksLoad = true;
    window.logger.log('clearTable: Set skipDefectMarksLoad flag to prevent defect marks reload');
    // Clear the table
    dataTableBody.innerHTML = '<tr><td colspan="13" class="empty-state">No data submitted yet</td></tr>';
    updateTableCount();
    updateFolderDisplay();
    // æ¸…ç©º Defect Summary table
    if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
    
    // æ›´æ–°ç¼ºé™·åˆ†é¡å…§å®¹é¡¯ç¤º
    updateCategoryDisplay('j');
    
    // é¡å¤–ç¢ºä¿ç¼ºé™·æ‘˜è¦è¡¨æ ¼è¢«æ¸…ç©º
    const defectSummaryTableBody = document.getElementById('defectSummaryTableBody');
    const defectSummaryCount = document.getElementById('defectSummaryCount');
    if (defectSummaryTableBody) {
        // æª¢æŸ¥æ˜¯å¦é‚„æœ‰è³‡æ–™è¡Œï¼ˆä¸æ˜¯ç©ºç‹€æ…‹è¡Œï¼‰
        const dataRows = defectSummaryTableBody.querySelectorAll('tr:not(.empty-state)');
        if (dataRows.length > 0) {
            window.logger.log('clearTable: Found data rows in defect summary table, forcing clear');
            defectSummaryTableBody.innerHTML = '<tr><td colspan="14" class="empty-state">No defect summary data yet</td></tr>';
            defectSummaryCount.textContent = '0 entries';
        }
    }
    // Save cleared state to localStorage
    saveDataToStorage();
    
    // å¼·åˆ¶æ¸…é™¤ IndexedDB ä¸­çš„æ‰€æœ‰ç›¸é—œæ•¸æ“š
    const currentData = await window.storageAdapter.getItemDirect('photoNumberExtractorData') || {};
    currentData.defectEntries = [];
    currentData.submittedDefectEntries = [];
    currentData.submittedData = [];
    currentData.photoFolders = [];
    currentData.submittedFilenames = [];
    currentData.folderName = '';
    // ç¢ºä¿æ‰€æœ‰ç¼ºé™·ç›¸é—œæ•¸æ“šéƒ½è¢«æ¸…é™¤
    currentData.defectMarks = [];
    currentData.floorPlanDefectMarks = [];
    // æ¸…é™¤æ¨“å±¤å¹³é¢åœ–ç›¸é—œæ•¸æ“š
    if (typeof window.labels !== 'undefined') {
        currentData.floorPlanLabels = [];
    }
    if (typeof window.defectMarks !== 'undefined') {
        currentData.floorPlanDefectMarks = [];
    }
    await window.storageAdapter.setItemDirect('photoNumberExtractorData', currentData);
    window.logger.log('clearTable: Forced clear of all data in IndexedDB');
    
    // ç¢ºä¿ localStorage ä¸­çš„ç¼ºé™·è³‡æ–™è¢«å®Œå…¨æ¸…ç©º
    window.logger.log('clearTable: Final check - submittedDefectEntries.length:', submittedDefectEntries.length);
    
    // å¼·åˆ¶é‡æ–°è¼‰å…¥é é¢ç‹€æ…‹ä»¥ç¢ºä¿æ‰€æœ‰è¡¨æ ¼éƒ½è¢«æ­£ç¢ºæ¸…ç©º
    setTimeout(() => {
        // å†æ¬¡æª¢æŸ¥ä¸¦æ¸…ç©ºç¼ºé™·æ‘˜è¦è¡¨æ ¼
        const defectSummaryTableBody = document.getElementById('defectSummaryTableBody');
        const defectSummaryCount = document.getElementById('defectSummaryCount');
        if (defectSummaryTableBody && window.submittedDefectEntries.length === 0) {
            defectSummaryTableBody.innerHTML = '<tr><td colspan="14" class="empty-state">No defect summary data yet</td></tr>';
            defectSummaryCount.textContent = '0 entries';
            window.logger.log('clearTable: Forced clear of defect summary table');
        }
        
        // ç¢ºä¿ storage ä¸­çš„è³‡æ–™ä¹Ÿè¢«æ­£ç¢ºæ¸…ç©º
        const currentData = JSON.parse(localStorage.getItem('photoNumberExtractorData') || '{}');
        if (currentData.submittedDefectEntries && currentData.submittedDefectEntries.length > 0) {
            window.logger.log('clearTable: Found old data in storage, clearing it');
            currentData.submittedDefectEntries = [];
            localStorage.setItem('photoNumberExtractorData', JSON.stringify(currentData));
        }
        
        // é¡å¤–æª¢æŸ¥ï¼šç¢ºä¿æ²’æœ‰å…¶ä»–åœ°æ–¹é‡æ–°è¼‰å…¥è³‡æ–™
        window.logger.log('clearTable: Final verification - submittedDefectEntries.length:', window.submittedDefectEntries.length);
        if (window.submittedDefectEntries.length > 0) {
            window.logger.log('clearTable: WARNING - submittedDefectEntries was re-populated, clearing again');
            window.submittedDefectEntries.length = 0;
            if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
        }
    }, 100);
    
    showNotification('Table cleared successfully', 'success');
    // åŒæ­¥æ›´æ–°åˆ†é¡è¡¨æ ¼
    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}
}







// Initialize the page
initCategories();
initCustomSelect();
// ç§»é™¤æ­¤è™•çš„è‡ªå‹•è¼‰å…¥ï¼Œç­‰å¾…ç”¨æˆ¶åœ¨æœƒè©±æ¢å¾©å½ˆçª—ä¸­åšå‡ºé¸æ“‡
// loadDataFromStorage(); 
updateTableCount();
updateFolderDisplay();

// Immediately update defect summary table to display any existing detail-table records
if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}

// Clear all category content on page reload to prevent persistence issues
categories.forEach(category => {
    updateCategoryDisplay(category.id);
});
window.logger.log('Page initialization: Cleared all category content on reload');

// å…¨å±€è®Šæ•¸ï¼šè¿½è¹¤æ¨™é¡Œæ¬„ä½æ˜¯å¦ä¾†è‡ªæ¨™ç±¤åˆ†é…
let isHeaderFromLabelAssignment = false;

// å…¨å±€é‡è¤‡æª¢æŸ¥å‡½æ•¸
function checkInspectionNoDuplicate(inspectionNo, excludeIndex = -1, isFromLabelAssignment = false) {
    if (!inspectionNo || !inspectionNo.trim()) {
        return false;
    }
    
    // å¦‚æœæª¢æŸ¥è™Ÿç¢¼ä¾†è‡ªæ¨™ç±¤ç·¨è¼¯é¸å–®çš„åˆ†é…ï¼Œå‰‡ä¸æª¢æŸ¥é‡è¤‡
    if (isFromLabelAssignment) {
        return false;
    }
    
    // ğŸ”§ å¦‚æœåœ¨ç¹ªåœ–æ¨¡å¼ä¸‹ï¼ˆfloor plan overlay é¡¯ç¤ºä¸­ï¼‰ï¼Œå…è¨±é‡è¤‡çš„ inspection no.
    const floorPlanOverlay = document.getElementById('floorPlanOverlay');
    if (floorPlanOverlay && floorPlanOverlay.style.display === 'flex') {
        window.logger.log('Drawing mode active - allowing duplicate inspection number:', inspectionNo);
        return false;
    }
    
    const trimmedNo = inspectionNo.trim();
    
    // æª¢æŸ¥æ¨™ç±¤è©³ç´°è¡¨æ ¼ä¸­çš„é‡è¤‡
    if (window.labels && Array.isArray(window.labels)) {
        for (let i = 0; i < window.labels.length; i++) {
            if (i !== excludeIndex && window.labels[i].inspectionNo === trimmedNo) {
                return true;
            }
        }
    }
    
    return false;
}

// å…¨å±€æ›´æ–°é‡è¤‡ç‹€æ…‹å‡½æ•¸
function updateDuplicateStatus(inputElement, inspectionNo, excludeIndex = -1) {
    if (!inputElement) return;
    
    const isDuplicate = checkInspectionNoDuplicate(inspectionNo, excludeIndex);
    
    if (isDuplicate) {
        inputElement.classList.add('duplicate-inspection-no');
    } else {
        inputElement.classList.remove('duplicate-inspection-no');
    }
    
    return isDuplicate;
}

// Add event listener for inspection number field in defect window (for new entries)


document.addEventListener('DOMContentLoaded', async function() {
    // Initialize storage adapter first
    try {
        await window.storageAdapter.init();
        window.logger.log('Storage adapter initialized successfully');
    } catch (error) {
        window.logger.error('Failed to initialize storage adapter:', error);
    }
    
    // Initialize language system
    initializeLanguageSystem();
    
    // Initialize task management system
    initializeTaskManagement();
    
    // Initialize zoom slider
    zoomSlider = document.getElementById('zoomSlider');
    
    window.logger.log('Zoom slider initialization:', {
        element: zoomSlider,
        value: zoomSlider ? zoomSlider.value : 'N/A',
        min: zoomSlider ? zoomSlider.min : 'N/A',
        max: zoomSlider ? zoomSlider.max : 'N/A'
    });
    
    // Setup defect assign button
    setupDefectAssignButton();
    
    const inspectionNoField = document.getElementById('defectInspectionNo');
    if (inspectionNoField) {
        inspectionNoField.addEventListener('input', function() {
            updateLocationFromInspectionNo(this.value);
            // æª¢æŸ¥é‡è¤‡ä¸¦æ›´æ–°è¦–è¦ºç‹€æ…‹
            const inspectionNo = this.value.trim();
            updateDuplicateStatus(this, inspectionNo);
        });
        
        inspectionNoField.addEventListener('blur', function() {
            const inspectionNo = this.value.trim();
            updateDuplicateStatus(this, inspectionNo);
        });
    }
    
    // Initialize header checkboxes
    initHeaderCheckboxes();
    
    // å•Ÿå‹•è©¢å•ï¼šè‹¥åµæ¸¬åˆ°å·²ä¿å­˜è³‡æ–™ï¼Œé¡¯ç¤ºæ¢å¾©æœƒè©±å½ˆçª—
    try {
        const saved = await window.storageAdapter.getItem('photoNumberExtractorData');
        const modal = document.getElementById('sessionRestoreModal');
        
        // æª¢æŸ¥æ˜¯å¦æœ‰å¯¦éš›çš„æ•¸æ“šï¼ˆä¸åƒ…åƒ…æ˜¯ç©ºçš„æ•¸æ“šçµæ§‹ï¼‰
        // æ³¨æ„ï¼šä¸æª¢æŸ¥ localStorage ä¸­çš„æ•¸æ“šï¼Œå› ç‚ºå®ƒå€‘å¯èƒ½å·²ç¶“é·ç§»åˆ° IndexedDB
        // å¦‚æœå·²ç¶“å®Œæˆ Start Freshï¼Œå‰‡ä¸é¡¯ç¤ºæ¢å¾©æ¨¡æ…‹æ¡†
        const hasActualData = !window.startFreshCompleted && saved && (
            (saved.inspectionRecords && saved.inspectionRecords.length > 0) ||
            (saved.submittedData && saved.submittedData.length > 0) ||
            (saved.floorPlanLabels && saved.floorPlanLabels.length > 0) ||
            (saved.floorPlanDefectMarks && saved.floorPlanDefectMarks.length > 0) ||
            (saved.photoAssignments?.labels && saved.photoAssignments.labels.length > 0) ||
            (saved.photoAssignments?.defectMarks && saved.photoAssignments.defectMarks.length > 0) ||
            (saved.allPhotoFilenames && saved.allPhotoFilenames.length > 0) ||
            (saved.photoMetadata && saved.photoMetadata.length > 0) ||
            saved.floorPlanPDF || 
            saved.floorPlanData ||
            saved.embeddedPDF ||
            saved.floorPlanBase64 ||
            (saved.currentTask && saved.currentTask.name) // åŒ…å«ä»»å‹™æ•¸æ“š
        );
        
        if (hasActualData && modal) {
            // åƒ…åœ¨æœ‰å¯¦éš›æ•¸æ“šæ™‚é¡¯ç¤º
            console.log('Previous session data detected, showing restore modal');
            modal.style.display = 'flex';
            const restoreBtn = document.getElementById('restoreSessionBtn');
            const startFreshBtn = document.getElementById('startFreshBtn');
            if (restoreBtn) {
                restoreBtn.onclick = async () => {
                    modal.style.display = 'none';
                    
                    // é¡¯ç¤ºè¼‰å…¥æç¤º modal
                    const loadingModal = document.getElementById('loadingPreviousDataModal');
                    const loadingPDFIcon = document.getElementById('loadingPDFIcon');
                    const loadingPhotosIcon = document.getElementById('loadingPhotosIcon');
                    const loadingDataIcon = document.getElementById('loadingDataIcon');
                    
                    if (loadingModal) {
                        loadingModal.style.display = 'flex';
                        // é‡ç½®é€²åº¦åœ–æ¨™
                        if (loadingPDFIcon) loadingPDFIcon.classList.remove('completed');
                        if (loadingPhotosIcon) loadingPhotosIcon.classList.remove('completed');
                        if (loadingDataIcon) loadingDataIcon.classList.remove('completed');
                    }
                    
                    try {
                        // å„ªå…ˆä½¿ç”¨å·²ä¿å­˜çš„ FSA handles è‡ªå‹•è¼‰å…¥ PDF èˆ‡ç…§ç‰‡
                        let loadedWithHandles = false;
                        try {
                            // PDF
                            const pdfHandle = await window.storageAdapter.getItem('pne_pdf_file_handle');
                            if (pdfHandle && pdfHandle.kind === 'file') {
                                const p = await pdfHandle.queryPermission?.();
                                if (p === 'granted' || (await pdfHandle.requestPermission?.()) === 'granted') {
                                    const file = await pdfHandle.getFile();
                                    const arrayBuffer = await file.arrayBuffer();
                                    await loadPDFFromArrayBuffer(arrayBuffer, file.name);
                                    const floorPlanOverlay = document.getElementById('floorPlanOverlay');
                                    const floorPlanUploadArea = document.getElementById('floorPlanUploadArea');
                                    const floorPlanViewer = document.getElementById('floorPlanViewer');
                                    if (floorPlanOverlay) floorPlanOverlay.style.display = 'flex';
                                    if (floorPlanUploadArea && floorPlanViewer) {
                                        floorPlanUploadArea.style.display = 'none';
                                        floorPlanViewer.style.display = 'flex';
                                    }
                                    loadedWithHandles = true;
                                    
                                    // æ¨™è¨˜ PDF è¼‰å…¥å®Œæˆ
                                    if (loadingPDFIcon) {
                                        loadingPDFIcon.classList.add('completed');
                                        loadingPDFIcon.closest('.loading-progress-item').classList.add('completed');
                                    }
                                }
                            }
                            // Photos folder
                            const dirHandle = await window.storageAdapter.getItem('pne_photos_dir_handle');
                            if (dirHandle && dirHandle.kind === 'directory') {
                                const p = await dirHandle.queryPermission?.({mode: 'read'});
                                if (p === 'granted' || (await dirHandle.requestPermission?.({mode: 'read'})) === 'granted') {
                                    const imageFiles = [];
                                    for await (const [name, handle] of dirHandle.entries()) {
                                        if (handle.kind === 'file' && /\.(jpe?g|png|gif|bmp|webp)$/i.test(name)) {
                                            const f = await handle.getFile();
                                            imageFiles.push(f);
                                        }
                                    }
                                    if (imageFiles.length > 0) {
                                        window.loadedFromHandles = true; // æ¨™è¨˜é¿å…ä¹‹å¾Œè¦†å¯« allPhotos
                                        allPhotos = imageFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'}));
                                        
                                        // ğŸ”§ å¾ IndexedDB è¼‰å…¥ photoMetadata ä»¥æ¢å¾© dataURL
                                        console.log('ğŸ“¥ Loading photoMetadata to restore dataURLs...');
                                        const savedData = await window.storageAdapter.getItem('photoNumberExtractorData');
                                        if (savedData && savedData.photoMetadata) {
                                            const photoMetadataMap = new Map(savedData.photoMetadata.map(meta => [meta.name, meta.dataURL]));
                                            console.log(`ğŸ“¦ Found ${photoMetadataMap.size} photos in IndexedDB with dataURL`);
                                            
                                            // å°‡ dataURL é™„åŠ åˆ°å¾ FSA handle è®€å–çš„ File å°è±¡ä¸Š
                                            let restoredCount = 0;
                                            for (const photo of allPhotos) {
                                                const dataURL = photoMetadataMap.get(photo.name);
                                                if (dataURL && dataURL.trim() !== '') {
                                                    photo.dataURL = dataURL;
                                                    restoredCount++;
                                                }
                                            }
                                            console.log(`âœ… Restored dataURL for ${restoredCount} / ${allPhotos.length} photos`);
                                        } else {
                                            console.log('âš ï¸ No photoMetadata found in IndexedDB, photos will be re-processed');
                                        }
                                        
                                        const lazyObserver = initLazyLoading();
                                        await renderPhotos(allPhotos, lazyObserver);
                                        updateFolderDisplay();
                                        updateAddPhotosButtonVisibility();
                                        loadedWithHandles = true;
                                        
                                        // æ¨™è¨˜ç…§ç‰‡è¼‰å…¥å®Œæˆ
                                        if (loadingPhotosIcon) {
                                            loadingPhotosIcon.classList.add('completed');
                                            loadingPhotosIcon.closest('.loading-progress-item').classList.add('completed');
                                        }
                                    }
                                }
                            }
                        } catch (e) { /* å¿½ç•¥ handle è¼‰å…¥éŒ¯èª¤ï¼Œé€€å›ä¸€èˆ¬è¼‰å…¥ */ }

                        // è¼‰å…¥å…¶é¤˜è³‡æ–™ï¼ˆæ¨™ç±¤ã€ç¼ºé™·ã€åˆ†é¡â€¦ï¼‰ï¼Œä¸¦é¿å…è¦†å¯«å·²ç”± handle è¼‰å…¥çš„ç…§ç‰‡
                        await loadDataFromStorage();
                        
                        // æ¨™è¨˜æª¢æŸ¥æ•¸æ“šè¼‰å…¥å®Œæˆ
                        if (loadingDataIcon) {
                            loadingDataIcon.classList.add('completed');
                            loadingDataIcon.closest('.loading-progress-item').classList.add('completed');
                        }

                        // è‹¥æœªèƒ½ç”¨ handle è¼‰å…¥ PDFï¼Œæª¢æŸ¥æ˜¯å¦æœ‰åµŒå…¥çš„ PDF æ•¸æ“š
                        try {
                            if (!loadedWithHandles) {
                                // æª¢æŸ¥ localStorage ä¸­æ˜¯å¦æœ‰åµŒå…¥çš„ PDF æ•¸æ“š
                                const pdfBase64 = localStorage.getItem('pne_floorplan_base64');
                                const pdfFilename = localStorage.getItem('pne_floorplan_filename');
                                
                                if (pdfBase64 && pdfFilename) {
                                    window.logger.log('Open previous: Found embedded PDF in localStorage, loading...');
                                    try {
                                        // å°‡ base64 æ•¸æ“šè½‰æ›ç‚º ArrayBuffer
                                        const binaryString = atob(pdfBase64);
                                        const arrayBuffer = new ArrayBuffer(binaryString.length);
                                        const uint8Array = new Uint8Array(arrayBuffer);
                                        for (let i = 0; i < binaryString.length; i++) {
                                            uint8Array[i] = binaryString.charCodeAt(i);
                                        }
                                        
                                        // è¼‰å…¥ PDF
                                        await loadPDFFromArrayBuffer(arrayBuffer, pdfFilename);
                                        
                                        // æ‰“é–‹ç¹ªåœ–æ¨¡å¼
                                        const floorPlanOverlay = document.getElementById('floorPlanOverlay');
                                        const floorPlanUploadArea = document.getElementById('floorPlanUploadArea');
                                        const floorPlanViewer = document.getElementById('floorPlanViewer');
                                        if (floorPlanOverlay) floorPlanOverlay.style.display = 'flex';
                                        if (floorPlanUploadArea && floorPlanViewer) {
                                            floorPlanUploadArea.style.display = 'none';
                                            floorPlanViewer.style.display = 'flex';
                                        }
                                        
                                        // æ¨™è¨˜ PDF è¼‰å…¥å®Œæˆï¼ˆå¦‚æœä¹‹å‰æ²’æœ‰æ¨™è¨˜ï¼‰
                                        if (loadingPDFIcon && !loadingPDFIcon.classList.contains('completed')) {
                                            loadingPDFIcon.classList.add('completed');
                                            loadingPDFIcon.closest('.loading-progress-item').classList.add('completed');
                                        }
                                        
                                        window.logger.log('Open previous: Embedded PDF loaded successfully');
                                    } catch (error) {
                                        window.logger.error('Open previous: Error loading embedded PDF:', error);
                                        // è‡³å°‘æ‰“é–‹ç¹ªåœ–æ¨¡å¼ä»¥ä¾¿ä½¿ç”¨è€…çœ‹åˆ°æé†’èˆ‡è¼‰å…¥æŒ‰éˆ•
                                        const floorPlanOverlay = document.getElementById('floorPlanOverlay');
                                        if (floorPlanOverlay) floorPlanOverlay.style.display = 'flex';
                                    }
                                } else {
                                    // æ²’æœ‰åµŒå…¥çš„ PDFï¼Œè‡³å°‘æ‰“é–‹ç¹ªåœ–æ¨¡å¼ä»¥ä¾¿ä½¿ç”¨è€…çœ‹åˆ°æé†’èˆ‡è¼‰å…¥æŒ‰éˆ•
                                    const floorPlanOverlay = document.getElementById('floorPlanOverlay');
                                    if (floorPlanOverlay) floorPlanOverlay.style.display = 'flex';
                                }
                            }
                        } catch (e) { 
                            window.logger.error('Open previous: Error in PDF loading logic:', e);
                            // è‡³å°‘æ‰“é–‹ç¹ªåœ–æ¨¡å¼
                            const floorPlanOverlay = document.getElementById('floorPlanOverlay');
                            if (floorPlanOverlay) floorPlanOverlay.style.display = 'flex';
                        }
                        
                        // å®Œæˆæ‰€æœ‰è¼‰å…¥å¾Œï¼Œå»¶é²éš±è—è¼‰å…¥ modalï¼ˆè®“ç”¨æˆ¶çœ‹åˆ°å®Œæˆç‹€æ…‹ï¼‰
                        setTimeout(() => {
                            if (loadingModal) {
                                loadingModal.style.display = 'none';
                            }
                        }, 800);
                        
                    } catch (error) {
                        // ç™¼ç”ŸéŒ¯èª¤æ™‚ä¹Ÿè¦éš±è—è¼‰å…¥ modal
                        window.logger.error('Error during session restore:', error);
                        if (loadingModal) {
                            loadingModal.style.display = 'none';
                        }
                    }
                };
            }
            if (startFreshBtn) {
                startFreshBtn.onclick = async () => {
                    modal.style.display = 'none';
                    
                    // é¡¯ç¤ºè¼‰å…¥æŒ‡ç¤ºå™¨
                    const globalLoadingOverlay = document.getElementById('globalLoadingOverlay');
                    const loadingMessage = document.getElementById('loadingMessage');
                    if (globalLoadingOverlay && loadingMessage) {
                        loadingMessage.textContent = 'æ­£åœ¨æ¸…é™¤æ‰€æœ‰æ•¸æ“šä¸¦é‡ç½®æ‡‰ç”¨ç¨‹å¼...';
                        globalLoadingOverlay.style.display = 'flex';
                    }
                    
                    try {
                        // 1) å…ˆæ¸…ç©º IndexedDBï¼ˆåŒ…å«å…ˆå‰å„²å­˜çš„ FSA handles èˆ‡è³‡æ–™ï¼‰
                        console.log('é–‹å§‹æ¸…é™¤ IndexedDB æ•¸æ“š...');
                        await window.storageAdapter.clear();
                        console.log('IndexedDB æ•¸æ“šæ¸…é™¤å®Œæˆ');
                        
                    // ä¹ŸåŒæ­¥æ¸…ç©º localStorageï¼ˆä¿éšªç§»é™¤æ®˜ç•™éµï¼‰
                        try { 
                            localStorage.clear(); 
                            console.log('localStorage æ•¸æ“šæ¸…é™¤å®Œæˆ');
                        } catch (e) { 
                            console.warn('localStorage æ¸…é™¤å¤±æ•—:', e);
                        }
                        
                        // 2) é‡ç½®å‰ç«¯ç‹€æ…‹ï¼Œæä¾›å®Œå…¨ç©ºç™½çš„é–‹å§‹
                        console.log('é–‹å§‹é‡ç½®å‰ç«¯ç‹€æ…‹...');
                        submittedData = [];
                        submittedDefectEntries = [];
                        photoFolders = [];
                        submittedFilenames = new Set();
                        rowIdCounter = 0;
                        allPhotos = [];
                        selectedPhotos = [];
                        
                        // é‡ç½®ç¼ºé™·ç›¸é—œæ•¸æ“š
                        if (typeof window.defectEntries !== 'undefined') {
                            window.defectEntries = [];
                        }
                        
                        // é‡ç½®åˆ†é¡æ•¸æ“š
                        categories.forEach(category => {
                            categoryNumbers[category.id] = [];
                            assignedPhotos[category.id] = new Set();
                        });
                        
                        // é‡ç½®æ¨“å±¤å¹³é¢åœ–èˆ‡ç¼ºé™·æ¨™è¨˜
                        if (typeof window.labels !== 'undefined') window.labels = [];
                        if (typeof window.defectMarks !== 'undefined') window.defectMarks = [];
                        if (typeof window.redrawLabels === 'function') window.redrawLabels();
                        if (typeof window.redrawDefectMarks === 'function') window.redrawDefectMarks();
                        
                        // é—œé–‰ä¸¦é‡ç½®ç¹ªåœ–æ¨¡å¼èˆ‡ PDF æª¢è¦–
                        const floorPlanOverlay = document.getElementById('floorPlanOverlay');
                        const floorPlanUploadArea = document.getElementById('floorPlanUploadArea');
                        const floorPlanViewer = document.getElementById('floorPlanViewer');
                        const floorPlanCanvas = document.getElementById('floorPlanCanvas');
                        const labelLayer = document.getElementById('labelLayer');
                        const floorplanThumb = document.getElementById('floorplanThumb');
                        const floorplanThumbImg = document.getElementById('floorplanThumbImg');
                        
                        if (floorPlanOverlay) floorPlanOverlay.style.display = 'none';
                        if (floorPlanViewer) floorPlanViewer.style.display = 'none';
                        if (floorPlanUploadArea) floorPlanUploadArea.style.display = 'block';
                        if (labelLayer) labelLayer.innerHTML = '';
                        if (floorPlanCanvas) {
                            try { 
                                const ctx = floorPlanCanvas.getContext('2d'); 
                                ctx && ctx.clearRect(0,0,floorPlanCanvas.width,floorPlanCanvas.height); 
                            } catch (e) { 
                                console.warn('æ¸…é™¤ floorPlanCanvas å¤±æ•—:', e);
                            }
                        }
                        
                        // é—œé–‰ PDF ç¸®åœ–
                        if (floorplanThumb) floorplanThumb.style.display = 'none';
                        if (floorplanThumbImg) floorplanThumbImg.src = '';
                        
                        // é‡ç½®è³‡æ–™å¤¾åç¨±èˆ‡ç‹€æ…‹
                        if (folderNameDisplay) folderNameDisplay.textContent = '';
                        window.loadedFromHandles = false;
                        
                        // 3) æ›´æ–°æ‰€æœ‰è¡¨æ ¼å’Œ UI å…ƒç´ 
                        console.log('é–‹å§‹æ›´æ–°æ‰€æœ‰è¡¨æ ¼...');
                        await updateAllTablesAfterStartFresh();
                        
                        // æ›´æ–° UI
                        updateCategoryDisplay('j');
                        updateFolderDisplay();
                        
                        if (photoGrid) {
                            photoGrid.innerHTML = `
                                <div class="empty-preview">
                                    <i class="fas fa-images fa-4x"></i>
                                    <p>Select a folder to preview photos</p>
                                    <button id="centerFolderBtn" class="center-folder-btn" onclick="selectPhotoFolder()">
                                        <i class="fas fa-folder-open"></i> Select Photo Folder
                                    </button>
                                </div>
                            `;
                        }
                        
                        // æ›´æ–° Add photos æŒ‰éˆ•å¯è¦‹æ€§
                        updateAddPhotosButtonVisibility();
                        
                        // æ¸…é™¤ä»»å‹™æ•¸æ“š
                        console.log('æ¸…é™¤ä»»å‹™æ•¸æ“š...');
                        currentTask = null;
                        
                        // æ¸…é™¤ä»»å‹™é¡¯ç¤º
                        const taskDisplayText = document.getElementById('taskDisplayText');
                        if (taskDisplayText) {
                            taskDisplayText.textContent = getText('taskDisplay');
                        }
                        
                        // æ¸…é™¤ä»»å‹™è¡¨å–®
                        const taskFormElement = document.getElementById('taskFormElement');
                        if (taskFormElement) {
                            taskFormElement.reset();
                        }
                        
                        // å¾å­˜å„²ä¸­æ¸…é™¤ä»»å‹™æ•¸æ“š
                        try {
                            await window.storageAdapter.setItem('photoNumberExtractorData', {
                                ...(await window.storageAdapter.getItem('photoNumberExtractorData') || {}),
                                currentTask: null
                            });
                            console.log('ä»»å‹™æ•¸æ“šå·²å¾å­˜å„²ä¸­æ¸…é™¤');
                        } catch (error) {
                            console.error('æ¸…é™¤ä»»å‹™æ•¸æ“šæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                        }
                        
                        console.log('Start Fresh å®Œæˆ - æ‰€æœ‰æ•¸æ“šå·²æ¸…é™¤ï¼Œæ‡‰ç”¨ç¨‹å¼å·²é‡ç½®');
                        showNotification('All saved data cleared. Starting fresh.', 'success');
                        
                        // é¡¯ç¤º Start Fresh è¦†è“‹çª—å£
                        setTimeout(() => {
                            showStartFreshOverlay();
                        }, 500);
                        
                        // è¨­ç½®æ¨™èªŒé˜²æ­¢é‡æ–°é¡¯ç¤ºæ¢å¾©æ¨¡æ…‹æ¡†
                        window.startFreshCompleted = true;
                        
                    } catch (error) {
                        console.error('Start Fresh éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤:', error);
                        showNotification('æ¸…é™¤æ•¸æ“šæ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œä½†æ‡‰ç”¨ç¨‹å¼å·²é‡ç½®', 'warning');
                    } finally {
                        // éš±è—è¼‰å…¥æŒ‡ç¤ºå™¨
                        if (globalLoadingOverlay) {
                            globalLoadingOverlay.style.display = 'none';
                        }
                    }
                };
            }
        } else {
            // æ²’æœ‰å¯¦éš›æ•¸æ“šæ™‚ï¼Œç¢ºä¿ç…§ç‰‡é è¦½å€åŸŸé¡¯ç¤ºç©ºç‹€æ…‹
            if (!hasActualData && photoGrid) {
                photoGrid.innerHTML = `
                    <div class="empty-preview">
                        <i class="fas fa-images fa-4x"></i>
                        <p>Select a folder to preview photos</p>
                        <button id="centerFolderBtn" class="center-folder-btn" onclick="selectPhotoFolder()">
                            <i class="fas fa-folder-open"></i> Select Photo Folder
                        </button>
                    </div>
                `;
                window.logger.log('No actual data found. Displaying empty state.');
                
                // è‡ªå‹•æ‰“é–‹ Start Fresh è¦†è“‹çª—å£ï¼Œæé†’ç”¨æˆ¶é¸æ“‡é–‹å§‹æ–¹å¼
                setTimeout(() => {
                    // æª¢æŸ¥æ˜¯å¦æœ‰ä»»å‹™æ•¸æ“šï¼Œå¦‚æœæ²’æœ‰å‰‡æ‰“é–‹ Start Fresh è¦†è“‹çª—å£
                    if (!window.hasTaskData) {
                        showStartFreshOverlay();
                        console.log('ğŸ”” No previous data and no task data found. Opening Start Fresh overlay to guide user.');
                    }
                }, 1000); // å»¶é²1ç§’ç¢ºä¿é é¢å®Œå…¨è¼‰å…¥
            }
        }
    } catch (e) { 
        // åˆå§‹åŒ–è©¢å•éŒ¯èª¤æ™‚ï¼Œä¹Ÿé¡¯ç¤ºç©ºç‹€æ…‹
        if (photoGrid) {
            photoGrid.innerHTML = `
                <div class="empty-preview">
                    <i class="fas fa-images fa-4x"></i>
                    <p>Select a folder to preview photos</p>
                    <button id="centerFolderBtn" class="center-folder-btn" onclick="selectPhotoFolder()">
                        <i class="fas fa-folder-open"></i> Select Photo Folder
                    </button>
                </div>
            `;
        }
        window.logger.error('Error during session restore initialization:', e);
    }

    // ç§»é™¤è‡ªå‹•è¼‰å…¥é‚è¼¯ - åªæœ‰åœ¨ç”¨æˆ¶é¸æ“‡ã€ŒOpen previousã€å¾Œæ‰è¼‰å…¥ç…§ç‰‡
    // é€™æ¨£ç¢ºä¿åœ¨ç”¨æˆ¶åšå‡ºé¸æ“‡ä¹‹å‰ï¼Œç…§ç‰‡é è¦½å€åŸŸä¿æŒç©ºç™½
    
    // Initialize Add photos button visibility with delay to ensure DOM is ready
    setTimeout(() => {
        updateAddPhotosButtonVisibility();
    }, 100);
    
    // Initialize zoom slider event listeners
    if (zoomSlider) {
        let isResizing = false;
        let resizeStartTime = 0;
        
        zoomSlider.addEventListener('input', function() {
            if (!isResizing) {
                isResizing = true;
                resizeStartTime = Date.now();
                
                // Store current scroll position and container dimensions
                const photoGrid = document.getElementById('photoGrid');
                if (photoGrid) {
                    const containerRect = photoGrid.getBoundingClientRect();
                    const scrollTop = photoGrid.scrollTop;
                    const scrollLeft = photoGrid.scrollLeft;
                    const containerCenterX = containerRect.width / 2;
                    const containerCenterY = containerRect.height / 2;
                    
                    // Store the center point relative to the scroll position
                    window.resizeCenterX = scrollLeft + containerCenterX;
                    window.resizeCenterY = scrollTop + containerCenterY;
                    
                    window.logger.log('Resize started - Center point:', {
                        centerX: window.resizeCenterX,
                        centerY: window.resizeCenterY,
                        scrollTop: scrollTop,
                        scrollLeft: scrollLeft
                    });
                }
            }
            
            const size = this.value + 'px';
            document.documentElement.style.setProperty('--photo-size', size);
            window.logger.log('Photo size changed to:', size);
        });
        
        // Handle resize end and center adjustment
        zoomSlider.addEventListener('change', function() {
            const size = this.value + 'px';
            document.documentElement.style.setProperty('--photo-size', size);
            
            // Adjust scroll position to maintain center after resize
            setTimeout(() => {
                const photoGrid = document.getElementById('photoGrid');
                if (photoGrid && window.resizeCenterX !== undefined && window.resizeCenterY !== undefined) {
                    const containerRect = photoGrid.getBoundingClientRect();
                    const containerCenterX = containerRect.width / 2;
                    const containerCenterY = containerRect.height / 2;
                    
                    // Calculate new scroll position to keep the same center point visible
                    const newScrollLeft = Math.max(0, window.resizeCenterX - containerCenterX);
                    const newScrollTop = Math.max(0, window.resizeCenterY - containerCenterY);
                    
                    photoGrid.scrollTo({
                        left: newScrollLeft,
                        top: newScrollTop,
                        behavior: 'smooth'
                    });
                    
                    window.logger.log('Resize completed - Adjusted scroll position:', {
                        newScrollLeft: newScrollLeft,
                        newScrollTop: newScrollTop,
                        originalCenterX: window.resizeCenterX,
                        originalCenterY: window.resizeCenterY
                    });
                    
                    // Clean up
                    delete window.resizeCenterX;
                    delete window.resizeCenterY;
                }
                
                isResizing = false;
            }, 100); // Small delay to allow CSS transition to complete
        });
        
        // Handle mouse up event to ensure resize end is captured
        zoomSlider.addEventListener('mouseup', function() {
            if (isResizing) {
                // Trigger the same logic as change event
                this.dispatchEvent(new Event('change'));
            }
        });
        
        window.logger.log('Zoom slider event listeners initialized');
    } else {
        window.logger.warn('Zoom slider not found during initialization');
    }
    
    // Add photos button click handler
    addPhotosBtn = document.getElementById('addPhotosBtn');
    addPhotosFileInput = document.getElementById('addPhotosFileInput');
    if (addPhotosBtn && addPhotosFileInput) {
        addPhotosBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation(); // Prevent global click handler interference
            window.logger.log('Add photos button clicked in Chrome');
            window.logger.log('File input element:', addPhotosFileInput);
            window.logger.log('File input display style:', window.getComputedStyle(addPhotosFileInput).display);
            
            // Show loading indicator
            showNotification('Please select additional photos...', 'info', 2000);
            
            // Use requestAnimationFrame for smoother experience
            requestAnimationFrame(() => {
                addPhotosFileInput.click();
            });
        });
        
        // Add photos file input change handler
        addPhotosFileInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            window.logger.log('Add photos: Files selected:', files.length);
            window.logger.log('DEBUG: defectEntries before photo upload:', window.defectEntries ? window.defectEntries.length : 'undefined');
            
            if (files.length === 0) {
                showNotification('No files selected', 'warning');
                return;
            }
            
            // Helper function to show photo upload loading
            const showPhotoUploadLoading = (message = 'æ­£åœ¨è™•ç†ç…§ç‰‡ï¼Œè«‹ç¨å€™') => {
                const loadingStatus = document.getElementById('photoUploadLoadingStatus');
                const statusTitle = document.getElementById('photoUploadStatusTitle');
                const statusMessage = document.getElementById('photoUploadStatusMessage');
                if (loadingStatus && statusTitle && statusMessage) {
                    statusTitle.textContent = 'æ–°å¢ç…§ç‰‡ä¸­...';
                    statusMessage.textContent = message;
                    loadingStatus.style.display = 'flex';
                }
            };
            
            // Helper function to hide photo upload loading
            const hidePhotoUploadLoading = () => {
                const loadingStatus = document.getElementById('photoUploadLoadingStatus');
                if (loadingStatus) {
                    loadingStatus.style.display = 'none';
                }
            };
            
            // Show processing notification
            showNotification('Processing additional photos...', 'info', 1000);
            
            // Show loading indicator
            showPhotoUploadLoading('æ­£åœ¨è™•ç†æ–°å¢çš„ç…§ç‰‡...');
            
            try {
                // Check for duplicate photos by name and content hash
                // Rules:
                // 1. If filename is same AND content hash is same -> block upload
                // 2. If filename is same BUT content hash is different -> allow upload
                // 3. If filename is different BUT content hash is same -> allow upload
                
                window.logger.log('Add photos: Existing photos count:', allPhotos.length);
                window.logger.log('Add photos: Photo hash storage size:', photoHashStorage.size);
                
                const duplicatePhotos = []; // Photos blocked due to same filename AND same hash
                const newPhotos = [];
                const filesToCheck = [];
                
                // First, filter valid image files
                for (const file of files) {
                    window.logger.log('Add photos: Processing file:', file.name, 'Type:', file.type);
                    // Filter out macOS resource fork files (._* files) and only accept valid image files
                    if (!file.name.startsWith('._') && file.type.startsWith('image/')) {
                        filesToCheck.push(file);
                    } else {
                        window.logger.log('Add photos: Skipping non-image file:', file.name);
                    }
                }
                
                // Calculate hashes for all files in parallel
                const fileHashPromises = filesToCheck.map(async (file) => {
                    const hash = await calculateFileHash(file);
                    return { file, hash };
                });
                
                const fileHashResults = await Promise.all(fileHashPromises);
                
                // Check each file against hash storage
                for (const { file, hash } of fileHashResults) {
                    // Check if duplicate (same filename AND same hash)
                    if (isDuplicatePhoto(file.name, hash)) {
                        window.logger.log('Add photos: Duplicate photo blocked (same filename and hash):', file.name, 'Hash:', hash.substring(0, 16) + '...');
                        duplicatePhotos.push(file.name);
                    } else {
                        // Allow upload: either different filename or different hash
                        window.logger.log('Add photos: New photo added to queue:', file.name, 'Hash:', hash.substring(0, 16) + '...');
                        newPhotos.push(file);
                        // Store the hash for future duplicate detection
                        photoHashStorage.set(file.name, hash);
                    }
                }
                
                // Add only new photos to existing photos
                if (newPhotos.length > 0) {
                    window.logger.log('Add photos: Adding', newPhotos.length, 'new photos to allPhotos');
                    
                    // Mark new photos with a flag
                    newPhotos.forEach(photo => {
                        photo.isNewlyAdded = true;
                    });
                    
                    // Update loading message function
                    const updateMessage = (message) => {
                        showPhotoUploadLoading(message);
                    };
                    
                    // Get current photo count for indexing
                    const currentPhotoCount = allPhotos.length;
                    
                    // Process new photos one by one with immediate visual feedback
                    // Note: We need to compress photos that haven't been compressed yet
                    const photosToProcess = [];
                    for (const photo of newPhotos) {
                        if (!photo.dataURL) {
                            // Need to compress this photo
                            try {
                                const compressedDataURL = await resizeImage(photo);
                                photo.dataURL = compressedDataURL;
                            } catch (error) {
                                window.logger.error(`Error compressing photo ${photo.name}:`, error);
                                continue; // Skip this photo
                            }
                        }
                        photosToProcess.push(photo);
                    }
                    
                    // Process and render new photos one by one
                    for (let i = 0; i < photosToProcess.length; i++) {
                        const photo = photosToProcess[i];
                        const index = currentPhotoCount + i;
                        
                        try {
                            // Update loading message
                            updateMessage(`æ­£åœ¨è™•ç†ç¬¬ ${i + 1}/${photosToProcess.length} å¼µæ–°ç…§ç‰‡: ${photo.name}`);
                            
                            // Create photo item element
                            const photoItem = document.createElement('div');
                            photoItem.className = 'photo-item';
                            photoItem.dataset.index = index;
                            photoItem.dataset.filename = photo.name;
                            photoItem.setAttribute('role', 'gridcell');
                            photoItem.setAttribute('aria-label', `Photo ${index + 1}`);
                            // Disable native drag and drop to allow custom drag selection
                            photoItem.draggable = false;
                            
                            // Check if this photo is already assigned
                            let isAssigned = false;
                            for (const cat in assignedPhotos) {
                                if (assignedPhotos[cat].has(photo.name)) {
                                    isAssigned = true;
                                    photoItem.classList.add('assigned');
                                    break;
                                }
                            }
                            
                            // Extract number from filename
                            const numberMatch = photo.name.match(/\d+/);
                            const number = numberMatch ? numberMatch[0] : 'N/A';
                            
                            // Add "new" icon
                            const newIconHtml = '<div class="new-icon">new</div>';
                            
                            photoItem.innerHTML = `
                                <img src="${photo.dataURL}" alt="${photo.name}">
                                <div class="photo-number">${number}</div>
                                <div class="photo-status" id="status-${index}"></div>
                                ${newIconHtml}
                            `;
                            
                            // Disable image dragging to prevent native drag behavior
                            const imgEl = photoItem.querySelector('img');
                            if (imgEl) {
                                imgEl.draggable = false;
                                imgEl.style.userSelect = 'none';
                                imgEl.style.webkitUserDrag = 'none';
                                
                                imgEl.addEventListener('dblclick', async (e) => {
                                    e.stopPropagation();
                                    try {
                                        await showPhotoPreviewPopup(photo, photoItem);
                                    } catch (err) {
                                        console.error('Failed to open photo preview popup:', err);
                                    }
                                });
                            }
                            
                            photoItem.addEventListener('click', (event) => {
                                if (photoItem.classList.contains('assigned') || photoItem.classList.contains('submitted')) {
                                    return;
                                }
                                
                                const currentIndex = parseInt(photoItem.dataset.index);
                                
                                // Handle selection with shift key (range selection)
                                if (event.shiftKey && selectedPhotos.length > 0) {
                                    const lastIndex = selectedPhotos[selectedPhotos.length - 1];
                                    const start = Math.min(lastIndex, currentIndex);
                                    const end = Math.max(lastIndex, currentIndex);
                                    
                                    for (let j = start; j <= end; j++) {
                                        const item = photoGrid.querySelector(`[data-index="${j}"]`);
                                        if (item && !item.classList.contains('assigned') && !item.classList.contains('submitted')) {
                                            item.classList.add('selected');
                                            if (!selectedPhotos.includes(j)) {
                                                selectedPhotos.push(j);
                                            }
                                        }
                                    }
                                }
                                // Handle selection with ctrl/cmd key (multi-select)
                                else if (event.ctrlKey || event.metaKey) {
                                    if (selectedPhotos.includes(currentIndex)) {
                                        // Deselect if already selected
                                        selectedPhotos = selectedPhotos.filter(idx => idx !== currentIndex);
                                        photoItem.classList.remove('selected');
                                    } else {
                                        // Add to selection
                                        selectedPhotos.push(currentIndex);
                                        photoItem.classList.add('selected');
                                    }
                                }
                                // Normal single selection (clear others)
                                else {
                                    // Clear all previous selections
                                    document.querySelectorAll('.photo-item.selected').forEach(item => {
                                        item.classList.remove('selected');
                                    });
                                    selectedPhotos = [currentIndex];
                                    photoItem.classList.add('selected');
                                }
                                
                                updateSelectedCount();
                            });
                            
                            // Immediately append to grid for visual feedback
                            photoGrid.appendChild(photoItem);
                            
                            // Use requestAnimationFrame to allow UI to update
                            await new Promise(resolve => requestAnimationFrame(resolve));
                            
                        } catch (error) {
                            window.logger.error(`Error processing new photo ${photo.name}:`, error);
                        }
                    }
                    
                    // Add processed photos to allPhotos array
                    allPhotos.push(...photosToProcess);
                    window.logger.log('Add photos: Total photos after adding:', allPhotos.length);
                    
                    // Update folder display
                    updateFolderDisplay();
                    
                    // Update button visibility
                    updateAddPhotosButtonVisibility();
                    
                    // Save data to storage to persist the newly added photos
                    showPhotoUploadLoading('æ­£åœ¨å„²å­˜ç…§ç‰‡è³‡æ–™...');
                    window.logger.log('Add photos: Saving data to storage...');
                    await saveDataToStorage();
                    window.logger.log('Add photos: Data saved successfully');
                    
                    // Hide loading indicator
                    hidePhotoUploadLoading();
                } else {
                    window.logger.log('Add photos: No new photos to add');
                    hidePhotoUploadLoading();
                }
                
                window.logger.log('DEBUG: defectEntries after photo upload:', window.defectEntries ? window.defectEntries.length : 'undefined');
                
                // Show appropriate notification
                if (duplicatePhotos.length > 0 && newPhotos.length > 0) {
                    const message = `Added ${newPhotos.length} new photo(s). ${duplicatePhotos.length} duplicate photo(s) were blocked (same filename and content hash): ${duplicatePhotos.slice(0, 3).join(', ')}${duplicatePhotos.length > 3 ? '...' : ''}`;
                    showNotification(message, 'warning', 5000);
                } else if (duplicatePhotos.length > 0 && newPhotos.length === 0) {
                    const message = `${duplicatePhotos.length} duplicate photo(s) were blocked (same filename and content hash): ${duplicatePhotos.slice(0, 3).join(', ')}${duplicatePhotos.length > 3 ? '...' : ''}. Please select different photos.`;
                    showNotification(message, 'warning', 5000);
                } else if (newPhotos.length > 0) {
                    showNotification(`Added ${newPhotos.length} new photo(s)`, 'success');
                }
                
            } catch (error) {
                window.logger.error('Error adding photos:', error);
                hidePhotoUploadLoading();
                showNotification(`Error adding photos: ${error.message}`, 'error');
            }
            
            // Clear the input
            e.target.value = '';
        });
    }
});

// Clean up invalid folder data on page load
function cleanupInvalidFolderData() {
    // If we have folder name but no submitted data, clear the folder name
    if (folderNameDisplay.textContent && 
        folderNameDisplay.textContent !== '' && 
        submittedData.length === 0) {
        folderNameDisplay.textContent = '';
        updateFolderDisplay();
        
        // Show normal empty state
        photoGrid.innerHTML = `
            <div class="empty-preview">
                <i class="fas fa-images fa-4x"></i>
                <p>Select a folder to preview photos</p>
                <button id="centerFolderBtn" class="center-folder-btn" onclick="selectPhotoFolder()">
                    <i class="fas fa-folder-open"></i> Select Photo Folder
                </button>
            </div>
        `;
    }
}

// Run cleanup after initialization
cleanupInvalidFolderData();

// è¼‰å…¥åµŒå…¥çš„ PDF ä¸¦è‡ªå‹•é€²å…¥ç¹ªåœ–æ¨¡å¼
async function loadEmbeddedPDFAndEnterDrawingMode(embeddedPDF) {
    window.logger.log('Loading embedded PDF and entering drawing mode:', embeddedPDF.filename);
    
    try {
        // å°‡ base64 è½‰æ›ç‚º ArrayBuffer
        const binaryString = atob(embeddedPDF.base64Data);
        const arrayBuffer = new ArrayBuffer(binaryString.length);
        const uint8Array = new Uint8Array(arrayBuffer);
        
        for (let i = 0; i < binaryString.length; i++) {
            uint8Array[i] = binaryString.charCodeAt(i);
        }
        
        window.logger.log('Converted base64 to ArrayBuffer, size:', arrayBuffer.byteLength);
        
        // è¼‰å…¥ PDF
        await loadPDFFromArrayBuffer(arrayBuffer, embeddedPDF.filename);
        
        // è‡ªå‹•é€²å…¥ç¹ªåœ–æ¨¡å¼
        const floorPlanOverlay = document.getElementById('floorPlanOverlay');
        const floorPlanUploadArea = document.getElementById('floorPlanUploadArea');
        const floorPlanViewer = document.getElementById('floorPlanViewer');
        
        if (floorPlanOverlay) {
            floorPlanOverlay.style.display = 'flex';
            window.logger.log('Floor plan overlay opened');
        }
        
        if (floorPlanUploadArea && floorPlanViewer) {
            floorPlanUploadArea.style.display = 'none';
            floorPlanViewer.style.display = 'flex';
            window.logger.log('Floor plan viewer activated');
        }
        
        // æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜å·²ç¶“åœ¨ loadPDFFromArrayBuffer ä¸­è¼‰å…¥å’Œæ¸²æŸ“
        // ä¸éœ€è¦é‡è¤‡è¼‰å…¥
        
        // æ‡‰ç”¨ä¿å­˜çš„è¦–åœ–ç‹€æ…‹
        if (embeddedPDF.metadata && embeddedPDF.metadata.dimensions) {
            window.logger.log('Applying saved view state from embedded PDF');
            
            // è¨­ç½®åŸºç¤ç¸®æ”¾
            if (embeddedPDF.metadata.dimensions.width && embeddedPDF.metadata.dimensions.height) {
                const canvas = document.getElementById('floorPlanCanvas');
                if (canvas) {
                    const scaleX = canvas.width / embeddedPDF.metadata.dimensions.width;
                    const scaleY = canvas.height / embeddedPDF.metadata.dimensions.height;
                    window.baseScale = Math.min(scaleX, scaleY);
                    window.logger.log('Base scale calculated:', window.baseScale);
                }
            }
        }
        
        // ç­‰å¾… PDF å®Œå…¨è¼‰å…¥å¾Œå†æ¢å¾©è¦–åœ–ç‹€æ…‹
        setTimeout(() => {
            // å˜—è©¦å¾ localStorage æ¢å¾©è¦–åœ–ç‹€æ…‹
            const viewStateKey = `pne_view_state_${embeddedPDF.filename.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const savedViewState = localStorage.getItem(viewStateKey);
            
            if (savedViewState) {
                try {
                    const viewState = JSON.parse(savedViewState);
                    window.logger.log('Restoring view state for embedded PDF:', viewState);
                    
                    // æ‡‰ç”¨è¦–åœ–ç‹€æ…‹
                    window.currentScale = viewState.scale || 1.0;
                    window.translateX = viewState.translateX || 0;
                    window.translateY = viewState.translateY || 0;
                    
                    if (viewState.baseScale) {
                        if (typeof baseScale !== 'undefined') {
                            baseScale = viewState.baseScale;
                        } else {
                            window.baseScale = viewState.baseScale;
                        }
                    }
                    
                    if (viewState.labelSizeScale) {
                        window.labelSizeScale = viewState.labelSizeScale;
                        if (typeof updateLabelSizeUI === 'function') {
                            updateLabelSizeUI();
                        }
                    }
                    
                    if (viewState.defectMarkSizeScale) {
                        window.defectMarkSizeScale = viewState.defectMarkSizeScale;
                        if (typeof updateDefectMarkSizeUI === 'function') {
                            updateDefectMarkSizeUI();
                        }
                    }
                    
                    // æ‡‰ç”¨è®Šæ›
                    if (typeof window.applyTransform === 'function') {
                        window.applyTransform();
                        window.logger.log('View state applied successfully for embedded PDF');
                    }
                    
                    // é‡æ–°è¨­ç½®é›™æ“Šäº‹ä»¶ç›£è½å™¨ï¼Œç¢ºä¿ç¼ºé™·æ¨™è¨˜å‰µå»ºåŠŸèƒ½æ­£å¸¸
                    if (typeof setupDoubleClickHandler === 'function') {
                        setupDoubleClickHandler();
                        window.logger.log('Double-click handler re-initialized for embedded PDF');
                    }
                } catch (error) {
                    window.logger.error('Error restoring view state for embedded PDF:', error);
                }
            } else {
                window.logger.log('No saved view state found for embedded PDF, using default');
                
                // å³ä½¿æ²’æœ‰è¦–åœ–ç‹€æ…‹ï¼Œä¹Ÿè¦é‡æ–°è¨­ç½®é›™æ“Šäº‹ä»¶ç›£è½å™¨
                if (typeof setupDoubleClickHandler === 'function') {
                    setupDoubleClickHandler();
                    window.logger.log('Double-click handler re-initialized for embedded PDF (no view state)');
                }
            }
        }, 500); // ç­‰å¾… 500ms ç¢ºä¿ PDF å®Œå…¨è¼‰å…¥
        
        // é¡¯ç¤ºæˆåŠŸè¨Šæ¯
        showNotification(`PDF æª”æ¡ˆ "${embeddedPDF.filename}" å·²è‡ªå‹•è¼‰å…¥ä¸¦é€²å…¥ç¹ªåœ–æ¨¡å¼`, 'success');
        
        window.logger.log('Embedded PDF loaded successfully and drawing mode activated');
        
    } catch (error) {
        window.logger.error('Error loading embedded PDF:', error);
        showNotification('è¼‰å…¥åµŒå…¥çš„ PDF æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤', 'error');
        throw error;
    }
}

// æ›´æ–°æ‰€æœ‰è¡¨æ ¼åœ¨ Start Fresh å¾Œ
async function updateAllTablesAfterStartFresh() {
    console.log('é–‹å§‹æ›´æ–°æ‰€æœ‰è¡¨æ ¼...');
    
    try {
        // 1. æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼ (Inspection Records)
        const inspectionRecordsTableBody = document.getElementById('dataTableBody');
        const tableCount = document.getElementById('tableCount');
        
        if (inspectionRecordsTableBody) {
            inspectionRecordsTableBody.innerHTML = '<tr><td colspan="13" class="empty-state">No data submitted yet</td></tr>';
            console.log('æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼å·²æ¸…ç©º');
        }
        
        if (tableCount) {
            tableCount.textContent = '0 entries';
            console.log('æª¢æŸ¥è¨˜éŒ„è¨ˆæ•¸å·²é‡ç½®');
        }
        
        // 2. æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼ (Defect Summary)
        if (typeof window.updateDefectSummaryTable === 'function') {
            window.updateDefectSummaryTable();
            console.log('ç¼ºé™·æ‘˜è¦è¡¨æ ¼å·²æ›´æ–°');
        } else {
            const defectSummaryTableBody = document.getElementById('defectSummaryTableBody');
            const defectSummaryCount = document.getElementById('defectSummaryCount');
            
            if (defectSummaryTableBody) {
                defectSummaryTableBody.innerHTML = '<tr><td colspan="13" class="empty-state">No defect summary data yet</td></tr>';
                console.log('ç¼ºé™·æ‘˜è¦è¡¨æ ¼å·²æ¸…ç©º');
            }
            
            if (defectSummaryCount) {
                defectSummaryCount.textContent = '0 entries';
                console.log('ç¼ºé™·æ‘˜è¦è¨ˆæ•¸å·²é‡ç½®');
            }
        }
        
        // 3. æ›´æ–°åˆ†é¡è¡¨æ ¼ (Category Tables A-I)
        categories.forEach(category => {
            if (category.id !== 'j') { // æ’é™¤ç¼ºé™·åˆ†é¡,å®ƒæœ‰è‡ªå·±çš„è™•ç†é‚è¼¯
                updateCategoryDisplay(category.id);
                console.log(`åˆ†é¡ ${category.id.toUpperCase()} è¡¨æ ¼å·²æ›´æ–°`);
            }
        });
        
        // 3a. æ¸…ç©ºåˆ†é¡è¨˜éŒ„è¡¨æ ¼ (Category Records Tables)
        if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
            window.updateCategoryTablesFromInspectionRecords();
            console.log('åˆ†é¡è¨˜éŒ„è¡¨æ ¼å·²æ›´æ–°');
        } else {
            // æ‰‹å‹•æ¸…ç©ºåˆ†é¡è¨˜éŒ„è¡¨æ ¼
            categoryTableIds.forEach(cat => {
                const tbody = document.querySelector(`#category-table-${cat.id} tbody`);
                if (tbody) {
                    tbody.innerHTML = '';
                    console.log(`åˆ†é¡ ${cat.id.toUpperCase()} è¨˜éŒ„è¡¨æ ¼å·²æ¸…ç©º`);
                }
            });
        }
        
        // 4. æ›´æ–°æ¨™ç±¤è©³ç´°è¡¨æ ¼ (Labels Detail)
        const labelsDetailTableBody = document.getElementById('labelsDetailTableBody');
        if (labelsDetailTableBody) {
            labelsDetailTableBody.innerHTML = '';
            console.log('æ¨™ç±¤è©³ç´°è¡¨æ ¼å·²æ¸…ç©º');
        }
        
        // 5. æ›´æ–°ç¼ºé™·è©³ç´°è¡¨æ ¼ (Defects Detail)
        const defectsDetailTableBody = document.getElementById('defectsDetailTableBody');
        if (defectsDetailTableBody) {
            defectsDetailTableBody.innerHTML = '';
            console.log('ç¼ºé™·è©³ç´°è¡¨æ ¼å·²æ¸…ç©º');
        }
        
        // 6. é‡ç½®æ‰€æœ‰åˆ†é¡çš„è¨ˆæ•¸é¡¯ç¤º
        categories.forEach(category => {
            const countBadge = document.getElementById(`count-${category.id}`);
            if (countBadge) {
                countBadge.textContent = '0';
            }
        });
        
        // 7. é‡ç½®é¸ä¸­çš„ç…§ç‰‡è¨ˆæ•¸å’Œç‹€æ…‹
        const selectedCount = document.getElementById('selectedCount');
        if (selectedCount) {
            selectedCount.textContent = '0';
        }
        
        // é‡ç½®ç…§ç‰‡é¸æ“‡ç‹€æ…‹
        if (typeof updatePhotoSelection === 'function') {
            updatePhotoSelection();
        }
        
        if (typeof updateSelectedCount === 'function') {
            updateSelectedCount();
        }
        
        // 8. é‡ç½®æ¨™é¡Œæ¬„ä½
        const headerFields = [
            'locationId', 'inspectionDate', 'floorHeader', 
            'areaNameHeader', 'roomNo'
        ];
        
        headerFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
                field.value = '';
            }
        });
        
        // 9. é‡ç½®æ¨™é¡Œæ¬„ä½çš„å‹¾é¸ç‹€æ…‹
        const headerCheckboxes = [
            'locationIdCheck', 'inspectionDateCheck', 'floorHeaderCheck',
            'areaNameHeaderCheck', 'roomNoCheck'
        ];
        
        headerCheckboxes.forEach(checkboxId => {
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.checked = false;
            }
        });
        
        console.log('æ‰€æœ‰è¡¨æ ¼æ›´æ–°å®Œæˆ');
        
    } catch (error) {
        console.error('æ›´æ–°è¡¨æ ¼æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
        throw error; // é‡æ–°æ‹‹å‡ºéŒ¯èª¤ï¼Œè®“ä¸Šå±¤è™•ç†
    }
}

// Update button text based on browser support
function updateButtonText() {
    const centerFolderBtn = document.getElementById('centerFolderBtn');
    const pneSelectFolderBtn = document.querySelector('.pne-dropdown-item[data-action="selectfolder"]');
    
    if (isWebkitDirectorySupported()) {
        const buttonText = '<i class="fas fa-folder-open"></i> Select Photo Folder';
        const ariaLabel = 'Select photo folder';
        
        if (centerFolderBtn) {
            centerFolderBtn.innerHTML = buttonText;
            centerFolderBtn.setAttribute('aria-label', ariaLabel);
        }
        if (pneSelectFolderBtn) {
            pneSelectFolderBtn.innerHTML = buttonText;
            pneSelectFolderBtn.setAttribute('aria-label', ariaLabel);
        }
    } else {
        const buttonText = '<i class="fas fa-images"></i> Select Multiple Files';
        const ariaLabel = 'Select multiple files';
        
        if (centerFolderBtn) {
            centerFolderBtn.innerHTML = buttonText;
            centerFolderBtn.setAttribute('aria-label', ariaLabel);
        }
        if (pneSelectFolderBtn) {
            pneSelectFolderBtn.innerHTML = buttonText;
            pneSelectFolderBtn.setAttribute('aria-label', ariaLabel);
        }
    }
}

// Update button text on page load
updateButtonText();

// Add event listener for Clear All Categories button
clearBtn.addEventListener('click', () => {
    clearAllCategories();
});

// Clear row button event listener removed - no longer needed as action column is removed


// Zoom slider event listeners moved to DOMContentLoaded

// Export CSV functionality moved to PNE dropdown menu

// Save data when the page is about to unload
window.addEventListener('beforeunload', function() {
    console.log('ğŸ’¾ Page is unloading, saving data...');
    console.log('ğŸ’¾ Current allPhotos count:', allPhotos ? allPhotos.length : 0);
    console.log('ğŸ’¾ Photos with dataURL:', allPhotos ? allPhotos.filter(p => p.dataURL).length : 0);
    saveDataToStorage();
});

// æª¢æŸ¥æ˜¯å¦ç‚º Safari ç€è¦½å™¨
function isSafari() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}

// æª¢æŸ¥æ˜¯å¦æ”¯æ´ webkitdirectory
function isWebkitDirectorySupported() {
    const input = document.createElement('input');
    return 'webkitdirectory' in input && !isSafari();
}

// æ‹–æ‹½åŠŸèƒ½å·²ç§»é™¤

// 1. å®šç¾© 9 å€‹åˆ†é¡è¡¨æ ¼çš„è³‡æ–™çµæ§‹
const categoryTableIds = [
    {id: 'a', name: 'A: Exposed structural metalwork'},
    {id: 'b', name: 'B: Structural elements'},
    {id: 'c', name: 'C: External building elements'},
    {id: 'd', name: 'D: Suspended objects'},
    {id: 'e', name: 'E: High level internal finishes'},
    {id: 'f', name: 'F: Heavy metal gates/doors'},
    {id: 'g', name: 'G: Window and glass louvers'},
    {id: 'h', name: 'H: Drainage and Plumbing systems'},
    {id: 'i', name: 'I: Fire safety elements'}
];
let categoryTablesData = {}; // { a: [ {locationNo, roomNo, photoNo, defects}, ... ], ... }

// 2. å‹•æ…‹ç”¢ç”Ÿ 9 å€‹åˆ†é¡è¡¨æ ¼
function renderCategoryTables() {
    const section = document.getElementById('categoryTablesSection');
    section.innerHTML = '';
    categoryTableIds.forEach(cat => {
        const container = document.createElement('div');
        container.className = 'category-table-container';
        
        // Get localized category name and headers
        const categoryKey = `categoryTable${cat.id.toUpperCase()}`;
        const localizedName = getText(categoryKey);
        const locationNoHeader = getText('locationNoHeader');
        const roomNoHeader = getText('roomNoHeader');
        const photoNoHeader = getText('photoNoHeader');
        const defectsHeader = getText('defectsHeader');
        
        container.innerHTML = `
            <div class="category-table-title"><i class="fas fa-table"></i> ${localizedName}</div>
            <table class="category-table" id="category-table-${cat.id}">
                <thead>
                    <tr>
                        <th>${locationNoHeader}</th>
                        <th>${roomNoHeader}</th>
                        <th>${photoNoHeader}</th>
                        <th>${defectsHeader}</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            </table>
        `;
        section.appendChild(container);
    });
}
renderCategoryTables();

// åŒæ­¥æ¨™ç±¤è©³ç´°è¡¨æ ¼çš„æ•¸æ“šåˆ°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼ï¼ˆåªé¡¯ç¤ºï¼Œä¸å­˜å„²ï¼‰
function syncLabelsToInspectionRecords() {
    // å–å¾—è¡¨æ ¼ body ä¸¦å…ˆæ¸…ç©ºç‚ºç©ºç‹€æ…‹
    const dataTableBody = document.getElementById('dataTableBody');
    if (dataTableBody) {
        dataTableBody.innerHTML = '<tr><td colspan="13" class="empty-state">No data submitted yet</td></tr>';
    }
    
    // æ¸…ç©º submittedDataï¼ˆåƒ…é¡¯ç¤ºç”¨é€”ï¼Œä¸æŒä¹…åŒ–ï¼‰
    submittedData = [];
    
    // åªé¡¯ç¤ºè—è‰²ï¼ˆå·²æäº¤ï¼‰çš„æ¨™ç±¤
    const sourceLabels = Array.isArray(window.labels) ? window.labels : [];
    const labelsToSync = sourceLabels.filter(l => l && l.submitted);
    
    // ç„¡è³‡æ–™æ™‚ï¼Œç¶­æŒç©ºç‹€æ…‹ä¸¦æ›´æ–°è¨ˆæ•¸å¾Œè¿”å›
    if (!labelsToSync || labelsToSync.length === 0) {
        if (typeof updateTableCount === 'function') {
            updateTableCount();
        }
        window.logger.log('Synced labels to inspection records (display only): 0 records');
        return;
    }
    
    // å°‡æ¨™ç±¤è½‰ç‚ºæª¢æŸ¥è¨˜éŒ„åˆ—ä¸¦æ–°å¢åˆ° submittedDataï¼ˆåƒ…é¡¯ç¤ºï¼‰
    labelsToSync.forEach(label => {
        if (!label) return;
        const inspectionRecord = {
            id: label.id,
            locationId: label.inspectionNo,
            inspectionDate: label.inspectionDate,
            floor: label.floor,
            areaName: label.areaName,
            roomNo: label.roomNo,
            a: label.a || 'N/A',
            b: label.b || 'N/A',
            c: label.c || 'N/A',
            d: label.d || 'N/A',
            e: label.e || 'N/A',
            f: label.f || 'N/A',
            g: label.g || 'N/A',
            h: label.h || 'N/A',
            i: label.i || 'N/A',
            j: label.j || 'N/A',
            photoFilenames: label.photoFilenames || [],
            folderName: label.folderName || '',
            hasImminentDanger: label.imminentDanger || false,
            submittedAt: label.submittedAt
        };
        submittedData.push(inspectionRecord);
    });
    
    // æŒ‰æª¢æŸ¥ç·¨è™Ÿæ’åº submittedData
    submittedData.sort((a, b) => {
        const aNo = parseInt(a.locationId) || 0;
        const bNo = parseInt(b.locationId) || 0;
        return aNo - bNo;
    });
    
    // åŒæ­¥åˆ°å…¨å±€è®Šé‡ä¾›å…¶ä»–åŠŸèƒ½ä½¿ç”¨
    window.inspectionRecords = submittedData;
    console.log('ğŸ” Synced window.inspectionRecords:', window.inspectionRecords.length, 'records');
    
    // æ¸…ç©ºè¡¨æ ¼ä¸¦é‡æ–°æ·»åŠ æ’åºå¾Œçš„æ•¸æ“š
    if (dataTableBody) {
        dataTableBody.innerHTML = '';
    }
    
    // æ·»åŠ æ’åºå¾Œçš„è¨˜éŒ„åˆ°è¡¨æ ¼
    submittedData.forEach(inspectionRecord => {
        if (typeof addTableRow === 'function') {
            addTableRow(inspectionRecord);
        }
    });
    
    if (typeof updateTableCount === 'function') {
        updateTableCount();
    }
    window.logger.log('Synced labels to inspection records (display only):', submittedData.length, 'records');
}

// 3. å¡«å……åˆ†é¡è¡¨æ ¼è³‡æ–™
window.updateCategoryTablesFromInspectionRecords = function() {
    // å…ˆæ¸…ç©º
    categoryTablesData = {};
    categoryTableIds.forEach(cat => categoryTablesData[cat.id] = []);
    
    // åŒæ­¥æ¨™ç±¤è©³ç´°è¡¨æ ¼çš„æ•¸æ“šåˆ°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼
    syncLabelsToInspectionRecords();
    
    // ç›´æ¥å¾ submittedData é™£åˆ—è®€å–è³‡æ–™ï¼Œè€Œä¸æ˜¯å¾ DOM è¡¨æ ¼
    if (submittedData.length === 0) {
        // è‹¥ç„¡è³‡æ–™ï¼Œä¿æŒç©ºç™½
        categoryTableIds.forEach(cat => {
            const tbody = document.querySelector(`#category-table-${cat.id} tbody`);
            tbody.innerHTML = '';
        });
        return;
    }
    
    // å¾ submittedData é™£åˆ—è®€å–æ¯ä¸€ç­†è³‡æ–™
    submittedData.forEach(rowData => {
        const locationNo = rowData.locationId || 'N/A';
        const roomNo = rowData.roomNo || 'N/A';
        
        // è§£æç¼ºé™·é …ç›®ï¼Œæ ¹æ“šå…¶åˆ†é¡å¡«å…¥å°æ‡‰çš„åˆ†é¡è¡¨æ ¼
        const defectItems = rowData.j ? rowData.j.split('\n').filter(item => item.trim()) : [];
        
        // ç‚ºæ¯å€‹åˆ†é¡å»ºç«‹è¨˜éŒ„
        categoryTableIds.forEach(cat => {
            const photoNo = rowData[cat.id] || 'N/A'; // ç›´æ¥å¾ rowData è®€å–å°æ‡‰åˆ†é¡çš„è³‡æ–™
            
            // æ‰¾å‡ºå±¬æ–¼æ­¤åˆ†é¡çš„ç¼ºé™·é …ç›®
            const categoryDefects = defectItems.filter(item => {
                // æª¢æŸ¥ç¼ºé™·é …ç›®æ˜¯å¦å±¬æ–¼æ­¤åˆ†é¡
                // ç¼ºé™·é …ç›®çš„æ ¼å¼é€šå¸¸æ˜¯: "range_description" æˆ– "* range_description"
                const description = item.replace(/^\*?\s*/, ''); // ç§»é™¤æ˜Ÿè™Ÿå‰ç¶´
                const defectDesc = description.split('_').slice(1).join('_'); // å–å¾—æè¿°éƒ¨åˆ†
                
                // æª¢æŸ¥æ­¤æè¿°æ˜¯å¦åœ¨å°æ‡‰åˆ†é¡çš„ç¼ºé™·é¡å‹åˆ—è¡¨ä¸­
                return defectTypes[cat.id] && defectTypes[cat.id].includes(defectDesc);
            });
            
            // å¦‚æœæ­¤åˆ†é¡æœ‰ç…§ç‰‡ç·¨è™Ÿæˆ–æœ‰å°æ‡‰çš„ç¼ºé™·é …ç›®ï¼Œå‰‡å»ºç«‹è¨˜éŒ„
            if (photoNo.trim() || categoryDefects.length > 0) {
                const defects = categoryDefects.length > 0 ? categoryDefects.join('; ') : 'N/A';
                categoryTablesData[cat.id].push({
                    locationNo, 
                    roomNo, 
                    photoNo: photoNo.trim() ? photoNo : 'N/A', 
                    defects
                });
            }
        });
    });
    
    // å¯«å…¥è¡¨æ ¼
    categoryTableIds.forEach(cat => {
        const tbody = document.querySelector(`#category-table-${cat.id} tbody`);
        if (categoryTablesData[cat.id].length === 0) {
            tbody.innerHTML = '';
        } else {
            tbody.innerHTML = categoryTablesData[cat.id].map(row =>
                `<tr>
                    <td>${row.locationNo}</td>
                    <td>${row.roomNo}</td>
                    <td>${row.photoNo}</td>
                    <td>${row.defects}</td>
                </tr>`
            ).join('');
        }
    });
}

// åŒæ­¥æ›´æ–° floor plan ä¸­çš„ç¼ºé™·æ¨™è¨˜ç·¨è™Ÿ
function updateFloorPlanDefectNumbers() {
    // æª¢æŸ¥æ˜¯å¦æœ‰ floor plan ç›¸é—œçš„è®Šæ•¸å’Œå‡½æ•¸
    if (typeof defectMarks === 'undefined' || typeof redrawDefectMarks === 'undefined') {
        window.logger.log('Floor plan defect marks not available, skipping update');
        return;
    }
    
    window.logger.log('Updating floor plan defect numbers, current count:', window.defectMarks.length);
    
    // æŒ‰ç…§ç¼ºé™·æ¨™è¨˜çš„å‰µå»ºé †åºé‡æ–°ç·¨è™Ÿï¼ˆå¾ 1 é–‹å§‹ï¼‰
    window.defectMarks.forEach((defectMark, index) => {
        const newDefectNo = index + 1;
        if (defectMark.defectNo !== newDefectNo.toString()) {
            window.logger.log(`Updating defect mark ${defectMark.id} from ${defectMark.defectNo} to ${newDefectNo}`);
            defectMark.defectNo = newDefectNo.toString();
        }
    });
    
    // ä¿å­˜æ›´æ–°å¾Œçš„ç¼ºé™·æ¨™è¨˜æ•¸æ“š
    if (typeof saveDefectMarksToStorage === 'function') {
        saveDefectMarksToStorage();
    }
    
    // é‡æ–°æ¸²æŸ“ç¼ºé™·æ¨™è¨˜ä»¥é¡¯ç¤ºæ–°çš„ç·¨è™Ÿ
    if (typeof window.redrawDefectMarks === 'function') {
        window.redrawDefectMarks();
    }
    
    // æ³¨æ„ï¼šæ¨™ç±¤ç·¨è™Ÿä¸æ‡‰è©²è¢«è‡ªå‹•é‡æ–°ç·¨è™Ÿ
    // æ¨™ç±¤çš„ inspectionNo æ‡‰è©²ä¿æŒç”¨æˆ¶è¨­å®šçš„å€¼
    // åªæ›´æ–°æ¨™ç±¤ä½ç½®ï¼Œä¸æ”¹è®Šç·¨è™Ÿ
    window.logger.log('Labels numbering preserved - only positions updated');
    
    // åŒæ™‚æ›´æ–°æ¨™ç±¤ä½ç½®ä»¥ç¢ºä¿åŒæ­¥
    if (typeof window.updateAllLabelPositions === 'function') {
        window.updateAllLabelPositions();
    }
    
    window.logger.log('Floor plan defect numbers updated successfully');
}


// Update Defect Summary Table
window.updateDefectSummaryTable = function() {
    
    const tbody = document.getElementById('defectSummaryTableBody');
    const countBadge = document.getElementById('defectSummaryCount');
    
    // åªå¾ defectEntries ä¸­æå–ç¼ºé™·æ•¸æ“šï¼ˆé€™äº›æ•¸æ“šä¾†è‡ª all defects detail-table-containerï¼‰
    const allDefects = [];
    let globalDefectIndex = 0;
    
    // å¾ç•¶å‰çš„ç¼ºé™·æ¢ç›®ä¸­æå–æ•¸æ“šï¼ˆä¾†è‡ª all defects detail-table-container çš„è³‡æ–™ï¼‰
    window.defectEntries.forEach((entry, entryIndex) => {
        // å°‡åˆ†é¡ä»£ç¢¼è½‰æ›ç‚ºå®Œæ•´çš„åˆ†é¡åç¨±
        const getCategoryName = (categoryCode) => {
            const category = categories.find(cat => cat.id === categoryCode);
            return category ? category.name : categoryCode;
        };
        
        allDefects.push({
            id: `defect_entry_${entryIndex}`,
            defectNo: entry.defectNo || (globalDefectIndex + 1),
            imminentDanger: entry.imminentDanger || false,
            location: `${entry.floor || 'N/A'}, ${entry.areaName || 'N/A'}, ${entry.roomNo || 'N/A'}`,
            category: getCategoryName(entry.category) || 'N/A',
            description: entry.description || 'N/A',
            range: entry.range || 'N/A',
            descriptionConstruction: entry.descriptionConstruction || 'N/A',
            existingCondition: entry.existingCondition || 'N/A',
            humidity: entry.humidity || 'N/A',
            moisture: entry.moisture || 'N/A',
            chloride: entry.chloride || 'N/A',
            carbonation: entry.carbonation || 'N/A',
            remedialWorks: entry.remedialWorks || 'N/A',
            preventiveWorks: entry.preventiveWorks || 'N/A',
            remarks: (entry.remarks && entry.remarks.trim() !== '') ? entry.remarks : 'N/A'
        });
        globalDefectIndex++;
    });
    
    window.logger.log('updateDefectSummaryTable: total defects found:', allDefects.length);
    window.logger.log('updateDefectSummaryTable: defectEntries array length:', window.defectEntries.length);
    window.logger.log('updateDefectSummaryTable: submittedData array length:', submittedData.length);
    window.logger.log('updateDefectSummaryTable: defectEntries content:', window.defectEntries);
    
    if (allDefects.length === 0) {
        window.logger.log('Clearing defect summary table - no defects found in defect entries or submitted data');
        tbody.innerHTML = '<tr><td colspan="13" class="empty-state">No defect summary data yet</td></tr>';
        countBadge.textContent = '0 entries';
        return;
    }
    
    // Remove empty state if exists
    if (tbody.querySelector('.empty-state')) {
        tbody.innerHTML = '';
    }
    
    // Generate defect summary rows with sequential numbering from 1
    const summaryRows = allDefects.map((defect) => {
        const imminentDanger = defect.imminentDanger ? 'Yes' : 'No';
        return `
            <tr data-defect-id="${defect.id}" data-defect-no="${defect.defectNo}">
                <td>${defect.defectNo}</td>
                <td>${imminentDanger}</td>
                <td>${defect.location}</td>
                <td>${defect.category}</td>
                <td>${defect.descriptionConstruction}</td>
                <td>${defect.existingCondition}</td>
                <td>${defect.description}</td>
                <td>${defect.humidity}</td>
                <td>${defect.moisture}</td>
                <td>${defect.chloride}</td>
                <td>${defect.carbonation}</td>
                <td>${defect.remedialWorks}</td>
                <td>${defect.preventiveWorks}</td>
                <td>${defect.remarks}</td>
            </tr>
        `;
    });
    tbody.innerHTML = summaryRows.join('');
    countBadge.textContent = `${allDefects.length} ${allDefects.length === 1 ? 'entry' : 'entries'}`;
    
    // æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼ä¸­çš„ç¼ºé™·ç·¨è™Ÿ
    updateTableDefectsDisplay();
    
    // å¦‚æœç¼ºé™·é …ç›®æ¢ç›®èœå–®æ˜¯æ‰“é–‹çš„ï¼Œé‡æ–°åˆ†é…ç¼ºé™·ç·¨è™Ÿ
    if (defectWindow && defectWindow.style.display !== 'none') {
        assignDefectNo();
    }
    
    // æ›´æ–°ç¼ºé™·åˆ†é¡å…§å®¹é¡¯ç¤º
    updateCategoryDisplay('j');
}

// ç·¨è¼¯ç¼ºé™·è¨˜éŒ„å‡½æ•¸
function editDefectRecord(defectId, defectNo) {
    window.logger.log('Editing defect record:', defectId, defectNo);
    
    // æ‰¾åˆ°å°æ‡‰çš„ç¼ºé™·æ¢ç›®
    const defectEntryIndex = window.defectEntries.findIndex(entry => 
        String(entry.defectNo) === String(defectNo)
    );
    
    if (defectEntryIndex >= 0) {
        const defectEntry = window.defectEntries[defectEntryIndex];
        
        // å¡«å……ç¼ºé™·è¡¨å–®
        document.getElementById('defectInspectionNo').value = defectEntry.locationId || '';
        document.getElementById('inspectionDateDefect').value = defectEntry.inspectionDate || '';
        document.getElementById('defectFloor').value = defectEntry.floor || '';
        document.getElementById('defectAreaName').value = defectEntry.areaName || '';
        document.getElementById('defectRoomNo').value = defectEntry.roomNo || '';
        document.getElementById('defectNo').value = defectEntry.defectNo || '';
        document.getElementById('defectPhotoNo').value = defectEntry.photoNumbers || '';
        document.getElementById('defectCategory').value = defectEntry.category || '';
        document.getElementById('defectTypeDirectInput').value = defectEntry.defectType || '';
        document.getElementById('defectDescription').value = defectEntry.description || '';
        document.getElementById('defectExistingCondition').value = defectEntry.existingCondition || '';
        document.getElementById('defectHumidity').value = defectEntry.humidity || '';
        document.getElementById('defectMoisture').value = defectEntry.moisture || '';
        document.getElementById('defectChloride').value = defectEntry.chloride || '';
        document.getElementById('defectCarbonation').value = defectEntry.carbonation || '';
        document.getElementById('defectRemedialWorks').value = defectEntry.remedialWorks || '';
        document.getElementById('defectPreventiveWorks').value = defectEntry.preventiveWorks || '';
        document.getElementById('defectRemarks').value = defectEntry.remarks || '';
        
        // è¨­ç½®ç·Šæ€¥å±éšªç‹€æ…‹
        const imminentDangerSwitch = document.getElementById('imminentDangerSwitch');
        if (imminentDangerSwitch) {
            imminentDangerSwitch.checked = defectEntry.imminentDanger || false;
        }
        
        // æ‰“é–‹ç¼ºé™·è¡¨å–®çª—å£
        const defectWindow = document.getElementById('defectWindow');
        if (defectWindow) {
            defectWindow.style.display = 'block';
        }
        
        // è¨­ç½®ç·¨è¼¯æ¨¡å¼æ¨™è¨˜
        window.editingDefectId = defectId;
        window.editingDefectNo = defectNo;
        
        showNotification('ç¼ºé™·è¨˜éŒ„å·²è¼‰å…¥åˆ°ç·¨è¼¯è¡¨å–®', 'info');
    } else {
        showNotification('æ‰¾ä¸åˆ°å°æ‡‰çš„ç¼ºé™·è¨˜éŒ„', 'error');
    }
}

// åˆªé™¤ç¼ºé™·è¨˜éŒ„å‡½æ•¸
function deleteDefectRecord(defectId, defectNo) {
    window.logger.log('Deleting defect record:', defectId, defectNo);
    
    // ç¢ºèªåˆªé™¤
    if (!confirm(`ç¢ºå®šè¦åˆªé™¤ç¼ºé™·è¨˜éŒ„ ${defectNo} å—ï¼Ÿæ­¤æ“ä½œå°‡åŒæ™‚åˆªé™¤ç›¸é—œçš„ç¼ºé™·æ¨™è¨˜ã€‚`)) {
        return;
    }
    
    // å¾ç¼ºé™·æ¢ç›®ä¸­åˆªé™¤
    const defectEntryIndex = window.defectEntries.findIndex(entry => 
        String(entry.defectNo) === String(defectNo)
    );
    
    if (defectEntryIndex >= 0) {
        window.defectEntries.splice(defectEntryIndex, 1);
        window.logger.log('Deleted defect entry from defectEntries:', defectNo);
    }
    
    // å¾æäº¤çš„ç¼ºé™·æ¢ç›®ä¸­åˆªé™¤
    const submittedDefectEntryIndex = window.submittedDefectEntries.findIndex(entry => 
        String(entry.defectNo) === String(defectNo)
    );
    
    if (submittedDefectEntryIndex >= 0) {
        window.submittedDefectEntries.splice(submittedDefectEntryIndex, 1);
        window.logger.log('Deleted defect entry from submittedDefectEntries:', defectNo);
    }
    
    // åŒæ­¥åˆªé™¤å°æ‡‰çš„ç¼ºé™·æ¨™è¨˜ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    if (window.defectMarks && window.defectMarks.length > 0) {
        const defectMarkIndex = window.defectMarks.findIndex(mark => 
            String(mark.defectNo) === String(defectNo)
        );
        
        if (defectMarkIndex >= 0) {
            window.defectMarks.splice(defectMarkIndex, 1);
            window.logger.log('Deleted corresponding defect mark:', defectNo);
            
            // ä¿å­˜ç¼ºé™·æ¨™è¨˜åˆ°æœ¬åœ°å­˜å„²
            if (typeof saveDefectMarksToStorage === 'function') {
                saveDefectMarksToStorage();
            }
            
            // é‡æ–°æ¸²æŸ“ç¼ºé™·æ¨™è¨˜
            if (typeof window.redrawDefectMarks === 'function') {
                window.redrawDefectMarks();
            }
        }
    }
    
    // åŒæ­¥åˆªé™¤å°æ‡‰çš„æ¨™ç±¤ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    if (window.labels && window.labels.length > 0) {
        const labelIndex = window.labels.findIndex(label => 
            String(label.defectNo) === String(defectNo)
        );
        
        if (labelIndex >= 0) {
            window.labels.splice(labelIndex, 1);
            window.logger.log('Deleted corresponding label:', defectNo);
            
            // ä¿å­˜æ¨™ç±¤åˆ°æœ¬åœ°å­˜å„²
            if (typeof window.saveLabelsToStorage === 'function') {
                window.saveLabelsToStorage();
            }
            
            // é‡æ–°æ¸²æŸ“æ¨™ç±¤
            if (typeof window.redrawLabels === 'function') {
                window.redrawLabels();
            }
        }
    }
    
    // ä¿å­˜æ•¸æ“šåˆ°æœ¬åœ°å­˜å„²
    saveDataToStorage();
    
    // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼
    if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
    
    // æ›´æ–°ç¼ºé™·åˆ†é¡å…§å®¹é¡¯ç¤º
    updateCategoryDisplay('j');
    
    // åŒæ­¥åˆ° labels detail-table-containerï¼ˆæª¢æŸ¥æ¨™ç±¤çš„ç¼ºé™·åˆ—è®ŠåŒ–ï¼‰
    syncDefectsToLabelsDetailTable();
    
    // é‡æ–°æ’åˆ—ç¼ºé™·ç·¨è™Ÿ
    renumberDefectEntries();
    
    showNotification(`ç¼ºé™·è¨˜éŒ„ ${defectNo} å·²åˆªé™¤`, 'success');
}

// æª¢æ¸¬æ˜¯å¦åœ¨ç¹ªåœ–æ¨¡å¼
function isDrawingMode() {
    const floorPlanCanvas = document.getElementById('floorPlanCanvas');
    const floorPlanViewer = document.getElementById('floorPlanViewer');
    const hasPDFData = localStorage.getItem('pne_floorplan_data') || localStorage.getItem('pne_floorplan_base64');
    const hasLabels = localStorage.getItem('pne_floorplan_labels');
    
    // æª¢æŸ¥PDFæ˜¯å¦å·²è¼‰å…¥ä¸”ç•«å¸ƒæœ‰å…§å®¹
    const isCanvasLoaded = floorPlanCanvas && floorPlanCanvas.width > 0 && floorPlanCanvas.height > 0;
    const isViewerVisible = floorPlanViewer && floorPlanViewer.style.display !== 'none';
    const hasPDFLoaded = isCanvasLoaded && isViewerVisible;
    
    // ç¹ªåœ–æ¨¡å¼ï¼šPDFå·²è¼‰å…¥ä¸”æœ‰æ¨™ç±¤æ•¸æ“š
    const isDrawingMode = hasPDFLoaded && (hasPDFData || hasLabels);
    
    window.logger.log('Drawing mode detection:', {
        isCanvasLoaded,
        isViewerVisible,
        hasPDFLoaded,
        hasPDFData: !!hasPDFData,
        hasLabels: !!hasLabels,
        isDrawingMode
    });
    
    return isDrawingMode;
}

// åˆªé™¤æ¨™ç±¤å‡½æ•¸
function deleteLabel(labelId) {
    window.logger.log('Deleting label:', labelId);
    
    // æª¢æ¸¬æ˜¯å¦åœ¨ç¹ªåœ–æ¨¡å¼
    const drawingMode = isDrawingMode();
    window.logger.log('Delete label - Drawing mode:', drawingMode);
    
    // æ‰¾åˆ°å°æ‡‰çš„æ¨™ç±¤
    const labelIndex = window.labels.findIndex(label => String(label.id) === String(labelId));
    
    if (labelIndex >= 0) {
        const label = window.labels[labelIndex];
        const defectNo = label.defectNo;
        
        // åœ¨åˆªé™¤æ¨™ç±¤å‰ï¼Œå…ˆæ¸…ç†ç›¸é—œçš„ç…§ç‰‡åˆ†é…è¨˜éŒ„
        cleanupPhotoAssignmentsOnLabelDelete(label);
        
        // å¾æ¨™ç±¤æ•¸çµ„ä¸­åˆªé™¤
        window.labels.splice(labelIndex, 1);
        
        // ä¿å­˜æ¨™ç±¤åˆ°æœ¬åœ°å­˜å„²
        if (typeof window.saveLabelsToStorage === 'function') {
            window.saveLabelsToStorage();
        }
        
        // åªåœ¨ç¹ªåœ–æ¨¡å¼ä¸‹é‡æ–°æ¸²æŸ“æ¨™ç±¤ï¼ˆå› ç‚ºéç¹ªåœ–æ¨¡å¼ä¸‹æ²’æœ‰åœ°åœ–é¡¯ç¤ºï¼‰
        if (drawingMode && typeof window.redrawLabels === 'function') {
            window.redrawLabels();
        }
        
        // åŒæ­¥æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼ï¼ˆåªé¡¯ç¤ºï¼‰
        if (typeof window.syncLabelsToInspectionRecords === 'function') {
            window.syncLabelsToInspectionRecords();
        }
        
        // åŒæ­¥åˆ° defects detail-table-containerï¼ˆæª¢æŸ¥ç¼ºé™·è¨˜éŒ„çš„è®ŠåŒ–ï¼‰
        // é€™æœƒè‡ªå‹•è™•ç†ç¼ºé™·è¨˜éŒ„çš„åˆªé™¤å’Œæ›´æ–°
        syncLabelsToDefectsDetailTable();
        
        // åªåœ¨ç¹ªåœ–æ¨¡å¼ä¸‹åˆªé™¤å°æ‡‰çš„ç¼ºé™·æ¨™è¨˜ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (drawingMode && window.defectMarks && window.defectMarks.length > 0 && defectNo) {
            const defectMarkIndex = window.defectMarks.findIndex(mark => 
                String(mark.defectNo) === String(defectNo)
            );
            
            if (defectMarkIndex >= 0) {
                window.defectMarks.splice(defectMarkIndex, 1);
                window.logger.log('Deleted corresponding defect mark:', defectNo);
                
                // ä¿å­˜ç¼ºé™·æ¨™è¨˜åˆ°æœ¬åœ°å­˜å„²
                if (typeof saveDefectMarksToStorage === 'function') {
                    saveDefectMarksToStorage();
                }
                
                // é‡æ–°æ¸²æŸ“ç¼ºé™·æ¨™è¨˜
                if (typeof window.redrawDefectMarks === 'function') {
                    window.redrawDefectMarks();
                }
            }
        }
        
        // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼
        if (typeof window.updateDefectSummaryTable === 'function') {
            window.updateDefectSummaryTable();
            window.logger.log('Defect summary table updated after label deletion');
        }
        
        // æ›´æ–°åˆ†é¡è¡¨æ ¼
        if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
            window.updateCategoryTablesFromInspectionRecords();
            window.logger.log('Category tables updated after label deletion');
        }
        
        // ä¿å­˜æ•¸æ“šåˆ°æœ¬åœ°å­˜å„²
        if (typeof window.saveDataToStorage === 'function') {
            window.saveDataToStorage();
        }
        
        // æ ¹æ“šæ¨¡å¼é¡¯ç¤ºä¸åŒçš„æˆåŠŸè¨Šæ¯
        if (drawingMode) {
            showNotification('æ¨™ç±¤å·²åˆªé™¤ï¼ˆåŒ…å«åœ°åœ–æ¨™è¨˜ï¼‰', 'success');
        } else {
            showNotification('æ¨™ç±¤è¨˜éŒ„å·²åˆªé™¤', 'success');
        }
    } else {
        showNotification('æ‰¾ä¸åˆ°è¦åˆªé™¤çš„æ¨™ç±¤', 'error');
    }
}


// å¤šé¸åŠŸèƒ½è®Šé‡ - å­—æ®µç´šåˆ¥é¸æ“‡
let selectedCells = new Set();
let lastSelectedCell = null;
let isMultiSelectMode = false;
let currentTable = null;

// åˆå§‹åŒ–å¤šé¸åŠŸèƒ½
function initMultiSelect() {
    // ç‚ºæ¨™ç±¤è©³ç´°è¡¨æ ¼æ·»åŠ å¤šé¸åŠŸèƒ½
    const labelsTable = document.getElementById('labelsDetailTable');
    if (labelsTable) {
        labelsTable.addEventListener('click', handleTableClick);
    }

    // ç‚ºç¼ºé™·è©³ç´°è¡¨æ ¼æ·»åŠ å¤šé¸åŠŸèƒ½
    const defectsTable = document.getElementById('defectsDetailTable');
    if (defectsTable) {
        defectsTable.addEventListener('click', handleTableClick);
    }

    // å¤šé¸æŒ‰éˆ•å·²ç§»é™¤ï¼Œä¸å†éœ€è¦ç¶å®šæŒ‰éˆ•äº‹ä»¶
}

// è™•ç†è¡¨æ ¼é»æ“Šäº‹ä»¶ - å­—æ®µç´šåˆ¥é¸æ“‡
function handleTableClick(event) {
    const cell = event.target.closest('td');
    if (!cell || cell.closest('thead')) {
        return;
    }

    const table = event.target.closest('table');
    if (!table) return;

    // æª¢æŸ¥æ˜¯å¦é»æ“Šäº†æŒ‰éˆ•æˆ–å…¶ä»–éå­—æ®µäº¤äº’å…ƒç´ 
    const isNonFieldElement = event.target.tagName === 'BUTTON' ||
                            event.target.closest('button') ||
                            event.target.closest('.multiselect-btn') ||
                            event.target.closest('.action-buttons');
    if (isNonFieldElement) {
        return;
    }

    // æª¢æŸ¥æ˜¯å¦åˆ‡æ›äº†è¡¨æ ¼
    if (currentTable !== table) {
        clearAllSelections();
        currentTable = table;
    }

    event.preventDefault();
    event.stopPropagation();

    const isShiftClick = event.shiftKey;
    const isCtrlClick = event.ctrlKey || event.metaKey; // æ”¯æŒ Mac çš„ Command éµ

    if (isShiftClick && lastSelectedCell && currentTable === table) {
        // Shift + é»æ“Šï¼šé¸æ“‡ç¯„åœï¼ˆé€£çºŒé¸æ“‡ï¼‰
        selectCellRange(lastSelectedCell, cell);
    } else if (isCtrlClick) {
        // Ctrl/Cmd + é»æ“Šï¼šåˆ‡æ›é¸æ“‡ç‹€æ…‹ï¼ˆå¤šé¸ï¼‰
        toggleCellSelection(cell);
    } else {
        // æ™®é€šé»æ“Šï¼šæ¸…é™¤å…¶ä»–é¸æ“‡ï¼Œåªé¸æ“‡ç•¶å‰å­—æ®µ
        clearAllSelections();
        selectCell(cell);
    }

    updateMultiSelectUI();
}

// é¸æ“‡å–®å€‹å­—æ®µ
function selectCell(cell) {
    cell.classList.add('selected');
    selectedCells.add(cell);
    lastSelectedCell = cell;
}

// å–æ¶ˆé¸æ“‡å–®å€‹å­—æ®µ
function deselectCell(cell) {
    cell.classList.remove('selected', 'multi-select-range');
    selectedCells.delete(cell);
    if (lastSelectedCell === cell) {
        lastSelectedCell = null;
    }
}

// åˆ‡æ›å­—æ®µé¸æ“‡ç‹€æ…‹
function toggleCellSelection(cell) {
    if (cell.classList.contains('selected')) {
        deselectCell(cell);
    } else {
        selectCell(cell);
    }
}

// é¸æ“‡å­—æ®µç¯„åœï¼ˆæ”¯æŒå‚ç›´å’Œæ°´å¹³æ–¹å‘ï¼‰
function selectCellRange(startCell, endCell) {
    const table = startCell.closest('table');
    const startRow = startCell.closest('tr');
    const endRow = endCell.closest('tr');
    
    const startRowIndex = Array.from(table.querySelectorAll('tbody tr')).indexOf(startRow);
    const endRowIndex = Array.from(table.querySelectorAll('tbody tr')).indexOf(endRow);
    const startCellIndex = Array.from(startRow.children).indexOf(startCell);
    const endCellIndex = Array.from(endRow.children).indexOf(endCell);
    
    if (startRowIndex === -1 || endRowIndex === -1 || startCellIndex === -1 || endCellIndex === -1) return;

    const minRowIndex = Math.min(startRowIndex, endRowIndex);
    const maxRowIndex = Math.max(startRowIndex, endRowIndex);
    const minCellIndex = Math.min(startCellIndex, endCellIndex);
    const maxCellIndex = Math.max(startCellIndex, endCellIndex);

    // æ¸…é™¤ç¯„åœé¸æ“‡æ¨£å¼
    selectedCells.forEach(cell => cell.classList.remove('multi-select-range'));

    // é¸æ“‡ç¯„åœå…§çš„æ‰€æœ‰å­—æ®µ
    const rows = Array.from(table.querySelectorAll('tbody tr'));
    for (let rowIndex = minRowIndex; rowIndex <= maxRowIndex; rowIndex++) {
        const row = rows[rowIndex];
        const cells = Array.from(row.children);
        
        for (let cellIndex = minCellIndex; cellIndex <= maxCellIndex; cellIndex++) {
            if (cells[cellIndex]) {
                const cell = cells[cellIndex];
                selectCell(cell);
                
                // æ¨™è¨˜ç¯„åœå…§çš„å­—æ®µï¼ˆé™¤äº†èµ·å§‹å’ŒçµæŸå­—æ®µï¼‰
                if (!(rowIndex === startRowIndex && cellIndex === startCellIndex) &&
                    !(rowIndex === endRowIndex && cellIndex === endCellIndex)) {
                    cell.classList.add('multi-select-range');
                }
            }
        }
    }
}

// æ¸…é™¤æ‰€æœ‰é¸æ“‡
function clearAllSelections() {
    selectedCells.forEach(cell => {
        cell.classList.remove('selected', 'multi-select-range');
    });
    selectedCells.clear();
    lastSelectedCell = null;
}

// æ›´æ–°å¤šé¸UIï¼ˆç°¡åŒ–ç‰ˆæœ¬ï¼Œåƒ…ç”¨æ–¼èª¿è©¦ï¼‰
function updateMultiSelectUI() {
    const count = selectedCells.size;
    window.logger.log('Selected cells count:', count);
    // å¤šé¸æŒ‰éˆ•å·²ç§»é™¤ï¼Œæ­¤å‡½æ•¸ä¿ç•™ç”¨æ–¼èª¿è©¦
}

// è¤‡è£½é¸ä¸­çš„å­—æ®µå…§å®¹ - é™åˆ¶åªèƒ½è¤‡è£½å–®å€‹ td
function copySelectedCells() {
    if (selectedCells.size === 0) return;
    
    // é™åˆ¶åªèƒ½è¤‡è£½å–®å€‹ td
    if (selectedCells.size > 1) {
        showNotification('è¤‡è£½åŠŸèƒ½åªèƒ½åœ¨å–®å€‹å„²å­˜æ ¼ä¸­ä½¿ç”¨', 'warning');
        return;
    }
    
    const cell = Array.from(selectedCells)[0];
    const input = cell.querySelector('input, textarea, select');
    const cellValue = input ? input.value || '' : cell.textContent.trim() || '';
    
    // å°‡æ•¸æ“šå­˜å„²åˆ°å‰ªè²¼æ¿
    window.copiedCellData = [cellValue];
    
    // å˜—è©¦ä½¿ç”¨ Clipboard API
    if (navigator.clipboard && window.ClipboardItem) {
        navigator.clipboard.writeText(cellValue).catch(() => {
            // å¦‚æœ Clipboard API å¤±æ•—ï¼Œä½¿ç”¨å­˜å„²çš„æ•¸æ“š
            window.logger.log('Copied data stored in window.copiedCellData');
        });
    }
    
    showNotification('å·²è¤‡è£½å„²å­˜æ ¼å…§å®¹', 'success');
}

// ç²˜è²¼åˆ°é¸ä¸­çš„å­—æ®µ
function pasteToSelectedCells() {
    if (selectedCells.size === 0) return;
    
    // å„ªå…ˆä½¿ç”¨å­˜å„²çš„æ•¸æ“šï¼Œé¿å…ç€è¦½å™¨è¨±å¯æç¤º
    if (window.copiedCellData) {
        pasteDataToCells(window.copiedCellData.join('\t'));
    } else {
        // å¦‚æœæ²’æœ‰å­˜å„²çš„æ•¸æ“šï¼Œå˜—è©¦å¾ Clipboard API è®€å–
        if (navigator.clipboard && window.ClipboardItem) {
            navigator.clipboard.readText().then(text => {
                pasteDataToCells(text);
            }).catch(() => {
                showNotification('æ²’æœ‰å¯ç²˜è²¼çš„æ•¸æ“š', 'warning');
            });
        } else {
            showNotification('æ²’æœ‰å¯ç²˜è²¼çš„æ•¸æ“š', 'warning');
        }
    }
}

// å°‡æ•¸æ“šç²˜è²¼åˆ°é¸ä¸­çš„å­—æ®µ
function pasteDataToCells(data) {
    const dataArray = Array.isArray(data) ? data : data.split('\t');
    if (!dataArray || dataArray.length === 0) return;

    // ä¾è¡Œã€åˆ—æ’åºç›®å‰é¸ä¸­çš„å„²å­˜æ ¼
    const sortedCells = Array.from(selectedCells).sort((a, b) => {
        const aRow = a.closest('tr');
        const bRow = b.closest('tr');
        const aRowIndex = Array.from(aRow.parentNode.children).indexOf(aRow);
        const bRowIndex = Array.from(bRow.parentNode.children).indexOf(bRow);
        if (aRowIndex !== bRowIndex) return aRowIndex - bRowIndex;
        return Array.from(aRow.children).indexOf(a) - Array.from(bRow.children).indexOf(b);
    });

    let pastedCount = 0;

    // æƒ…å¢ƒ 1ï¼šåªæœ‰ä¸€å€‹å€¼ â†’ è¤‡è£½åˆ°æ‰€æœ‰é¸å–æ¬„ä½
    if (dataArray.length === 1) {
        const value = dataArray[0];
        sortedCells.forEach(cell => {
            const input = cell.querySelector('input, textarea, select');
            if (input) {
                input.value = value;
                input.dispatchEvent(new Event('input', { bubbles: true }));
                pastedCount++;
            }
        });
        showNotification(`å·²ç²˜è²¼åˆ° ${pastedCount} å€‹å­—æ®µ`, 'success');
        return;
    }

    // æƒ…å¢ƒ 2ï¼šå¤šå€‹å€¼
    // å…ˆå¡«æ»¿å·²é¸æ¬„ä½ï¼ˆä¾åºå°æ‡‰ï¼‰
    let dataIndex = 0;
    for (let i = 0; i < sortedCells.length && dataIndex < dataArray.length; i++, dataIndex++) {
        const cell = sortedCells[i];
        const input = cell.querySelector('input, textarea, select');
        if (input) {
            input.value = dataArray[dataIndex];
            input.dispatchEvent(new Event('input', { bubbles: true }));
            pastedCount++;
        }
    }

    // è‹¥ä»æœ‰å‰©é¤˜è³‡æ–™ï¼Œå¾æœ€å¾Œä¸€å€‹é¸å–æ¬„ä½é–‹å§‹ï¼Œä¾è¡¨æ ¼é †åºé€£çºŒè²¼åˆ°ä¹‹å¾Œçš„æ¬„ä½
    if (dataIndex < dataArray.length && sortedCells.length > 0) {
        const lastCell = sortedCells[sortedCells.length - 1];
        const table = lastCell.closest('table');
        if (table) {
            // å–å¾—è¡¨æ ¼å…§æ‰€æœ‰å¯ç·¨è¼¯æ¬„ä½ï¼ˆå« input/textarea/selectï¼‰ä¾ DOM é †åº
            const allEditableCells = Array.from(table.querySelectorAll('tbody td'))
                .filter(td => td.querySelector('input, textarea, select'));

            // æ‰¾åˆ°æœ€å¾Œä¸€å€‹é¸å–æ¬„ä½æ–¼ allEditableCells çš„ç´¢å¼•
            const lastIndexInAll = allEditableCells.indexOf(lastCell);
            // å¾ä¸‹ä¸€æ ¼é–‹å§‹é€£çºŒå¡«å…¥
            for (let j = lastIndexInAll + 1; j < allEditableCells.length && dataIndex < dataArray.length; j++, dataIndex++) {
                const nextCell = allEditableCells[j];
                const input = nextCell.querySelector('input, textarea, select');
                if (input) {
                    input.value = dataArray[dataIndex];
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                    pastedCount++;
                }
            }
        }
    }

    showNotification(`å·²ç²˜è²¼åˆ° ${pastedCount} å€‹å­—æ®µ`, 'success');
}

// æ·»åŠ å‚³çµ±çš„ç²˜è²¼äº‹ä»¶ç›£è½å™¨ï¼Œé¿å…ç€è¦½å™¨è¨±å¯æç¤º
document.addEventListener('paste', function(event) {
    // æª¢æŸ¥æ˜¯å¦åœ¨æ¨™ç±¤è©³ç´°è¡¨æ ¼ä¸­
    const isInLabelsTable = event.target.closest('#labelsDetailTable');
    const isInDefectsTable = event.target.closest('#defectsDetailTable');
    
    if ((isInLabelsTable || isInDefectsTable) && selectedCells.size > 0) {
        event.preventDefault();
        
        // ç²å–ç²˜è²¼çš„æ–‡æœ¬æ•¸æ“š
        const pastedText = (event.clipboardData || window.clipboardData).getData('text');
        
        if (pastedText) {
            // å°‡ç²˜è²¼çš„æ•¸æ“šå­˜å„²åˆ°å…¨å±€è®Šé‡
            window.copiedCellData = pastedText.split('\t');
            pasteDataToCells(pastedText);
        } else {
            showNotification('æ²’æœ‰å¯ç²˜è²¼çš„æ•¸æ“š', 'warning');
        }
    }
});


// ç·¨è¼¯é¸ä¸­çš„æ¨™ç±¤å­—æ®µ
function editSelectedLabels() {
    if (selectedCells.size === 0) return;
    
    // ç²å–é¸ä¸­å­—æ®µæ‰€å±¬çš„è¡Œ
    const selectedRows = new Set();
    selectedCells.forEach(cell => {
        const row = cell.closest('tr');
        if (row) {
            selectedRows.add(row);
        }
    });
    
    if (selectedRows.size === 1) {
        // å–®å€‹è¡Œç·¨è¼¯
        const row = Array.from(selectedRows)[0];
        const labelId = row.dataset.labelId;
        if (labelId) {
            // é€™è£¡å¯ä»¥å¯¦ç¾å–®å€‹æ¨™ç±¤çš„ç·¨è¼¯é‚è¼¯
            showNotification('ç·¨è¼¯å–®å€‹æ¨™ç±¤åŠŸèƒ½', 'info');
        }
    } else {
        // æ‰¹é‡ç·¨è¼¯
        showNotification(`ç·¨è¼¯ ${selectedRows.size} å€‹æ¨™ç±¤åŠŸèƒ½`, 'info');
    }
}

// åˆªé™¤é¸ä¸­çš„æ¨™ç±¤
function deleteSelectedLabels() {
    if (selectedCells.size === 0) return;

    // ç²å–é¸ä¸­å­—æ®µæ‰€å±¬çš„è¡Œ
    const selectedRows = new Set();
    selectedCells.forEach(cell => {
        const row = cell.closest('tr');
        if (row) {
            selectedRows.add(row);
        }
    });

    const count = selectedRows.size;
    if (!confirm(`ç¢ºå®šè¦åˆªé™¤é¸ä¸­çš„ ${count} å€‹æ¨™ç±¤å—ï¼Ÿ`)) {
        return;
    }

    const rowsToDelete = Array.from(selectedRows);
    rowsToDelete.forEach(row => {
        const labelId = row.dataset.labelId;
        if (labelId && typeof deleteLabel === 'function') {
            deleteLabel(labelId);
        }
    });

    clearAllSelections();
    updateMultiSelectUI();
    
    // åŒæ­¥æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼
    syncLabelsToInspectionRecords();
    
    // æ›´æ–°åˆ†é¡è¡¨æ ¼
    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}
    
    showNotification(`å·²åˆªé™¤ ${count} å€‹æ¨™ç±¤`, 'success');
}

// ç·¨è¼¯é¸ä¸­çš„ç¼ºé™·å­—æ®µ
function editSelectedDefects() {
    if (selectedCells.size === 0) return;
    
    // ç²å–é¸ä¸­å­—æ®µæ‰€å±¬çš„è¡Œ
    const selectedRows = new Set();
    selectedCells.forEach(cell => {
        const row = cell.closest('tr');
        if (row) {
            selectedRows.add(row);
        }
    });
    
    if (selectedRows.size === 1) {
        // å–®å€‹è¡Œç·¨è¼¯
        const row = Array.from(selectedRows)[0];
        const defectId = row.dataset.defectId;
        const defectNo = row.dataset.defectNo;
        if (defectId && defectNo && typeof editDefectRecord === 'function') {
            editDefectRecord(defectId, defectNo);
        }
    } else {
        // æ‰¹é‡ç·¨è¼¯
        showNotification(`ç·¨è¼¯ ${selectedRows.size} å€‹ç¼ºé™·åŠŸèƒ½`, 'info');
    }
}

// åˆªé™¤é¸ä¸­çš„ç¼ºé™·
function deleteSelectedDefects() {
    if (selectedCells.size === 0) return;

    // ç²å–é¸ä¸­å­—æ®µæ‰€å±¬çš„è¡Œ
    const selectedRows = new Set();
    selectedCells.forEach(cell => {
        const row = cell.closest('tr');
        if (row) {
            selectedRows.add(row);
        }
    });

    const count = selectedRows.size;
    if (!confirm(`ç¢ºå®šè¦åˆªé™¤é¸ä¸­çš„ ${count} å€‹ç¼ºé™·å—ï¼Ÿ`)) {
        return;
    }

    const rowsToDelete = Array.from(selectedRows);
    rowsToDelete.forEach(row => {
        const defectId = row.dataset.defectId;
        const defectNo = row.dataset.defectNo;
        if (defectId && defectNo && typeof deleteDefectRecord === 'function') {
            deleteDefectRecord(defectId, defectNo);
        }
    });

    clearAllSelections();
    updateMultiSelectUI();
    showNotification(`å·²åˆªé™¤ ${count} å€‹ç¼ºé™·`, 'success');
}

// éµç›¤äº‹ä»¶è™•ç†
document.addEventListener('keydown', function(event) {
    // ESCéµæ¸…é™¤æ‰€æœ‰é¸æ“‡
    if (event.key === 'Escape' && selectedCells.size > 0) {
        clearAllSelections();
        updateMultiSelectUI();
        event.preventDefault();
    }
    
    // è¤‡è£½åŠŸèƒ½ (Ctrl+C æˆ– Cmd+C)
    if ((event.ctrlKey || event.metaKey) && event.key === 'c' && selectedCells.size > 0) {
        copySelectedCells();
        event.preventDefault();
    }
    
    // ç²˜è²¼åŠŸèƒ½ (Ctrl+V æˆ– Cmd+V)
    if ((event.ctrlKey || event.metaKey) && event.key === 'v' && selectedCells.size > 0) {
        pasteToSelectedCells();
        event.preventDefault();
    }
});

// åœ¨é é¢è¼‰å…¥æ™‚åˆå§‹åŒ–å¤šé¸åŠŸèƒ½
document.addEventListener('DOMContentLoaded', function() {
    initMultiSelect();
    
    // Add event listener for "Got it" button in defect mark reminder popup
    const gotItBtn = document.getElementById('gotItBtn');
    if (gotItBtn) {
        gotItBtn.addEventListener('click', function() {
            window.logger.log('Got it button clicked');
            hideDefectMarkReminder();
        });
    }
    
    // åˆå§‹åŒ–å¯¦æ™‚è¼¸å…¥ç›£è½å™¨
    initRealtimeInputListeners();
});

// è‡ªå‹•ä¿å­˜åŠŸèƒ½ - å…¨å±€å‡½æ•¸
function addAutoSaveListeners(type) {
    const tableBody = type === 'labels' ? 
        document.getElementById('labelsDetailTableBody') : 
        document.getElementById('defectsDetailTableBody');
    
    if (!tableBody) return;
    
    // ç‚ºæ‰€æœ‰è¼¸å…¥å­—æ®µæ·»åŠ äº‹ä»¶ç›£è½å™¨
    const inputs = tableBody.querySelectorAll('input[data-field], textarea[data-field]');
    
    inputs.forEach(input => {
        // ç§»é™¤ç¾æœ‰çš„äº‹ä»¶ç›£è½å™¨ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
        input.removeEventListener('input', handleAutoSave);
        input.removeEventListener('change', handleAutoSave);
        input.removeEventListener('blur', handleAutoSave);
        
        // æ·»åŠ æ–°çš„äº‹ä»¶ç›£è½å™¨
        input.addEventListener('input', handleAutoSave);
        input.addEventListener('change', handleAutoSave);
        input.addEventListener('blur', handleAutoSave);
    });
    
    function handleAutoSave(event) {
        const input = event.target;
        const index = parseInt(input.dataset.index);
        const field = input.dataset.field;
        
        if (isNaN(index) || !field) return;
        
        // æª¢æŸ¥æ¬„ä½æ˜¯å¦ç‚ºåªè®€ï¼Œå¦‚æœæ˜¯å‰‡ä¸é€²è¡Œä¿å­˜
        if (input.readOnly) {
            return;
        }
        
        let value;
        if (input.type === 'checkbox') {
            value = input.checked;
        } else {
            value = input.value.trim();
        }
        
        // æ ¹æ“šé¡å‹æ›´æ–°ç›¸æ‡‰çš„æ•¸æ“š
        if (type === 'labels') {
            if (window.labels && window.labels[index]) {
                if (window.labels[index][field] !== value) {
                    window.labels[index][field] = value;
                    window.logger.log(`Auto-saved label ${index} field ${field}:`, value);
                    saveDataToStorage();
                    
                    // å¯¦æ™‚æ›´æ–°ç›¸é—œè¡¨æ ¼
                    updateTablesOnLabelChange();
                }
            }
        } else if (type === 'defects') {
            if (window.defectEntries && window.defectEntries[index]) {
                if (window.defectEntries[index][field] !== value) {
                    window.defectEntries[index][field] = value;
                    window.logger.log(`Auto-saved defect ${index} field ${field}:`, value);
                    saveDataToStorage();
                    
                    // å¯¦æ™‚æ›´æ–°ç›¸é—œè¡¨æ ¼
                    updateTablesOnDefectChange();
                }
            }
        }
    }
}

// å¯¦æ™‚æ›´æ–°è¡¨æ ¼å‡½æ•¸
function updateTablesOnLabelChange() {
    window.logger.log('Updating tables due to label change...');
    
    // æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼
    if (typeof window.syncLabelsToInspectionRecords === 'function') {
        window.syncLabelsToInspectionRecords();
        window.logger.log('Inspection records table updated');
    }
    
    // æ›´æ–°åˆ†é¡è¨˜éŒ„è¡¨æ ¼
    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
        window.updateCategoryTablesFromInspectionRecords();
        window.logger.log('Categories records table updated');
    }
    
    // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼ï¼ˆå¦‚æœæ¨™ç±¤è®ŠåŒ–å½±éŸ¿ç¼ºé™·æ•¸æ“šï¼‰
    if (typeof window.updateDefectSummaryTable === 'function') {
        window.updateDefectSummaryTable();
        window.logger.log('Defect summary table updated');
    }
    
    // åŒæ­¥åˆ° defects detail-table-containerï¼ˆæª¢æŸ¥ defects column çš„è®ŠåŒ–ï¼‰
    syncLabelsToDefectsDetailTable();
    
     // ç§»é™¤ï¼šä¸å†è‡ªå‹•æ›´æ–° imminent danger ç‹€æ…‹ï¼Œé˜²æ­¢æ„å¤–è®Šæ›´
     // if (typeof updateImminentDangerInInspectionRecords === 'function') {
     //     updateImminentDangerInInspectionRecords();
     //     window.logger.log('Imminent danger status updated with unified logic');
     // }
    
    // é‡æ–°æ¸²æŸ“æ¨“å±¤å¹³é¢åœ–ä¸­çš„ç¼ºé™·æ¨™è¨˜
    if (typeof window.redrawDefectMarks === 'function') {
        window.redrawDefectMarks();
        window.logger.log('Defect marks redrawn after label changes');
    }
}

// åˆå§‹åŒ–å¯¦æ™‚è¼¸å…¥ç›£è½å™¨
function initRealtimeInputListeners() {
    window.logger.log('Initializing realtime input listeners...');
    
    // ç‚ºæ¨™ç±¤è©³ç´°è¡¨æ ¼æ·»åŠ å¯¦æ™‚è¼¸å…¥ç›£è½å™¨
    const labelsDetailTable = document.getElementById('labelsDetailTableBody');
    if (labelsDetailTable) {
        // ç§»é™¤ç¾æœ‰çš„äº‹ä»¶ç›£è½å™¨ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
        labelsDetailTable.removeEventListener('input', handleLabelsRealtimeUpdate);
        labelsDetailTable.removeEventListener('change', handleLabelsRealtimeUpdate);
        
        // ä½¿ç”¨äº‹ä»¶å§”è¨—ä¾†è™•ç†å‹•æ…‹æ·»åŠ çš„è¼¸å…¥å­—æ®µ
        labelsDetailTable.addEventListener('input', handleLabelsRealtimeUpdate);
        labelsDetailTable.addEventListener('change', handleLabelsRealtimeUpdate);
        
        window.logger.log('Labels detail table realtime listeners added');
    }
    
    // ç‚ºç¼ºé™·è©³ç´°è¡¨æ ¼æ·»åŠ å¯¦æ™‚è¼¸å…¥ç›£è½å™¨
    const defectsDetailTable = document.getElementById('defectsDetailTableBody');
    if (defectsDetailTable) {
        // ç§»é™¤ç¾æœ‰çš„äº‹ä»¶ç›£è½å™¨ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
        defectsDetailTable.removeEventListener('input', handleDefectsRealtimeUpdate);
        defectsDetailTable.removeEventListener('change', handleDefectsRealtimeUpdate);
        
        // ä½¿ç”¨äº‹ä»¶å§”è¨—ä¾†è™•ç†å‹•æ…‹æ·»åŠ çš„è¼¸å…¥å­—æ®µ
        defectsDetailTable.addEventListener('input', handleDefectsRealtimeUpdate);
        defectsDetailTable.addEventListener('change', handleDefectsRealtimeUpdate);
        
        window.logger.log('Defects detail table realtime listeners added');
    }
    
    window.logger.log('Realtime input listeners initialized successfully');
}

// æ¨™ç±¤å¯¦æ™‚æ›´æ–°è™•ç†å‡½æ•¸
function handleLabelsRealtimeUpdate(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
        // æª¢æŸ¥æ˜¯å¦æ˜¯æœ‰ data-field å±¬æ€§çš„è¼¸å…¥å­—æ®µï¼ˆé¿å…èˆ‡è‡ªå‹•ä¿å­˜ç›£è½å™¨è¡çªï¼‰
        if (e.target.dataset.field) {
            window.logger.log('Label detail table realtime update:', e.target.dataset.field);
            
            // å»¶é²åŸ·è¡Œä»¥é¿å…é »ç¹æ›´æ–°
            clearTimeout(window.labelRealtimeUpdateTimeout);
            window.labelRealtimeUpdateTimeout = setTimeout(() => {
                updateTablesOnLabelChange();
            }, 500); // 500ms å»¶é²ï¼Œæ¯”è‡ªå‹•ä¿å­˜çš„300msç¨é•·
        }
    }
}

// ç¼ºé™·å¯¦æ™‚æ›´æ–°è™•ç†å‡½æ•¸
function handleDefectsRealtimeUpdate(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
        // æª¢æŸ¥æ˜¯å¦æ˜¯æœ‰ data-field å±¬æ€§çš„è¼¸å…¥å­—æ®µï¼ˆé¿å…èˆ‡è‡ªå‹•ä¿å­˜ç›£è½å™¨è¡çªï¼‰
        if (e.target.dataset.field) {
            window.logger.log('Defect detail table realtime update:', e.target.dataset.field);
            
            // å»¶é²åŸ·è¡Œä»¥é¿å…é »ç¹æ›´æ–°
            clearTimeout(window.defectRealtimeUpdateTimeout);
            window.defectRealtimeUpdateTimeout = setTimeout(() => {
                updateTablesOnDefectChange();
            }, 500); // 500ms å»¶é²ï¼Œæ¯”è‡ªå‹•ä¿å­˜çš„300msç¨é•·
        }
    }
}

function updateTablesOnDefectChange() {
    window.logger.log('Updating tables due to defect change...');
    
    // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼
    if (typeof window.updateDefectSummaryTable === 'function') {
        window.updateDefectSummaryTable();
        window.logger.log('Defect summary table updated');
    }
    
    // æ›´æ–°åˆ†é¡è¨˜éŒ„è¡¨æ ¼
    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
        window.updateCategoryTablesFromInspectionRecords();
        window.logger.log('Categories records table updated');
    }
    
    // æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼ï¼ˆå¦‚æœç¼ºé™·è®ŠåŒ–å½±éŸ¿æª¢æŸ¥è¨˜éŒ„ï¼‰
    if (typeof window.syncLabelsToInspectionRecords === 'function') {
        window.syncLabelsToInspectionRecords();
        window.logger.log('Inspection records table updated');
    }
    
    // åŒæ­¥åˆ° labels detail-table-containerï¼ˆæª¢æŸ¥ defects column çš„è®ŠåŒ–ï¼‰
    syncDefectsToLabelsDetailTable();
    
     // ç§»é™¤ï¼šä¸å†è‡ªå‹•æ›´æ–° imminent danger ç‹€æ…‹ï¼Œé˜²æ­¢æ„å¤–è®Šæ›´
     // if (typeof updateImminentDangerInInspectionRecords === 'function') {
     //     updateImminentDangerInInspectionRecords();
     //     window.logger.log('Imminent danger status updated with unified logic');
     // }
    
    // é‡æ–°æ¸²æŸ“æ¨“å±¤å¹³é¢åœ–ä¸­çš„ç¼ºé™·æ¨™è¨˜
    if (typeof window.redrawDefectMarks === 'function') {
        window.redrawDefectMarks();
        window.logger.log('Defect marks redrawn after defect changes');
    }
}

// å¦‚æœDOMå·²ç¶“è¼‰å…¥ï¼Œç«‹å³åˆå§‹åŒ–
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMultiSelect);
} else {
    initMultiSelect();
}

// å¾è©³ç´°è¡¨æ ¼ä¸­åˆªé™¤æ¨™ç±¤è¨˜éŒ„
window.deleteLabelFromDetailTable = function(labelId, index) {
    window.logger.log('Deleting label from detail table:', labelId, index);
    
    // æª¢æ¸¬æ˜¯å¦åœ¨ç¹ªåœ–æ¨¡å¼
    const drawingMode = isDrawingMode();
    window.logger.log('Delete label from detail table - Drawing mode:', drawingMode);
    
    // æ ¹æ“šæ¨¡å¼é¡¯ç¤ºä¸åŒçš„ç¢ºèªè¨Šæ¯
    let confirmMessage;
    if (drawingMode) {
        confirmMessage = 'ç¢ºå®šè¦åˆªé™¤é€™å€‹æ¨™ç±¤è¨˜éŒ„å—ï¼Ÿæ­¤æ“ä½œå°‡åŒæ™‚åˆªé™¤æ¨“å±¤å¹³é¢åœ–ä¸­å°æ‡‰çš„æ¨™ç±¤å’Œæ‰€æœ‰ç›¸é—œçš„ç¼ºé™·è¨˜éŒ„ã€‚';
    } else {
        confirmMessage = 'ç¢ºå®šè¦åˆªé™¤é€™å€‹æ¨™ç±¤è¨˜éŒ„å—ï¼Ÿæ­¤æ“ä½œå°‡åŒæ™‚åˆªé™¤æ‰€æœ‰ç›¸é—œçš„ç¼ºé™·è¨˜éŒ„ã€‚';
    }
    
    if (!confirm(confirmMessage)) {
        return;
    }
    
    // æ‰¾åˆ°å°æ‡‰çš„æ¨™ç±¤
    const labelIndex = window.labels.findIndex(label => String(label.id) === String(labelId));
    
    if (labelIndex >= 0) {
        const label = window.labels[labelIndex];
        
        // æ”¶é›†æ‰€æœ‰ç›¸é—œçš„ç¼ºé™·ç·¨è™Ÿ
        const defectNosToDelete = [];
        
        // æª¢æŸ¥ label.defectNo å­—æ®µï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (label.defectNo) {
            defectNosToDelete.push(String(label.defectNo));
        }
        
        // æª¢æŸ¥ label.j å­—æ®µä¸­çš„ç¼ºé™·ç·¨è™Ÿ
        if (label.j && label.j.trim()) {
            const defectsArray = label.j.split('\n').filter(d => d.trim());
            defectsArray.forEach(defectText => {
                const defectNoMatch = defectText.match(/^(\d+)\)?\s*/);
                if (defectNoMatch) {
                    const defectNoFromJ = defectNoMatch[1];
                    if (!defectNosToDelete.includes(defectNoFromJ)) {
                        defectNosToDelete.push(defectNoFromJ);
                    }
                }
            });
        }
        
        // æª¢æŸ¥æ˜¯å¦æœ‰ç¼ºé™·è¨˜éŒ„èˆ‡æ­¤æ¨™ç±¤çš„æª¢æŸ¥ç·¨è™Ÿç›¸é—œè¯
        if (window.defectEntries && Array.isArray(window.defectEntries)) {
            window.defectEntries.forEach(defect => {
                if (String(defect.locationId) === String(label.inspectionNo)) {
                    const defectNo = String(defect.defectNo);
                    if (!defectNosToDelete.includes(defectNo)) {
                        defectNosToDelete.push(defectNo);
                        window.logger.log(`Found associated defect ${defectNo} for label ${label.inspectionNo}`);
                    }
                }
            });
        }
        
        window.logger.log('Defect numbers to delete from label:', defectNosToDelete);
        
        // å¦‚æœæœ‰ç¼ºé™·ç·¨è™Ÿï¼Œä½¿ç”¨çµ±ä¸€çš„åˆªé™¤å‡½æ•¸
        if (defectNosToDelete.length > 0) {
            defectNosToDelete.forEach(defectNoToDelete => {
                deleteDefectRecordComprehensive(defectNoToDelete, 'labels detail table');
            });
            
            // ç¼ºé™·åˆªé™¤å®Œæˆå¾Œï¼Œç¹¼çºŒåˆªé™¤æ¨™ç±¤æœ¬èº«
            // åœ¨åˆªé™¤æ¨™ç±¤å‰ï¼Œå…ˆæ¸…ç†ç›¸é—œçš„ç…§ç‰‡åˆ†é…è¨˜éŒ„
            cleanupPhotoAssignmentsOnLabelDelete(label);
            
            window.labels.splice(labelIndex, 1);
            
            // ä¿å­˜æ¨™ç±¤åˆ°æœ¬åœ°å­˜å„²
            if (typeof window.saveLabelsToStorage === 'function') {
                window.saveLabelsToStorage();
            }
            
            // åªåœ¨ç¹ªåœ–æ¨¡å¼ä¸‹é‡æ–°æ¸²æŸ“æ¨™ç±¤ï¼ˆå› ç‚ºéç¹ªåœ–æ¨¡å¼ä¸‹æ²’æœ‰åœ°åœ–é¡¯ç¤ºï¼‰
            if (drawingMode && typeof window.redrawLabels === 'function') {
                window.redrawLabels();
            }
            
            // åŒæ­¥åˆ° defects detail-table-containerï¼ˆæª¢æŸ¥ç¼ºé™·è¨˜éŒ„çš„è®ŠåŒ–ï¼‰
            syncLabelsToDefectsDetailTable();
            
            // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼
            if (typeof window.updateDefectSummaryTable === 'function') {
                window.updateDefectSummaryTable();
                window.logger.log('Defect summary table updated after label deletion');
            }
            
            // æ›´æ–°åˆ†é¡è¡¨æ ¼
            if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
                window.updateCategoryTablesFromInspectionRecords();
                window.logger.log('Category tables updated after label deletion');
            }
            
            // æ›´æ–°ç…§ç‰‡ç‹€æ…‹
            if (typeof updatePhotoStatusFromLabels === 'function') {
                updatePhotoStatusFromLabels();
            }
            
            // é‡æ–°æ’åˆ—ç¼ºé™·ç·¨è™Ÿ - åœ¨æ¨™ç±¤åˆªé™¤å®Œæˆå¾Œé€²è¡Œ
            renumberDefectEntries();
            
            // é‡æ–°é¡¯ç¤ºæ¨™ç±¤è©³ç´°è¡¨æ ¼
            if (typeof window.showLabelsDetailPopup === 'function') {
                window.showLabelsDetailPopup();
            }
            
            // é¡¯ç¤ºå®Œæˆé€šçŸ¥
            showNotification(`æ¨™ç±¤è¨˜éŒ„ ${label.inspectionNo} åŠå…¶ç›¸é—œç¼ºé™·å·²å®Œå…¨åˆªé™¤`, 'success');
            
            return;
        } else {
            // å¦‚æœæ²’æœ‰ç¼ºé™·ç·¨è™Ÿï¼Œåªåˆªé™¤æ¨™ç±¤
            // åœ¨åˆªé™¤æ¨™ç±¤å‰ï¼Œå…ˆæ¸…ç†ç›¸é—œçš„ç…§ç‰‡åˆ†é…è¨˜éŒ„
            cleanupPhotoAssignmentsOnLabelDelete(label);
            
            window.labels.splice(labelIndex, 1);
            
            // ä¿å­˜æ¨™ç±¤åˆ°æœ¬åœ°å­˜å„²
            if (typeof window.saveLabelsToStorage === 'function') {
                window.saveLabelsToStorage();
            }
            
            // åªåœ¨ç¹ªåœ–æ¨¡å¼ä¸‹é‡æ–°æ¸²æŸ“æ¨™ç±¤ï¼ˆå› ç‚ºéç¹ªåœ–æ¨¡å¼ä¸‹æ²’æœ‰åœ°åœ–é¡¯ç¤ºï¼‰
            if (drawingMode && typeof window.redrawLabels === 'function') {
                window.redrawLabels();
            }
            
            // åŒæ­¥åˆ° defects detail-table-containerï¼ˆæª¢æŸ¥ç¼ºé™·è¨˜éŒ„çš„è®ŠåŒ–ï¼‰
            // é€™æœƒè‡ªå‹•è™•ç†ç¼ºé™·è¨˜éŒ„çš„åˆªé™¤å’Œæ›´æ–°
            syncLabelsToDefectsDetailTable();
            
            // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼
            if (typeof window.updateDefectSummaryTable === 'function') {
                window.updateDefectSummaryTable();
                window.logger.log('Defect summary table updated after label deletion');
            }
            
            // æ›´æ–°åˆ†é¡è¡¨æ ¼
            if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
                window.updateCategoryTablesFromInspectionRecords();
                window.logger.log('Category tables updated after label deletion');
            }
            
            // æ›´æ–°ç…§ç‰‡ç‹€æ…‹
            if (typeof updatePhotoStatusFromLabels === 'function') {
                updatePhotoStatusFromLabels();
            }
            
            // é‡æ–°æ’åˆ—ç¼ºé™·ç·¨è™Ÿ - åœ¨æ¨™ç±¤åˆªé™¤å®Œæˆå¾Œé€²è¡Œ
            renumberDefectEntries();
            
            // é‡æ–°é¡¯ç¤ºæ¨™ç±¤è©³ç´°è¡¨æ ¼
            if (typeof window.showLabelsDetailPopup === 'function') {
                window.showLabelsDetailPopup();
            }
        }
    } else {
        showNotification('æ‰¾ä¸åˆ°è¦åˆªé™¤çš„æ¨™ç±¤è¨˜éŒ„', 'error');
    }
}

// å¾è©³ç´°è¡¨æ ¼ä¸­åˆªé™¤ç¼ºé™·è¨˜éŒ„ - å·²ç¦ç”¨ç”¨æˆ¶æ‰‹å‹•åˆªé™¤
// ç¼ºé™·è¨˜éŒ„åªèƒ½ç”±ç³»çµ±åœ¨åˆªé™¤æ¨™ç±¤æ™‚è‡ªå‹•åˆªé™¤
window.deleteDefectFromDetailTable = function(defectId, defectNo, index) {
    window.logger.log('User attempted to delete defect from detail table - operation blocked');
    showNotification('ç¼ºé™·è¨˜éŒ„åªèƒ½é€šéåˆªé™¤ç›¸é—œæ¨™ç±¤ä¾†ç§»é™¤', 'info');
}

// Save data to storage (with fallback) - èˆ‡ .pne æª”æ¡ˆæ ¼å¼å®Œå…¨ä¸€è‡´
window.saveDataToStorage = async function() {
    // æ”¶é›† header æ¬„ä½
    const headerFields = {
        inspectionNo: (document.getElementById('locationId') || {}).value || '',
        inspectionDate: (document.getElementById('inspectionDate') || {}).value || '',
        floor: (document.getElementById('floorHeader') || {}).value || '',
        areaName: (document.getElementById('areaNameHeader') || {}).value || '',
        roomNo: (document.getElementById('roomNo') || {}).value || '',
                sortEnabled: !!(document.getElementById('sortPhotosToFolder') && document.getElementById('sortPhotosToFolder').checked)
    };

    // æ”¶é›† localStorage å…§å®¹ï¼ˆé¿å… {...localStorage} åœ¨éƒ¨åˆ†ç€è¦½å™¨å–ä¸åˆ°è³‡æ–™ï¼‰
    const localStorageData = {};
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        localStorageData[key] = localStorage.getItem(key);
    }

    // å®‰å…¨å–å¾—æ¨“å±¤å¹³é¢æ¨™ç±¤/ç¼ºé™·æ¨™è¨˜ï¼ˆé¿å…æœªå®£å‘Šè®Šæ•¸ ReferenceErrorï¼‰
    const floorPlanLabels = (typeof labels !== 'undefined' && Array.isArray(labels))
        ? labels
        : (typeof window !== 'undefined' && Array.isArray(window.labels) ? window.labels : []);
    const floorPlanDefectMarks = (typeof defectMarks !== 'undefined' && Array.isArray(defectMarks))
        ? defectMarks
        : (typeof window !== 'undefined' && Array.isArray(window.defectMarks) ? window.defectMarks : []);

    const dataToSave = {
        // ç‰ˆæœ¬èˆ‡æ™‚é–“ - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        version: '7.1.0',
        exportDate: new Date().toISOString(),
        lastSaved: new Date().toISOString(),

        // Header/UI ç‹€æ…‹ - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        headerFields: headerFields,

        // æª”æ¡ˆè·¯å¾‘è³‡è¨Š - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        filePaths: {
            // PDF æª”æ¡ˆè·¯å¾‘ï¼ˆæ¨“å±¤å¹³é¢åœ–ï¼‰- åªä¿å­˜æ–‡ä»¶å¼•ç”¨
            pdfPath: localStorage.getItem('pne_floorplan_filename') || '',
            pdfData: localStorage.getItem('pne_floorplan_data') || '',
            pdfFileReference: (() => {
                try {
                    const floorPlanData = JSON.parse(localStorage.getItem('pne_floorplan_data') || '{}');
                    return floorPlanData.fileReference || null;
                } catch (e) {
                    return null;
                }
            })(),
            
            // ç…§ç‰‡è³‡æ–™å¤¾è·¯å¾‘
            photoFolderPath: (document.getElementById('folderNameDisplay') && document.getElementById('folderNameDisplay').textContent) || '',
            photoFolderName: (document.getElementById('folderNameDisplay') && document.getElementById('folderNameDisplay').textContent.split('/').pop()) || '',
            
            // ç…§ç‰‡æª”æ¡ˆè·¯å¾‘åˆ—è¡¨
            photoFilePaths: (allPhotos || []).map(file => ({
                name: file.name,
                webkitRelativePath: file.webkitRelativePath || '',
                fullPath: file.webkitRelativePath ? `${(document.getElementById('folderNameDisplay') && document.getElementById('folderNameDisplay').textContent) || ''}/${file.webkitRelativePath}` : file.name
            }))
        },

        // æ–‡ä»¶å¼•ç”¨ç³»çµ± - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        files: (() => {
            const files = [];
            
            // æ·»åŠ  PDF æ–‡ä»¶å¼•ç”¨
            const pdfFilename = localStorage.getItem('pne_floorplan_filename');
            const pdfData = localStorage.getItem('pne_floorplan_data');
            if (pdfFilename && pdfData) {
                try {
                    const floorPlanData = JSON.parse(pdfData);
                    files.push({
                        id: 'pdf_floorplan',
                        name: pdfFilename,
                        path: pdfFilename,
                        type: 'pdf',
                        description: 'æ¨“å±¤å¹³é¢åœ– PDF æ–‡ä»¶',
                        uploadDate: floorPlanData.uploadDate || new Date().toISOString(),
                        size: `${(floorPlanData.fileSize / 1024 / 1024).toFixed(2)} MB`,
                        fileReference: floorPlanData.fileReference,
                        hasBase64Data: floorPlanData.hasBase64Data || false
                    });
                } catch (e) {
                    window.logger.error('Error parsing PDF data:', e);
                }
            }
            
            // æ·»åŠ ç…§ç‰‡æ–‡ä»¶å¼•ç”¨
            (allPhotos || []).forEach((photo, index) => {
                files.push({
                    id: `photo_${index}`,
                    name: photo.name,
                    path: photo.webkitRelativePath || photo.name,
                    type: 'image',
                    description: `æª¢æŸ¥ç…§ç‰‡ - ${photo.name}`,
                    uploadDate: new Date(photo.lastModified).toISOString(),
                    size: `${(photo.size / 1024 / 1024).toFixed(2)} MB`,
                    dataURL: photo.dataURL || '',
                    webkitRelativePath: photo.webkitRelativePath || ''
                });
            });
            
            return files;
        })(),

        // ç…§ç‰‡åŸºæœ¬èˆ‡æŒ‡æ´¾çµ±è¨ˆ - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        totalPhotos: (allPhotos || []).length,
        totalAssignments: Object.values(assignedPhotos || {}).reduce((sum, photos) => sum + photos.size, 0),
        photoMetadata: (allPhotos || []).map(file => {
            // å¦‚æœæ²’æœ‰ dataURLï¼Œå˜—è©¦å¾ DOM ä¸­ç²å–
            let dataURL = file.dataURL || '';
            if (!dataURL) {
                const photoItem = document.querySelector(`[data-filename="${file.name}"]`);
                if (photoItem) {
                    const img = photoItem.querySelector('img');
                    if (img && img.src && img.src.startsWith('data:')) {
                        dataURL = img.src;
                    }
                }
            }
            
            // èª¿è©¦ï¼šç¢ºä¿ dataURL æ˜¯å­—ç¬¦ä¸²ä¸”ä¸ç‚ºç©º
            if (dataURL && typeof dataURL !== 'string') {
                console.warn('âš ï¸ dataURL is not a string for', file.name, '- type:', typeof dataURL);
                dataURL = '';
            }
            
            // ç¢ºä¿ dataURL æ˜¯æœ‰æ•ˆçš„ base64 åœ–ç‰‡æ•¸æ“š
            if (dataURL && !dataURL.startsWith('data:image/')) {
                console.warn('âš ï¸ Invalid dataURL format for', file.name, '- prefix:', dataURL.substring(0, 20));
                dataURL = '';
            }
            
            // å‰µå»ºç´” JavaScript å°è±¡ï¼ˆä¸æ˜¯ File å°è±¡ï¼‰ï¼Œç¢ºä¿å¯ä»¥æ­£ç¢ºåºåˆ—åŒ–
            const photoMetadata = {
                name: file.name,
                size: file.size,
                type: file.type,
                lastModified: file.lastModified || Date.now(),
                webkitRelativePath: file.webkitRelativePath || '',
                dataURL: dataURL
            };
            
            // èª¿è©¦ï¼šé©—è­‰ dataURL é•·åº¦
            if (dataURL) {
                console.log(`ğŸ“¸ Saving ${file.name} with dataURL length: ${dataURL.length}`);
            } else {
                console.warn(`âš ï¸ ${file.name} has NO dataURL!`);
            }
            
            return photoMetadata;
        }),

        // ä¸»è³‡æ–™è¡¨ - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        inspectionRecords: submittedData || [],
        submittedDefectEntries: submittedDefectEntries || [],
        rowIdCounter: rowIdCounter || 0,
        categories: categories || [],
        defectTypes: defectTypes || [],

        // ç…§ç‰‡åˆ†é…è³‡æ–™ - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        photoAssignments: (() => {
            const assignedPhotosArray = Object.fromEntries(
                Object.entries(assignedPhotos || {}).map(([key, value]) => [key, Array.from(value || [])])
            );
            const totalAssigned = Object.values(assignedPhotosArray).reduce((sum, arr) => sum + arr.length, 0);
            console.log('ğŸ’¾ saveDataToStorage - assignedPhotos:', {
                totalCategories: Object.keys(assignedPhotosArray).length,
                totalAssignedPhotos: totalAssigned,
                categoriesWithPhotos: Object.keys(assignedPhotosArray).filter(k => assignedPhotosArray[k] && assignedPhotosArray[k].length > 0),
                assignedPhotosArray
            });
            return {
                categoryNumbers: categoryNumbers || {},
                assignedPhotos: assignedPhotosArray,
                defectEntries: window.defectEntries || []
            };
        })(),

        // App ç‹€æ…‹ - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        uploadedFolderPath: (document.getElementById('folderNameDisplay') && document.getElementById('folderNameDisplay').textContent) || '',
        submittedFilenames: (() => {
            const filenames = Array.from(submittedFilenames || new Set());
            console.log('ğŸ” saveDataToStorage: Saving submittedFilenames:', filenames.length, 'files:', filenames);
            return filenames;
        })(),
        photoFolders: photoFolders || [],
        localStorage: localStorageData,

        // æ¨“å±¤å¹³é¢åœ– - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        floorPlanLabels: floorPlanLabels,
        floorPlanDefectMarks: floorPlanDefectMarks,
        
        // åµŒå…¥ PDF æª”æ¡ˆæ•¸æ“š - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        embeddedPDF: (() => {
            const pdfBase64 = localStorage.getItem('pne_floorplan_base64');
            const pdfData = localStorage.getItem('pne_floorplan_data');
            const pdfFilename = localStorage.getItem('pne_floorplan_filename');
            
            if (pdfBase64 && pdfData && pdfFilename) {
                try {
                    const floorPlanData = JSON.parse(pdfData);
                    return {
                        filename: pdfFilename,
                        base64Data: pdfBase64,
                        metadata: floorPlanData,
                        hasEmbeddedPDF: true,
                        size: pdfBase64.length
                    };
                } catch (e) {
                    window.logger.error('Error parsing PDF data for embedding:', e);
                    return null;
                }
            } else {
                return null;
            }
        })(),
        
        // æ¨“å±¤å¹³é¢åœ–è¦–åœ–ç‹€æ…‹ - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        floorPlanViewState: {
            scale: window.currentScale || 1.0,
            translateX: window.translateX || 0,
            translateY: window.translateY || 0,
            baseScale: (typeof baseScale !== 'undefined' ? baseScale : (window.baseScale || 1.0)),
            labelSizeScale: (window.labelSizeScale || 24),
            defectMarkSizeScale: (window.defectMarkSizeScale || 24)
        },
        
        // ç…§ç‰‡æäº¤ç‹€æ…‹ - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        photoSubmissionStatus: {
            submittedPhotos: Array.from(submittedFilenames || new Set()),
            photoAssignments: Object.fromEntries(
                Object.entries(assignedPhotos || {}).map(([key, value]) => [key, Array.from(value || [])])
            )
        },
        
        // ä»»å‹™æ•¸æ“š - èˆ‡ .pne æª”æ¡ˆä¸€è‡´
        currentTask: currentTask
    };
    
    // è©³ç´°æ—¥èªŒ
    const photosWithDataURL = dataToSave.photoMetadata.filter(p => p.dataURL && p.dataURL.length > 0);
    console.log('ğŸ’¾ Saving data to IndexedDB:', {
        version: dataToSave.version,
        totalPhotos: dataToSave.totalPhotos,
        photosWithDataURL: photosWithDataURL.length,
        photosWithoutDataURL: dataToSave.totalPhotos - photosWithDataURL.length,
        samplePhoto: dataToSave.photoMetadata.length > 0 ? {
            name: dataToSave.photoMetadata[0].name,
            hasDataURL: !!dataToSave.photoMetadata[0].dataURL,
            dataURLLength: dataToSave.photoMetadata[0].dataURL ? dataToSave.photoMetadata[0].dataURL.length : 0,
            dataURLPrefix: dataToSave.photoMetadata[0].dataURL ? dataToSave.photoMetadata[0].dataURL.substring(0, 50) + '...' : 'N/A'
        } : null
    });
    window.logger.log('saveDataToStorage: Preparing to save data with PNE-compatible structure');
    window.logger.log(`- Version: ${dataToSave.version}`);
    window.logger.log(`- Total photos: ${dataToSave.totalPhotos}`);
    window.logger.log(`- Total assignments: ${dataToSave.totalAssignments}`);
    window.logger.log(`- Photos with dataURL: ${photosWithDataURL.length}`);
    window.logger.log(`- Floor plan labels: ${dataToSave.floorPlanLabels.length}`);
    window.logger.log(`- Floor plan defect marks: ${dataToSave.floorPlanDefectMarks.length}`);
    window.logger.log(`- Has embedded PDF: ${dataToSave.embeddedPDF ? 'Yes' : 'No'}`);
    
    // ä¿å­˜åˆ° IndexedDBï¼Œä½¿ç”¨èˆ‡ .pne æª”æ¡ˆå®Œå…¨ä¸€è‡´çš„çµæ§‹
    console.log('ğŸ” saveDataToStorage: About to save dataToSave to IndexedDB');
    console.log('ğŸ” saveDataToStorage: dataToSave keys:', Object.keys(dataToSave));
    console.log('ğŸ” saveDataToStorage: dataToSave.submittedFilenames:', dataToSave.submittedFilenames);
    await window.storageAdapter.setItemDirect('photoNumberExtractorData', dataToSave);
    console.log('ğŸ” saveDataToStorage: Data saved to IndexedDB successfully');
    window.logger.log('saveDataToStorage: PNE-compatible data successfully saved to IndexedDB');

    // åŒæ­¥æ›´æ–°å–®ç¨çš„æ¨“å±¤å¹³é¢åœ–å„²å­˜éµï¼Œé¿å…é‡è¼‰æ™‚ä¸åŒä¾†æºäº’ç›¸è¦†è“‹
    try {
        if (typeof LABELS_LS_KEY !== 'undefined') {
            await window.storageAdapter.setItem(LABELS_LS_KEY, dataToSave.floorPlanLabels || []);
        } else {
            await window.storageAdapter.setItem('pne_floorplan_labels', dataToSave.floorPlanLabels || []);
        }
        if (typeof DEFECT_MARKS_LS_KEY !== 'undefined') {
            await window.storageAdapter.setItem(DEFECT_MARKS_LS_KEY, dataToSave.floorPlanDefectMarks || []);
        } else {
            await window.storageAdapter.setItem('pne_floorplan_defect_marks', dataToSave.floorPlanDefectMarks || []);
        }
        window.logger.log('saveDataToStorage: Synced floor plan data with latest state');
    } catch (err) {
        window.logger.error('saveDataToStorage: Failed syncing floor plan keys', err);
    }
}

// 4. ç›£è½ã€ŒSubmit to Tableã€æŒ‰éˆ•ï¼Œå¡«å…… Inspection Records èˆ‡ 9 å€‹åˆ†é¡è¡¨ - å·²ç§»é™¤é‡è¤‡çš„ç›£è½å™¨

// 5. ç›£è½ Inspection Records è¡¨æ ¼è³‡æ–™ä¿®æ”¹ï¼ŒåŒæ­¥æ›´æ–°åˆ†é¡è¡¨

// updateCategoryTablesFromInspectionRecords();

// ç”Ÿæˆ Inspection Records CSV
function generateInspectionRecordsCSV() {
    let csv = 'Inspection no.,Inspection Date,Location (Floor, Area name and Room no. in sequence),A: Exposed structural metalwork,B: Structural elements,C: External building elements,D: Suspended objects,E: High level internal finishes,F: Heavy metal gates/doors,G: Window and glass louvers,H: Drainage and Plumbing systems,I: Fire safety elements,J: Defects,Imminent Danger\n';
    
    submittedData.forEach(row => {
        // çµ„åˆä½ç½®ä¿¡æ¯ï¼šfloor, Area name, Room no.
        const locationInfo = `${row.floor || 'N/A'}, ${row.areaName || 'N/A'}, ${row.roomNo || 'N/A'}`;
        
        csv += `"${row.locationId}","${row.inspectionDate}","${locationInfo}",`;
        csv += `"${row.a || 'N/A'}","${row.b || 'N/A'}","${row.c || 'N/A'}",`;
        csv += `"${row.d || 'N/A'}","${row.e || 'N/A'}","${row.f || 'N/A'}",`;
        csv += `"${row.g || 'N/A'}","${row.h || 'N/A'}","${row.i || 'N/A'}",`;
        csv += `"${row.j || 'N/A'}","${row.hasImminentDanger ? 'Yes' : 'No'}"\n`;
    });
    
    return csv;
}

// ç”Ÿæˆ Defect Summary CSV
function generateDefectSummaryCSV() {
    let csv = 'Defect no.,Defect(s) with Imminent Danger (Yes/No) Follow up action at Part A.5,Locations of Defects (Floor Area Name and Room No. in sequence),Type of High Risk Building Elements,Description / Construction of High Risk Building Elements,Existing Condition of of High Risk Building Elements,Defects Diagnosis and Deficiencies Identified,Relative Humidity of Room / Area measured during Site Inspection,Moisture Content of Concrete Structural Elements only,Chloride Content of Concrete Structural Elements,Depth and Extent of Carbonation for Concrete Structural Elements,Scope and Extent of Recommended Follow-up Repair Remedial Works,Scope and Extent of Recommended Preventive Maintenance Works,Remarks\n';
    
    // åªå¾ç¼ºé™·æ¢ç›®ä¸­æå–ç¼ºé™·æ•¸æ“š - åªåŒ…å«ä¾†è‡ª defect-window çš„è³‡æ–™ï¼Œæ’é™¤ä¾†è‡ªç¼ºé™·æ¨™è¨˜çš„è³‡æ–™
    // ä¸å†å¾ submittedData ä¸­æå–æ•¸æ“šï¼Œåªé¡¯ç¤ºä¾†è‡ª defect-window çš„ç¼ºé™·è¨˜éŒ„
    const allDefects = [];
    let globalDefectIndex = 0;
    
    window.defectEntries.filter(entry => !entry.fromDefectMark).forEach((entry, entryIndex) => {
        // å°‡åˆ†é¡ä»£ç¢¼è½‰æ›ç‚ºå®Œæ•´çš„åˆ†é¡åç¨±
        const getCategoryName = (categoryCode) => {
            const category = categories.find(cat => cat.id === categoryCode);
            return category ? category.name : categoryCode;
        };
                
                allDefects.push({
            id: `defect_entry_${entryIndex}`,
            defectNo: entry.defectNo || (globalDefectIndex + 1),
            imminentDanger: entry.imminentDanger || false,
            location: `${entry.floor || 'N/A'}, ${entry.areaName || 'N/A'}, ${entry.roomNo || 'N/A'}`,
            category: getCategoryName(entry.category) || 'N/A',
            description: entry.description || 'N/A',
            range: entry.range || 'N/A',
            descriptionConstruction: entry.descriptionConstruction || 'N/A',
            existingCondition: entry.existingCondition || 'N/A',
            humidity: entry.humidity || 'N/A',
            moisture: entry.moisture || 'N/A',
            chloride: entry.chloride || 'N/A',
            carbonation: entry.carbonation || 'N/A',
            remedialWorks: entry.remedialWorks || 'N/A',
            preventiveWorks: entry.preventiveWorks || 'N/A',
                    remarks: (entry.remarks && entry.remarks.trim() !== '') ? entry.remarks : 'N/A'
                });
                globalDefectIndex++;
    });
    
    // ä½¿ç”¨æå–çš„ç¼ºé™·æ•¸æ“šç”Ÿæˆ CSV
    allDefects.forEach((defect, index) => {
        const defectNo = index + 1; // Simple sequential numbering starting from 1
        const imminentDanger = defect.imminentDanger ? 'Yes' : 'No';
        const location = defect.location;
        // å°‡åˆ†é¡ä»£ç¢¼è½‰æ›ç‚ºå®Œæ•´çš„åˆ†é¡åç¨±
        const getCategoryName = (categoryCode) => {
            const category = categories.find(cat => cat.id === categoryCode);
            return category ? category.name : categoryCode;
        };
        const categoryName = getCategoryName(defect.category) || 'Defects';
        
        csv += `"${defectNo}","${imminentDanger}","${location}","${categoryName}",`;
        csv += `"${defect.descriptionConstruction}","${defect.existingCondition}","${defect.description}","${defect.humidity}","${defect.moisture}","${defect.chloride}","${defect.carbonation}","${defect.remedialWorks}","${defect.preventiveWorks}","${defect.remarks}"\n`;
    });
    
    return csv;
}

// ç”Ÿæˆåˆ†é¡è¡¨æ ¼ CSV
async function generateCategoryTableCSV(categoryId) {
    const cat = categoryTableIds.find(c => c.id === categoryId);
    if (!cat) return '';
    
    let csv = 'Location no.,Room no.,Photo no.,Defects,Photo Files\n';
    
    // ç¢ºä¿åˆ†é¡è¡¨æ ¼æ•¸æ“šå¯ç”¨
    let categoryData = [];
    
    // å„ªå…ˆä½¿ç”¨ç•¶å‰è¨˜æ†¶é«”ä¸­çš„æ•¸æ“š
    if (categoryTablesData[categoryId] && categoryTablesData[categoryId].length > 0) {
        categoryData = categoryTablesData[categoryId];
        window.logger.log(`Using category ${categoryId} data from memory:`, categoryData.length);
    } else {
        // å˜—è©¦å¾å­˜å„²ä¸­æ¢å¾©åˆ†é¡è¡¨æ ¼æ•¸æ“š
        try {
            const savedData = window.storageAdapter ? 
                await window.storageAdapter.getItem('photoNumberExtractorData') : 
                JSON.parse(localStorage.getItem('photoNumberExtractorData') || '{}');
            
            if (savedData && savedData.inspectionRecords && savedData.inspectionRecords.length > 0) {
                // å¾æª¢æŸ¥è¨˜éŒ„é‡æ–°ç”Ÿæˆåˆ†é¡è¡¨æ ¼æ•¸æ“š
                const inspectionRecords = savedData.inspectionRecords;
                categoryData = [];
                
                inspectionRecords.forEach(rowData => {
                    const locationNo = rowData.locationId || 'N/A';
                    const roomNo = rowData.roomNo || 'N/A';
                    const photoNo = rowData[categoryId] || 'N/A';
                    
                    const defectItems = rowData.j ? rowData.j.split('\n').filter(item => item.trim()) : [];
                    
                    // æ‰¾å‡ºå±¬æ–¼æ­¤åˆ†é¡çš„ç¼ºé™·é …ç›®
                    const categoryDefects = defectItems.filter(item => {
                        const description = item.replace(/^\*?\s*/, '');
                        const defectDesc = description.split('_').slice(1).join('_');
                        return defectTypes[categoryId] && defectTypes[categoryId].includes(defectDesc);
                    });
                    
                    if (photoNo.trim() || categoryDefects.length > 0) {
                        const defects = categoryDefects.length > 0 ? categoryDefects.join('; ') : 'N/A';
                        categoryData.push({
                            locationNo, 
                            roomNo, 
                            photoNo: photoNo.trim() ? photoNo : 'N/A', 
                            defects
                        });
                    }
                });
                
                window.logger.log(`Restored category ${categoryId} data from storage:`, categoryData.length);
            }
        } catch (error) {
            window.logger.error(`Error restoring category ${categoryId} data:`, error);
        }
    }
    
    if (categoryData.length > 0) {
        // æŒ‰ç…§ç…§ç‰‡ç·¨è™Ÿæ’åºè³‡æ–™
        const sortedData = categoryData.sort((a, b) => {
            const numA = parseInt(a.photoNo.match(/\d+/)?.[0] || '0');
            const numB = parseInt(b.photoNo.match(/\d+/)?.[0] || '0');
            return numA - numB;
        });
        
        sortedData.forEach(row => {
            // æ ¹æ“šç…§ç‰‡ç·¨è™Ÿæ‰¾åˆ°å°æ‡‰çš„ç…§ç‰‡æª”æ¡ˆåç¨±
            let photoFiles = [];
            if (row.photoNo && row.photoNo !== 'N/A') {
                // å¾ submittedData ä¸­æ‰¾åˆ°å°æ‡‰çš„è¨˜éŒ„
                const inspectionRecord = submittedData.find(record => 
                    record.locationId === row.locationNo && record.roomNo === row.roomNo
                );
                
                if (inspectionRecord && inspectionRecord.photoFilenames) {
                    // éæ¿¾å‡ºå±¬æ–¼æ­¤åˆ†é¡çš„ç…§ç‰‡
                    photoFiles = inspectionRecord.photoFilenames.filter(filename => {
                        const photoNumber = filename.match(/\d+/)?.[0];
                        if (!photoNumber) return false;
                        
                        // æª¢æŸ¥ç…§ç‰‡ç·¨è™Ÿæ˜¯å¦åœ¨æ­¤åˆ†é¡ä¸­
                        const photoNumbers = row.photoNo.split(/[,\-]/).map(num => num.trim());
                        return photoNumbers.includes(photoNumber);
                    });
                    
                    // æŒ‰ç…§ç…§ç‰‡ç·¨è™Ÿæ’åº
                    photoFiles.sort((a, b) => {
                        const numA = parseInt(a.match(/\d+/)?.[0] || '0');
                        const numB = parseInt(b.match(/\d+/)?.[0] || '0');
                        return numA - numB;
                    });
                }
            }
            
            csv += `"${row.locationNo}","${row.roomNo}","${row.photoNo}","${row.defects}","${photoFiles.join('; ')}"\n`;
        });
    }
    
    return csv;
}

// æ–°å¢ï¼šé¡¯ç¤ºç…§ç‰‡åˆ†é…ç‹€æ…‹æ‘˜è¦
function showPhotoAssignmentSummary() {
    const totalPhotos = allPhotos.length;
    const totalAssigned = Object.values(assignedPhotos).reduce((sum, photos) => sum + photos.size, 0);
    const totalSubmitted = submittedFilenames.size;
    
    let summary = `ç…§ç‰‡åˆ†é…ç‹€æ…‹æ‘˜è¦:\n`;
    summary += `ç¸½ç…§ç‰‡æ•¸: ${totalPhotos}\n`;
    summary += `å·²åˆ†é…ç…§ç‰‡: ${totalAssigned}\n`;
    summary += `å·²æäº¤ç…§ç‰‡: ${totalSubmitted}\n\n`;
    
    // å„åˆ†é¡çš„åˆ†é…ç‹€æ³
    categories.forEach(category => {
        const assignedCount = assignedPhotos[category.id]?.size || 0;
        const numbersCount = categoryNumbers[category.id]?.length || 0;
        summary += `${category.name}: ${assignedCount} å¼µç…§ç‰‡, ${numbersCount} å€‹ç·¨è™Ÿ\n`;
    });
    
    window.logger.log(summary);
    return summary;
}

// é é¢è¼‰å…¥æ™‚åˆå§‹åŒ–åˆ†é¡è¡¨å’Œç¼ºé™·æ‘˜è¦è¡¨
window.logger.log('Page initialization: Starting category tables and defect summary table updates');
if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}

// é é¢é‡æ–°è¼‰å…¥æ™‚æ¸…ç©ºç¼ºé™·æ‘˜è¦è¡¨æ ¼ï¼Œé˜²æ­¢é¡¯ç¤ºä¾†è‡ªç¼ºé™·æ¨™è¨˜çš„æ•¸æ“š
    const defectSummaryTableBody = document.getElementById('defectSummaryTableBody');
    const defectSummaryCount = document.getElementById('defectSummaryCount');
if (defectSummaryTableBody) {
        defectSummaryTableBody.innerHTML = '<tr><td colspan="14" class="empty-state">No defect summary data yet</td></tr>';
        defectSummaryCount.textContent = '0 entries';
    window.logger.log('Page initialization: Cleared defect summary table on reload to prevent defect mark data display');
}

// ç¢ºä¿åœ¨ loadDataFromStorage å¾Œä¹Ÿæ›´æ–°åˆ†é¡è¡¨å’Œç¼ºé™·æ‘˜è¦è¡¨
setTimeout(() => {
    window.logger.log('Page initialization: Delayed updates, submittedDefectEntries.length:', submittedDefectEntries.length);
    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}
    
    // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼ä»¥é¡¯ç¤ºä¾†è‡ª all defects detail-table-container çš„è¨˜éŒ„
    // é€™ç¢ºä¿äº†å¦‚æœ detail-table ä¸­æœ‰è¨˜éŒ„ï¼Œå®ƒå€‘æœƒåœ¨ä»»ä½•æ™‚å€™éƒ½é¡¯ç¤ºåœ¨ summary table ä¸­
    if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
    window.logger.log('Page initialization: Updated defect summary table to display detail-table records');
    
    // é¡¯ç¤ºç…§ç‰‡åˆ†é…ç‹€æ…‹æ‘˜è¦
    if (allPhotos.length > 0) {
        showPhotoAssignmentSummary();
    }
}, 100);

// PNEä¸‹æ‹‰é¸å–®äº’å‹•ï¼ˆç”±hoveræ”¹ç‚ºé»æ“Šï¼‰
const pneBtn = document.querySelector('.pne-func-btn');
const pneDropdown = pneBtn.querySelector('.pne-dropdown');

pneBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    pneDropdown.style.display = (pneDropdown.style.display === 'block') ? 'none' : 'block';
});
// é»æ“Šå¤–éƒ¨è‡ªå‹•æ”¶èµ·
window.addEventListener('click', () => {
    pneDropdown.style.display = 'none';
});
// é»æ“Šé¸å–®é …ç›®æ™‚è‡ªå‹•æ”¶èµ·ä¸¦è™•ç†å‹•ä½œ
pneDropdown.addEventListener('click', e => {
    if(e.target.classList.contains('pne-dropdown-item')) {
        const action = e.target.getAttribute('data-action');
        
        // ç«‹å³é—œé–‰ä¸‹æ‹‰é¸å–®
        pneDropdown.style.display = 'none';
        
        // è™•ç†å„ç¨®å‹•ä½œ
        switch(action) {
            case 'selectfolder':
                // Check if there are unexported records AND sorting is enabled
                if (submittedData.length > 0 && sortToggle.checked) {
                    // Show the overlay message
                    globalOverlay.style.display = 'flex';
                    return;
                }
                
                // Proceed with folder selection if no unexported data or sorting is disabled
                selectPhotoFolder();
                break;
                
            case 'uploadfloorplan':
                // Open drawing mode (floor plan)
                if (typeof openFloorPlanOverlay === 'function') {
                    openFloorPlanOverlay();
                }
                break;
                
            case 'open':
                // Open PNE file - this is handled by separate event listener
                // The dropdown is already closed above
                break;
                
            case 'saveas':
                // Save as PNE file - this is handled by separate event listener
                // The dropdown is already closed above
                break;
                
            case 'exportcsv':
                // Export CSV - this is handled by separate event listener
                // The dropdown is already closed above
                break;
                
            case 'preview':
                // Defects Report - this is handled by separate event listener
                // The dropdown is already closed above
                break;
                
            case 'summary':
                // Photo Assignment Summary
                const summary = showPhotoAssignmentSummary();
                
                // å‰µå»ºå½ˆå‡ºè¦–çª—é¡¯ç¤ºæ‘˜è¦
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 5000;
                `;
                
                const popup = document.createElement('div');
                popup.style.cssText = `
                    background: white;
                    padding: 30px;
                    border-radius: 12px;
                    max-width: 600px;
                    max-height: 80vh;
                    overflow-y: auto;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;
                
                popup.innerHTML = `
                    <h3 style="color: var(--primary); margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-info-circle"></i> ç…§ç‰‡åˆ†é…ç‹€æ…‹æ‘˜è¦
                    </h3>
                    <pre style="white-space: pre-wrap; font-family: monospace; font-size: 14px; line-height: 1.6; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">${summary}</pre>
                    <div style="text-align: center; margin-top: 20px;">
                        <button id="closeSummaryBtn" style="background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: 600;">é—œé–‰</button>
                    </div>
                `;
                
                overlay.appendChild(popup);
                document.body.appendChild(overlay);
                
                // æ·»åŠ é—œé–‰æŒ‰éˆ•çš„äº‹ä»¶ç›£è½å™¨
                const closeBtn = popup.querySelector('#closeSummaryBtn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        overlay.remove();
                    });
                }
                
                // é»æ“ŠèƒŒæ™¯ä¹Ÿå¯ä»¥é—œé–‰å½ˆå‡ºè¦–çª—
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        overlay.remove();
                    }
                });
                break;
                
            case 'fileviewer':
                // File Viewer - é¡¯ç¤ºç•¶å‰è¼‰å…¥çš„æ–‡ä»¶
                const currentFiles = [];
                
                // æ·»åŠ  PDF æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                const pdfFilename = localStorage.getItem('pne_floorplan_filename');
                const pdfData = localStorage.getItem('pne_floorplan_data');
                if (pdfFilename && pdfData) {
                    try {
                        const floorPlanData = JSON.parse(pdfData);
                        currentFiles.push({
                            id: 'pdf_floorplan',
                            name: pdfFilename,
                            path: pdfFilename,
                            type: 'pdf',
                            description: 'æ¨“å±¤å¹³é¢åœ– PDF æ–‡ä»¶',
                            uploadDate: floorPlanData.uploadDate || new Date().toISOString(),
                            size: `${(floorPlanData.fileSize / 1024 / 1024).toFixed(2)} MB`,
                            fileReference: floorPlanData.fileReference,
                            hasBase64Data: floorPlanData.hasBase64Data || false
                        });
                    } catch (e) {
                        window.logger.error('Error parsing PDF data:', e);
                    }
                }
                
                // æ·»åŠ ç…§ç‰‡æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (allPhotos && allPhotos.length > 0) {
                    allPhotos.forEach((photo, index) => {
                        currentFiles.push({
                            id: `photo_${index}`,
                            name: photo.name,
                            path: photo.webkitRelativePath || photo.name,
                            type: 'image',
                            description: `æª¢æŸ¥ç…§ç‰‡ - ${photo.name}`,
                            uploadDate: new Date(photo.lastModified).toISOString(),
                            size: `${(photo.size / 1024 / 1024).toFixed(2)} MB`,
                            dataURL: photo.dataURL || '',
                            webkitRelativePath: photo.webkitRelativePath || ''
                        });
                    });
                }
                
                if (currentFiles.length === 0) {
                    showNotification('æ²’æœ‰å¯é¡¯ç¤ºçš„æ–‡ä»¶', 'warning');
                } else {
                    createFileDisplaySystem(currentFiles);
                }
                break;
                
            default:
                window.logger.log('Unknown PNE dropdown action:', action);
                break;
        }
    }
});

// Export CSV from PNE menu
const exportCSVBtn = document.querySelector('.pne-dropdown-item[data-action="exportcsv"]');
exportCSVBtn.addEventListener('click', function() {
    // é—œé–‰ä¸‹æ‹‰é¸å–®
    const pneDropdown = document.querySelector('.pne-dropdown');
    if (pneDropdown) {
        pneDropdown.style.display = 'none';
    }
    
    // ç›´æ¥é¡¯ç¤ºå°å‡ºè¨­ç½®é é¢ï¼Œä¸æª¢æŸ¥æ•¸æ“š
    showExportSettingsModal();
});

// é¡¯ç¤ºå°å‡ºè¨­ç½®é é¢
function showExportSettingsModal() {
    const modal = document.getElementById('exportSettingsModal');
    if (modal) {
        modal.style.display = 'flex';
        
        // åˆå§‹åŒ–è¨­ç½®
        initializeExportSettings();
        
        // æ·»åŠ äº‹ä»¶ç›£è½å™¨
        setupExportSettingsEventListeners();
    }
}

// åˆå§‹åŒ–å°å‡ºè¨­ç½®
function initializeExportSettings() {
    // æª¢æŸ¥å„é …æ•¸æ“šçš„å¯ç”¨æ€§
    const hasInspectionRecords = submittedData && submittedData.length > 0;
    const hasDefectSummary = window.defectEntries && window.defectEntries.length > 0;
    // åˆ†é¡è¨˜éŒ„è¡¨æ ¼åŸºæ–¼ submittedData ä¸­çš„åˆ†é¡æ•¸æ“šï¼Œè€Œä¸æ˜¯ç•¶å‰åˆ†é…çš„ç…§ç‰‡
    const hasCategories = submittedData && submittedData.length > 0 && 
        submittedData.some(record => {
            // æª¢æŸ¥æ˜¯å¦æœ‰ä»»ä½•åˆ†é¡ (A-I) æœ‰æ•¸æ“š
            return ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'].some(categoryId => {
                const value = record[categoryId];
                return value && value.trim() && value.trim() !== 'N/A';
            });
        });
    const hasFloorPlanPDF = localStorage.getItem('pne_floorplan_filename') || localStorage.getItem('pne_floorplan_base64');
    const hasPhotos = (allPhotos && allPhotos.length > 0) || 
                     (photoFolders && photoFolders.length > 0) || 
                     (submittedData && submittedData.some(record => record.photoFilenames && record.photoFilenames.length > 0));
    
    // è¨­ç½®è¤‡é¸æ¡†ç‹€æ…‹
    const inspectionRecordsCheckbox = document.getElementById('exportInspectionRecords');
    const defectSummaryCheckbox = document.getElementById('exportDefectSummary');
    const categoriesCheckbox = document.getElementById('exportCategories');
    const floorPlanPDFCheckbox = document.getElementById('exportFloorPlanPDF');
    const sortPhotosCheckbox = document.getElementById('sortPhotosToFolder');
    
    if (inspectionRecordsCheckbox) {
        inspectionRecordsCheckbox.checked = hasInspectionRecords;
        inspectionRecordsCheckbox.disabled = !hasInspectionRecords;
        // æ·»åŠ è¦–è¦ºæç¤º
        if (!hasInspectionRecords) {
            inspectionRecordsCheckbox.parentElement.style.opacity = '0.6';
            inspectionRecordsCheckbox.parentElement.title = 'No inspection records available';
        } else {
            inspectionRecordsCheckbox.parentElement.style.opacity = '1';
            inspectionRecordsCheckbox.parentElement.title = '';
        }
    }
    
    if (defectSummaryCheckbox) {
        defectSummaryCheckbox.checked = hasDefectSummary;
        defectSummaryCheckbox.disabled = !hasDefectSummary;
        if (!hasDefectSummary) {
            defectSummaryCheckbox.parentElement.style.opacity = '0.6';
            defectSummaryCheckbox.parentElement.title = 'No defect summary available';
        } else {
            defectSummaryCheckbox.parentElement.style.opacity = '1';
            defectSummaryCheckbox.parentElement.title = '';
        }
    }
    
    if (categoriesCheckbox) {
        window.logger.log('Categories checkbox found, hasCategories:', hasCategories);
        window.logger.log('submittedData for categories check:', submittedData);
        categoriesCheckbox.checked = hasCategories;
        categoriesCheckbox.disabled = !hasCategories;
        if (!hasCategories) {
            categoriesCheckbox.parentElement.style.opacity = '0.6';
            categoriesCheckbox.parentElement.title = 'No category records available';
            window.logger.log('Categories checkbox disabled - no category records available');
        } else {
            categoriesCheckbox.parentElement.style.opacity = '1';
            categoriesCheckbox.parentElement.title = '';
            window.logger.log('Categories checkbox enabled - category records available');
        }
    } else {
        window.logger.error('Categories checkbox not found!');
    }
    
    if (floorPlanPDFCheckbox) {
        floorPlanPDFCheckbox.checked = !!hasFloorPlanPDF;
        floorPlanPDFCheckbox.disabled = !hasFloorPlanPDF;
        if (!hasFloorPlanPDF) {
            floorPlanPDFCheckbox.parentElement.style.opacity = '0.6';
            floorPlanPDFCheckbox.parentElement.title = 'No floor plan PDF available';
        } else {
            floorPlanPDFCheckbox.parentElement.style.opacity = '1';
            floorPlanPDFCheckbox.parentElement.title = '';
        }
    }
    
    if (sortPhotosCheckbox) {
        sortPhotosCheckbox.checked = true; // é»˜èªå•Ÿç”¨
        sortPhotosCheckbox.disabled = !hasPhotos; // åªæœ‰åœ¨æœ‰ç…§ç‰‡æ™‚æ‰å•Ÿç”¨
        if (!hasPhotos) {
            sortPhotosCheckbox.parentElement.style.opacity = '0.6';
            sortPhotosCheckbox.parentElement.title = 'No photos available for sorting';
        } else {
            sortPhotosCheckbox.parentElement.style.opacity = '1';
            sortPhotosCheckbox.parentElement.title = '';
        }
    }
}

// è¨­ç½®å°å‡ºè¨­ç½®é é¢çš„äº‹ä»¶ç›£è½å™¨
function setupExportSettingsEventListeners() {
    const modal = document.getElementById('exportSettingsModal');
    const closeBtn = document.getElementById('closeExportSettingsBtn');
    const cancelBtn = document.getElementById('cancelExportBtn');
    const exportBtn = document.getElementById('confirmExportBtn');
    
    // é—œé–‰æŒ‰éˆ•
    if (closeBtn) {
        closeBtn.onclick = () => {
            modal.style.display = 'none';
        };
    }
    
    // å–æ¶ˆæŒ‰éˆ•
    if (cancelBtn) {
        cancelBtn.onclick = () => {
            modal.style.display = 'none';
        };
    }
    
    // å°å‡ºæŒ‰éˆ•
    if (exportBtn) {
        exportBtn.onclick = async () => {
            await performExport();
            modal.style.display = 'none';
        };
    }
    
    // é»æ“Šæ¨¡æ…‹æ¡†å¤–éƒ¨é—œé–‰
    if (modal) {
        modal.onclick = (e) => {
            if (e.target === modal) {
                modal.style.display = 'none';
            }
        };
    }
    
    // Photo watermark controls
    setupPhotoWatermarkControls();
}

// Setup photo watermark controls
function setupPhotoWatermarkControls() {
    const watermarkToggle = document.getElementById('photoWatermarkToggle');
    const watermarkControls = document.getElementById('photoWatermarkControls');
    const watermarkColorPicker = document.getElementById('photoWatermarkColorPicker');
    const watermarkSizeSlider = document.getElementById('photoWatermarkSizeSlider');
    const watermarkSizeValue = document.getElementById('photoWatermarkSizeValue');
    
    // Watermark toggle event
    if (watermarkToggle && watermarkControls) {
        watermarkToggle.addEventListener('change', function() {
            if (this.checked) {
                watermarkControls.style.display = 'block';
            } else {
                watermarkControls.style.display = 'none';
            }
            updatePhotoWatermarkPreview();
        });
        
        // Initialize visibility based on toggle state
        watermarkControls.style.display = watermarkToggle.checked ? 'block' : 'none';
    }
    
    // Watermark size slider event
    if (watermarkSizeSlider && watermarkSizeValue) {
        watermarkSizeSlider.addEventListener('input', function() {
            watermarkSizeValue.textContent = this.value;
            updatePhotoWatermarkPreview();
        });
    }
    
    // Watermark color picker event
    if (watermarkColorPicker) {
        watermarkColorPicker.addEventListener('change', function() {
            updatePhotoWatermarkPreview();
        });
    }
    
    // Initialize preview
    updatePhotoWatermarkPreview();
}

// Update photo watermark preview
function updatePhotoWatermarkPreview() {
    // Update landscape preview
    updateLandscapeWatermarkPreview();
    // Update portrait preview
    updatePortraitWatermarkPreview();
}

// Update landscape watermark preview
function updateLandscapeWatermarkPreview() {
    const canvas = document.getElementById('photoWatermarkPreviewCanvas');
    const resolutionSpan = document.getElementById('photoWatermarkPreviewResolution');
    
    if (!canvas || !resolutionSpan) return;
    
    const ctx = canvas.getContext('2d');
    
    // Use example dimensions for landscape effect (16:9 ratio)
    const baseWidth = 1920;
    const baseHeight = 1080;
    
    // Set canvas size (scaled version for preview)
    const scale = Math.min(120 / baseWidth, 80 / baseHeight);
    const previewWidth = Math.floor(baseWidth * scale);
    const previewHeight = Math.floor(baseHeight * scale);
    
    canvas.width = previewWidth;
    canvas.height = previewHeight;
    
    // Update resolution display
    resolutionSpan.textContent = `${baseWidth} x ${baseHeight}`;
    
    // Fill white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, previewWidth, previewHeight);
    
    // Draw watermark if enabled
    const watermarkToggle = document.getElementById('photoWatermarkToggle');
    if (watermarkToggle && watermarkToggle.checked) {
        const watermarkColorPicker = document.getElementById('photoWatermarkColorPicker');
        const watermarkSizeSlider = document.getElementById('photoWatermarkSizeSlider');
        
        const watermarkColor = watermarkColorPicker ? watermarkColorPicker.value : '#000000';
        const watermarkSize = watermarkSizeSlider ? parseInt(watermarkSizeSlider.value) : 24;
        
        // Use current inspection date or today's date
        const inspectionDate = document.getElementById('inspectionDate')?.value || new Date().toISOString().split('T')[0];
        const watermarkText = formatDateForWatermark(inspectionDate);
        const watermarkFontSize = Math.floor(watermarkSize * scale);
        
        ctx.font = `bold ${watermarkFontSize}px Arial, sans-serif`;
        ctx.fillStyle = watermarkColor;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        
        // Watermark position (bottom right corner)
        const watermarkX = previewWidth - 5;
        const watermarkY = previewHeight - 5;
        
        ctx.fillText(watermarkText, watermarkX, watermarkY);
    }
    
    // Add orientation indicator
    ctx.font = `8px Arial, sans-serif`;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    
    ctx.fillText('Landscape', 5, 5);
}

// Update portrait watermark preview
function updatePortraitWatermarkPreview() {
    const canvas = document.getElementById('photoWatermarkPreviewCanvasP');
    const resolutionSpan = document.getElementById('photoWatermarkPreviewResolutionP');
    
    if (!canvas || !resolutionSpan) return;
    
    const ctx = canvas.getContext('2d');
    
    // Use example dimensions for portrait effect (9:16 ratio)
    const baseWidth = 1080;
    const baseHeight = 1920;
    
    // Set canvas size (scaled version for preview)
    const scale = Math.min(120 / baseWidth, 80 / baseHeight);
    const previewWidth = Math.floor(baseWidth * scale);
    const previewHeight = Math.floor(baseHeight * scale);
    
    canvas.width = previewWidth;
    canvas.height = previewHeight;
    
    // Update resolution display
    resolutionSpan.textContent = `${baseWidth} x ${baseHeight}`;
    
    // Fill white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, previewWidth, previewHeight);
    
    // Draw watermark if enabled
    const watermarkToggle = document.getElementById('photoWatermarkToggle');
    if (watermarkToggle && watermarkToggle.checked) {
        const watermarkColorPicker = document.getElementById('photoWatermarkColorPicker');
        const watermarkSizeSlider = document.getElementById('photoWatermarkSizeSlider');
        
        const watermarkColor = watermarkColorPicker ? watermarkColorPicker.value : '#000000';
        const watermarkSize = watermarkSizeSlider ? parseInt(watermarkSizeSlider.value) : 24;
        
        // Use current inspection date or today's date
        const inspectionDate = document.getElementById('inspectionDate')?.value || new Date().toISOString().split('T')[0];
        const watermarkText = formatDateForWatermark(inspectionDate);
        const watermarkFontSize = Math.floor(watermarkSize * scale);
        
        ctx.font = `bold ${watermarkFontSize}px Arial, sans-serif`;
        ctx.fillStyle = watermarkColor;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        
        // Watermark position (bottom right corner)
        const watermarkX = previewWidth - 5;
        const watermarkY = previewHeight - 5;
        
        ctx.fillText(watermarkText, watermarkX, watermarkY);
    }
    
    // Add orientation indicator
    ctx.font = `8px Arial, sans-serif`;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    
    ctx.fillText('Portrait', 5, 5);
}

// Photo watermark functionality
let photoWatermarkSettings = {
    enabled: true,
    color: '#000000',
    size: 24
};

// Format date for watermark (from Phorigami.html)
function formatDateForWatermark(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}/${month}/${day}`;
}

// Get inspection date for a photo based on filename
function getInspectionDateForPhoto(filename) {
    // First, try to find the photo in submittedData
    for (const record of submittedData) {
        if (record.photoFilenames && record.photoFilenames.includes(filename)) {
            return record.inspectionDate;
        }
    }
    
    // If not found in submittedData, try to find in photoFolders
    for (const folder of photoFolders) {
        if (folder.photos && folder.photos.includes(filename)) {
            // Try to find the inspection date from the folder's locationId
            for (const record of submittedData) {
                if (record.locationId === folder.locationId) {
                    return record.inspectionDate;
                }
            }
        }
    }
    
    // If still not found, use the current header inspection date
    const headerInspectionDate = document.getElementById('inspectionDate');
    if (headerInspectionDate && headerInspectionDate.value) {
        return headerInspectionDate.value;
    }
    
    // Fallback to today's date
    return new Date().toISOString().split('T')[0];
}

// Add watermark to photo
function addWatermarkToPhoto(imageBlob, inspectionDate) {
    return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();

        img.onload = function() {
            // Set canvas size to match image
            canvas.width = img.width;
            canvas.height = img.height;

            // Draw the original image
            ctx.drawImage(img, 0, 0);

            // Add watermark if enabled
            const watermarkToggle = document.getElementById('photoWatermarkToggle');
            if (watermarkToggle && watermarkToggle.checked && inspectionDate) {
                const watermarkText = formatDateForWatermark(inspectionDate);
                const watermarkColorPicker = document.getElementById('photoWatermarkColorPicker');
                const watermarkSizeSlider = document.getElementById('photoWatermarkSizeSlider');
                
                const watermarkColor = watermarkColorPicker ? watermarkColorPicker.value : '#000000';
                const watermarkSize = watermarkSizeSlider ? parseInt(watermarkSizeSlider.value) : 24;
                
                // Calculate watermark font size based on image dimensions
                const watermarkFontSize = Math.floor(watermarkSize * (img.width / 1920));
                
                ctx.font = `bold ${watermarkFontSize}px Arial, sans-serif`;
                ctx.fillStyle = watermarkColor;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'bottom';
                
                // Watermark position (bottom right corner)
                const watermarkX = canvas.width - Math.floor(watermarkFontSize * 0.5);
                const watermarkY = canvas.height - Math.floor(watermarkFontSize * 0.5);
                
                ctx.fillText(watermarkText, watermarkX, watermarkY);
            }

            // Convert to blob
            canvas.toBlob((blob) => {
                resolve(blob);
            }, 'image/jpeg', 0.9);
        };

        img.src = URL.createObjectURL(imageBlob);
    });
}

// åŸ·è¡Œå°å‡º - èˆ‡ pne.html é‚è¼¯ä¸€è‡´
async function performExport() {
    try {
        // ç²å–ç”¨æˆ¶é¸æ“‡çš„è¨­ç½®
        const exportSettings = {
            inspectionRecords: document.getElementById('exportInspectionRecords').checked,
            defectSummary: document.getElementById('exportDefectSummary').checked,
            categories: document.getElementById('exportCategories').checked,
            floorPlanPDF: document.getElementById('exportFloorPlanPDF').checked,
            sortPhotosToFolder: document.getElementById('sortPhotosToFolder').checked
        };
        
        // æ·»åŠ èª¿è©¦ä¿¡æ¯
        window.logger.log('Export settings:', exportSettings);
        window.logger.log('sortPhotosToFolder checkbox element:', document.getElementById('sortPhotosToFolder'));
        window.logger.log('sortPhotosToFolder checked:', document.getElementById('sortPhotosToFolder').checked);
        
        // æª¢æŸ¥æ˜¯å¦è‡³å°‘é¸æ“‡äº†ä¸€é …
        const hasSelection = Object.values(exportSettings).some(setting => setting === true);
        if (!hasSelection) {
            showNotification('Please select at least one item to export, or add some data to the application first.', 'warning');
        return;
    }
        
        showNotification('Preparing export...', 'info');
    
    // å‰µå»º ZIP æª”æ¡ˆ
    const zip = new JSZip();
    
    // 1. åŒ¯å‡º Inspection Records è¡¨æ ¼
        if (exportSettings.inspectionRecords) {
    const inspectionRecordsCSV = generateInspectionRecordsCSV();
    zip.file("Inspection_Records.csv", inspectionRecordsCSV);
        }
    
    // 2. åŒ¯å‡º Defect Summary è¡¨æ ¼
        if (exportSettings.defectSummary) {
    const defectSummaryCSV = generateDefectSummaryCSV();
    zip.file("Defect_Summary.csv", defectSummaryCSV);
        }
        
        // 3. åŒ¯å‡ºåˆ†é¡è¡¨æ ¼ (A-I)
        if (exportSettings.categories) {
            window.logger.log('Exporting category tables (A-I)...');
            window.logger.log('categoryTableIds:', categoryTableIds);
            window.logger.log('submittedData for categories:', submittedData);
            
            for (const cat of categoryTableIds) {
                window.logger.log(`Generating CSV for category ${cat.id}: ${cat.name}`);
                const categoryCSV = await generateCategoryTableCSV(cat.id);
        const filename = `${cat.name.replace(/[^a-zA-Z0-9]/g, '_')}.csv`;
                window.logger.log(`Adding ${filename} to ZIP, CSV length:`, categoryCSV.length);
        zip.file(filename, categoryCSV);
            }
            window.logger.log('Category tables export completed');
        }
        
        // 4. åŒ¯å‡ºæ¨“å±¤å¹³é¢åœ– PDF
        if (exportSettings.floorPlanPDF) {
            await exportFloorPlanToZip(zip);
        }
        
        // 5. æ·»åŠ ç…§ç‰‡åˆ° ZIP - èˆ‡ pne.html é‚è¼¯ä¸€è‡´
        // Always export photos regardless of sortPhotosToFolder setting
        window.logger.log('Starting photo export with folder sorting (pne.html style)');
        await exportPhotosToZipPneStyle(zip);
        
        // 6. æ·»åŠ ç•¶å‰ä»»å‹™æ•¸æ“šåˆ° ZIP
        if (currentTask && currentTask.name) {
            window.logger.log('Exporting current task to ZIP:', currentTask.name);
            const taskData = {
                currentTask: currentTask,
                exportDate: new Date().toISOString()
            };
            zip.file("Current_Task.json", JSON.stringify(taskData, null, 2));
            
            // ä¹Ÿç”Ÿæˆ CSV æ ¼å¼çš„ä»»å‹™ä¿¡æ¯
            const taskCSV = `Task Name,Description,Last Updated\n"${currentTask.name}","${currentTask.description || ''}","${currentTask.updatedAt || ''}"`;
            zip.file("Current_Task.csv", taskCSV);
        }
        
        // 7. ç”Ÿæˆä¸¦ä¸‹è¼‰ ZIP æª”æ¡ˆ
        const content = await zip.generateAsync({type: 'blob'});
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = `Inspection_Data_${new Date().toISOString().split('T')[0]}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showNotification('Data exported successfully!', 'success');
        
    } catch (error) {
        window.logger.error('Export error:', error);
        showNotification('Export failed!', 'error');
    }
}

// å°å‡ºæ¨“å±¤å¹³é¢åœ– PDF åˆ° ZIP - ä½¿ç”¨èˆ‡ç¹ªåœ–æ¨¡å¼ç›¸åŒçš„é‚è¼¯
async function exportFloorPlanToZip(zip) {
    try {
        const pdfBase64 = localStorage.getItem('pne_floorplan_base64');
        const pdfFilename = localStorage.getItem('pne_floorplan_filename');
        const floorPlanData = JSON.parse(localStorage.getItem('pne_floorplan_data') || '{}');
        
        if (pdfBase64 && pdfFilename) {
            window.logger.log('Exporting floor plan PDF to ZIP:', pdfFilename);
            
            // æª¢æŸ¥æ˜¯å¦æœ‰æ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜éœ€è¦å°å‡º
            let labelsToExport = [];
            let defectMarksToExport = [];
            
            // å„ªå…ˆä½¿ç”¨ç•¶å‰è¨˜æ†¶é«”ä¸­çš„æ•¸æ“š
            if (window.labels && window.labels.length > 0) {
                labelsToExport = window.labels;
                window.logger.log('Using labels from memory:', labelsToExport.length);
            } else {
                // å˜—è©¦å¾å­˜å„²ä¸­æ¢å¾©æ¨™ç±¤æ•¸æ“š
                try {
                    const savedData = await window.storageAdapter.getItem('photoNumberExtractorData');
                    if (savedData && savedData.floorPlanLabels && savedData.floorPlanLabels.length > 0) {
                        labelsToExport = savedData.floorPlanLabels;
                        window.logger.log('Restored labels from storage:', labelsToExport.length);
                    }
                } catch (error) {
                    window.logger.error('Error restoring labels from storage:', error);
                }
            }
            
            if (window.defectMarks && window.defectMarks.length > 0) {
                defectMarksToExport = window.defectMarks;
                window.logger.log('Using defect marks from memory:', defectMarksToExport.length);
            } else {
                // å˜—è©¦å¾å­˜å„²ä¸­æ¢å¾©ç¼ºé™·æ¨™è¨˜æ•¸æ“š
                try {
                    const savedData = await window.storageAdapter.getItem('photoNumberExtractorData');
                    if (savedData && savedData.floorPlanDefectMarks && savedData.floorPlanDefectMarks.length > 0) {
                        defectMarksToExport = savedData.floorPlanDefectMarks;
                        window.logger.log('Restored defect marks from storage:', defectMarksToExport.length);
                    }
                } catch (error) {
                    window.logger.error('Error restoring defect marks from storage:', error);
                }
            }
            
            // å¦‚æœæœ‰æ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜ï¼Œç”Ÿæˆå¸¶è¨»é‡‹çš„ PDFï¼ˆä½¿ç”¨èˆ‡ç¹ªåœ–æ¨¡å¼ç›¸åŒçš„é‚è¼¯ï¼‰
            if (labelsToExport.length > 0 || defectMarksToExport.length > 0) {
                window.logger.log('Generating annotated PDF with labels and defect marks for ZIP export');
                
                try {
                    // æª¢æŸ¥pdf-libæ˜¯å¦å¯ç”¨
                    if (typeof PDFLib === 'undefined') {
                        window.logger.error('PDFLib library not loaded');
                        // å¦‚æœ PDFLib ä¸å¯ç”¨ï¼Œä½¿ç”¨åŸå§‹ PDF
                        const binaryString = atob(pdfBase64);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        zip.file(`Floor_Plan_${pdfFilename}`, bytes);
                        window.logger.log('PDFLib not available, added original PDF to ZIP');
                        return;
                    }
                    
                    // å°‡base64è½‰æ›ç‚ºArrayBuffer
                    const binaryString = atob(pdfBase64);
                    const arrayBuffer = new ArrayBuffer(binaryString.length);
                    const uint8Array = new Uint8Array(arrayBuffer);
                    for (let i = 0; i < binaryString.length; i++) {
                        uint8Array[i] = binaryString.charCodeAt(i);
                    }
                    
                    // ä½¿ç”¨pdf-libåŠ è¼‰PDF
                    const { PDFDocument, rgb } = PDFLib;
                    const pdfDoc = await PDFDocument.load(arrayBuffer);
                    const newPdfDoc = await PDFDocument.create();

                    // ç²å–é é¢
                    const pages = pdfDoc.getPages();
                    const [firstPage] = await newPdfDoc.copyPages(pdfDoc, [0]);
                    newPdfDoc.addPage(firstPage);

                    // ç²å–é é¢å°ºå¯¸
                    const { width, height } = firstPage.getSize();
                    
                    // ç²å–Canvaså°ºå¯¸ç”¨æ–¼åæ¨™è½‰æ›
                    const floorPlanCanvas = document.getElementById('floorPlanCanvas');
                    let canvasWidth, canvasHeight;
                    
                    if (floorPlanCanvas && floorPlanCanvas.style.width && floorPlanCanvas.style.height) {
                        // ä½¿ç”¨ CSS å°ºå¯¸ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                        canvasWidth = parseFloat(floorPlanCanvas.style.width);
                        canvasHeight = parseFloat(floorPlanCanvas.style.height);
                        window.logger.log('Using CSS dimensions for coordinate conversion');
                    } else {
                        // å¾å­˜å„²çš„æ¨“å±¤å¹³é¢åœ–æ•¸æ“šä¸­ç²å–å°ºå¯¸
                        const storedCanvasWidth = floorPlanData.canvasWidth || 800;
                        const storedCanvasHeight = floorPlanData.canvasHeight || 600;
                        canvasWidth = storedCanvasWidth;
                        canvasHeight = storedCanvasHeight;
                        window.logger.log('Using stored dimensions for coordinate conversion');
                    }

                    // æª¢æŸ¥ Canvas å’Œ PDF çš„å¯¬é«˜æ¯”æ˜¯å¦åŒ¹é…
                    const canvasAspectRatio = canvasWidth / canvasHeight;
                    const pdfAspectRatio = width / height;
                    const aspectRatioDiff = Math.abs(canvasAspectRatio - pdfAspectRatio);
                    
                    // æª¢æŸ¥æ˜¯å¦ Canvas å’Œ PDF çš„å¯¬é«˜è¢«äº¤æ›äº†ï¼ˆ90åº¦æ—‹è½‰ï¼‰
                    const canvasAspectRatioSwapped = canvasHeight / canvasWidth;
                    const aspectRatioDiffSwapped = Math.abs(canvasAspectRatioSwapped - pdfAspectRatio);
                    const isRotated90Degrees = aspectRatioDiffSwapped < aspectRatioDiff && aspectRatioDiff > 0.1;
                    
                    window.logger.log('PDF page size:', width, height);
                    window.logger.log('Canvas size:', canvasWidth, canvasHeight);
                    window.logger.log('Canvas aspect ratio:', canvasAspectRatio.toFixed(3));
                    window.logger.log('Canvas aspect ratio (swapped):', canvasAspectRatioSwapped.toFixed(3));
                    window.logger.log('PDF aspect ratio:', pdfAspectRatio.toFixed(3));
                    window.logger.log('Aspect ratio difference (normal):', aspectRatioDiff.toFixed(3));
                    window.logger.log('Aspect ratio difference (swapped):', aspectRatioDiffSwapped.toFixed(3));
                    window.logger.log('Is rotated 90 degrees:', isRotated90Degrees);
                    window.logger.log('Floor plan data:', floorPlanData);
                    
                    // å¦‚æœæª¢æ¸¬åˆ° 90 åº¦æ—‹è½‰ï¼Œäº¤æ› Canvas çš„å¯¬é«˜
                    if (isRotated90Degrees) {
                        window.logger.warn('Canvas appears to be rotated 90 degrees relative to PDF - swapping dimensions');
                        [canvasWidth, canvasHeight] = [canvasHeight, canvasWidth];
                    } else if (aspectRatioDiff > 0.1) {
                        window.logger.warn('Canvas and PDF aspect ratios differ significantly, coordinate conversion may be inaccurate');
                    }

                    // ç¹ªè£½æ¨™ç±¤åˆ°PDF
                    if (labelsToExport.length > 0) {
                        window.logger.log('Drawing labels to PDF for ZIP export:', labelsToExport.length);
                        for (const label of labelsToExport) {
                            // æª¢æŸ¥æ˜¯å¦æœ‰canvasPositionï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨èˆŠåº§æ¨™ç³»çµ±
                            if (!label.canvasPosition && (label.x !== undefined || label.y !== undefined)) {
                                label.canvasPosition = { x: label.x || 0, y: label.y || 0 };
                            }
                            
                            if (label.canvasPosition) {
                                window.logger.log('Drawing label to PDF:', label.id, 'Canvas position:', label.canvasPosition);
                                await drawLabelOnPDF(firstPage, label, canvasWidth, canvasHeight, width, height);
                            } else {
                                window.logger.warn('Label missing canvasPosition:', label);
                            }
                        }
                    }

                    // ç¹ªè£½ç¼ºé™·æ¨™è¨˜åˆ°PDF
                    if (defectMarksToExport.length > 0) {
                        window.logger.log('Drawing defect marks to PDF for ZIP export:', defectMarksToExport.length);
                        defectMarksToExport.forEach(defectMark => {
                            // æª¢æŸ¥æ˜¯å¦æœ‰canvasPositionï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨èˆŠåº§æ¨™ç³»çµ±
                            if (!defectMark.canvasPosition && (defectMark.x !== undefined || defectMark.y !== undefined)) {
                                defectMark.canvasPosition = { x: defectMark.x || 0, y: defectMark.y || 0 };
                            }
                            
                            if (defectMark.canvasPosition) {
                                window.logger.log('Drawing defect mark to PDF:', defectMark.id, 'Canvas position:', defectMark.canvasPosition);
                                drawDefectMarkOnPDF(firstPage, defectMark, canvasWidth, canvasHeight, width, height);
                            } else {
                                window.logger.warn('Defect mark missing canvasPosition:', defectMark);
                            }
                        });
                    }

                    // ç”ŸæˆPDF bytes
                    window.logger.log('Generating annotated PDF bytes for ZIP...');
                    const pdfBytes = await newPdfDoc.save();
                    window.logger.log('Annotated PDF bytes generated, size:', pdfBytes.length);
                    
                    // æ·»åŠ åˆ°ZIP
                    zip.file(`Floor_Plan_${pdfFilename}`, pdfBytes);
                    window.logger.log('Annotated floor plan PDF added to ZIP');
                    
                } catch (error) {
                    window.logger.error('Error generating annotated PDF for ZIP:', error);
                    // å¦‚æœç”Ÿæˆå¸¶è¨»é‡‹çš„ PDF å¤±æ•—ï¼Œä½¿ç”¨åŸå§‹ PDF
                    const binaryString = atob(pdfBase64);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    zip.file(`Floor_Plan_${pdfFilename}`, bytes);
                    window.logger.log('Fallback: Original floor plan PDF added to ZIP');
                }
            } else {
                // æ²’æœ‰æ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜ï¼Œä½¿ç”¨åŸå§‹ PDF
                window.logger.log('No labels or defect marks, using original PDF');
                const binaryString = atob(pdfBase64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                zip.file(`Floor_Plan_${pdfFilename}`, bytes);
                window.logger.log('Original floor plan PDF added to ZIP');
            }
        } else {
            window.logger.warn('No floor plan PDF data found for export');
        }
    } catch (error) {
        window.logger.error('Error exporting floor plan PDF:', error);
    }
}

// å°å‡ºç…§ç‰‡åˆ° ZIP - èˆ‡ pne.html é‚è¼¯å®Œå…¨ä¸€è‡´
async function exportPhotosToZipPneStyle(zip) {
    try {
        window.logger.log('=== Photo Export Debug Info ===');
        window.logger.log('photoFolders.length:', photoFolders.length);
        window.logger.log('photoFolders:', photoFolders);
        window.logger.log('allPhotos.length:', allPhotos.length);
        window.logger.log('allPhotos:', allPhotos);
        window.logger.log('submittedData.length:', submittedData.length);
        window.logger.log('submittedData:', submittedData);
        window.logger.log('================================');
        
        // Check if we have any photos to export
        const hasPhotoFolders = photoFolders && photoFolders.length > 0;
        const hasAllPhotos = allPhotos && allPhotos.length > 0;
        const hasSubmittedDataPhotos = submittedData && submittedData.some(record => record.photoFilenames && record.photoFilenames.length > 0);
        
        if (!hasPhotoFolders && !hasAllPhotos && !hasSubmittedDataPhotos) {
            window.logger.warn('No photos available for export');
            return;
        }
        
        if (photoFolders.length > 0) {
        const photosFolder = zip.folder("Inspection_Photos");
        
        for (const folder of photoFolders) {
                window.logger.log('Processing folder:', folder.name, 'with', folder.photos.length, 'photos');
                const folderInZip = photosFolder.folder(folder.name);
                
                for (const filename of folder.photos) {
                    const photoData = allPhotos.find(f => f.name === filename);
                    window.logger.log('Looking for file:', filename, 'found:', !!photoData, 'size:', photoData?.size);
                    
                    // å„ªå…ˆä½¿ç”¨åŸå§‹æª”ï¼ˆè‹¥å¯é€é File System Access API å–å¾—ï¼‰
                    if (photoData && photoData.webkitRelativePath && window.showDirectoryPicker) {
                        try {
                            const dirHandle = await window.storageAdapter.getItem('pne_photos_dir_handle');
                            if (dirHandle && dirHandle.getDirectoryHandle) {
                                const pathParts = photoData.webkitRelativePath.split('/');
                                let currentHandle = dirHandle;
                                for (let i = 0; i < pathParts.length - 1; i++) {
                                    const part = pathParts[i];
                                    if (part) currentHandle = await currentHandle.getDirectoryHandle(part);
                                }
                                const fileHandle = await currentHandle.getFileHandle(pathParts[pathParts.length - 1]);
                                const file = await fileHandle.getFile();
                                const arrayBuffer = await file.arrayBuffer();
                                const originalBlob = new Blob([arrayBuffer], { type: file.type || 'image/jpeg' });
                                
                                // Apply watermark if enabled
                                const inspectionDate = getInspectionDateForPhoto(filename);
                                const watermarkedBlob = await addWatermarkToPhoto(originalBlob, inspectionDate);
                                folderInZip.file(photoData.name, watermarkedBlob);
                                window.logger.log('Added watermarked photo via File System Access API:', filename);
                                continue;
                            }
                        } catch (e) {
                            window.logger.warn('Failed to read original file via FS API, fallback to cached dataURL/Blob:', filename, e);
                        }
                    }
                    
                    if (photoData && photoData.blob) {
                        // ä½¿ç”¨å­˜å„²çš„ Blob å°è±¡ï¼ˆå·²ç¶“èª¿æ•´éå¤§å°ï¼‰
                        const inspectionDate = getInspectionDateForPhoto(filename);
                        const watermarkedBlob = await addWatermarkToPhoto(photoData.blob, inspectionDate);
                        folderInZip.file(photoData.name, watermarkedBlob);
                        window.logger.log('Added watermarked photo blob:', filename);
                    } else if (photoData && photoData.dataURL) {
                        // ä½¿ç”¨ dataURL å‰µå»º Blob
                        const blob = dataURLToBlob(photoData.dataURL);
                        const inspectionDate = getInspectionDateForPhoto(filename);
                        const watermarkedBlob = await addWatermarkToPhoto(blob, inspectionDate);
                        folderInZip.file(photoData.name, watermarkedBlob);
                        window.logger.log('Added watermarked photo from dataURL:', filename);
                    } else {
                        // å¦‚æœæ²’æœ‰æ‰¾åˆ°ç…§ç‰‡ç‰©ä»¶ï¼Œå‰µå»ºä½”ä½ç¬¦åœ–ç‰‡
                        window.logger.warn(`Photo file not found: ${filename}, creating placeholder image`);
                        
                        // å‰µå»ºä¸€å€‹ç°¡å–®çš„ 1x1 åƒç´ é€æ˜ PNG åœ–ç‰‡
                        const placeholderImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==';
                        
                        // å°‡ base64 è½‰æ›ç‚º Blob
                        const byteCharacters = atob(placeholderImage.split(',')[1]);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const placeholderBlob = new Blob([byteArray], {type: 'image/png'});
                        
            folderInZip.file(photoData?.name || filename, placeholderBlob);
                    }
                }
            }
        } else {
            // å¦‚æœæ²’æœ‰ photoFoldersï¼Œå˜—è©¦å¾ submittedData é‡å»º
            if (submittedData.length > 0) {
                window.logger.log('No photoFolders found, rebuilding from submittedData...');
                const photosFolder = zip.folder("Inspection_Photos");
                
                // Process each record sequentially to ensure proper async handling
                for (const record of submittedData) {
                    if (record.photoFilenames && record.photoFilenames.length > 0) {
                        const folderName = record.folderName || `${record.locationId}_folder`;
                        window.logger.log('Creating folder:', folderName, 'with', record.photoFilenames.length, 'photos');
                        const folderInZip = photosFolder.folder(folderName);
                        
                        // Process each photo in the record sequentially
                        for (const filename of record.photoFilenames) {
                            const photoData = allPhotos.find(f => f.name === filename);
                            if (photoData && photoData.blob) {
                                const inspectionDate = record.inspectionDate || getInspectionDateForPhoto(filename);
                                const watermarkedBlob = await addWatermarkToPhoto(photoData.blob, inspectionDate);
                                folderInZip.file(photoData.name, watermarkedBlob);
                                window.logger.log('Added watermarked photo to folder:', folderName, filename);
                            } else if (photoData && photoData.dataURL) {
                                const blob = dataURLToBlob(photoData.dataURL);
                                const inspectionDate = record.inspectionDate || getInspectionDateForPhoto(filename);
                                const watermarkedBlob = await addWatermarkToPhoto(blob, inspectionDate);
                                folderInZip.file(photoData.name, watermarkedBlob);
                                window.logger.log('Added watermarked photo from dataURL to folder:', folderName, filename);
                            } else {
                                // å‰µå»ºä½”ä½ç¬¦åœ–ç‰‡
                                const placeholderImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==';
                                const byteCharacters = atob(placeholderImage.split(',')[1]);
                                const byteNumbers = new Array(byteCharacters.length);
                                for (let i = 0; i < byteCharacters.length; i++) {
                                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                                }
                                const byteArray = new Uint8Array(byteNumbers);
                                const placeholderBlob = new Blob([byteArray], {type: 'image/png'});
                                folderInZip.file(filename, placeholderBlob);
                                window.logger.log('Added placeholder to folder:', folderName, filename);
                            }
                        }
                    }
                }
            } else {
                window.logger.log('No photoFolders to export and no submittedData available');
            }
        }
        
        window.logger.log('Photos added to ZIP (pne.html style)');
    } catch (error) {
        window.logger.error('Error exporting photos (pne.html style):', error);
        // Re-throw the error so it can be handled by the calling function
        throw error;
    }
}

// å°å‡ºç…§ç‰‡åˆ° ZIP
async function exportPhotosToZip(zip, sortToFolder) {
    try {
        // ç¢ºä¿ç…§ç‰‡æ•¸æ“šå¯ç”¨
        let photosToExport = [];
        let foldersToExport = [];
        
        // å„ªå…ˆä½¿ç”¨ç•¶å‰è¨˜æ†¶é«”ä¸­çš„ç…§ç‰‡æ•¸æ“š
        if (allPhotos && allPhotos.length > 0) {
            photosToExport = allPhotos;
            window.logger.log('Using photos from memory:', photosToExport.length);
        } else if (photoFolders && photoFolders.length > 0) {
            foldersToExport = photoFolders;
            window.logger.log('Using photo folders from memory:', foldersToExport.length);
        } else {
            // å˜—è©¦å¾å­˜å„²ä¸­æ¢å¾©ç…§ç‰‡æ•¸æ“š
            try {
                const savedData = await window.storageAdapter.getItem('photoNumberExtractorData');
                if (savedData && savedData.photoMetadata && savedData.photoMetadata.length > 0) {
                    photosToExport = savedData.photoMetadata.map(meta => ({
                        name: meta.name,
                        size: meta.size || 0,
                        type: meta.type || 'image/jpeg',
                        lastModified: meta.lastModified || Date.now(),
                        webkitRelativePath: meta.webkitRelativePath || '',
                        dataURL: meta.dataURL || ''
                    }));
                    window.logger.log('Restored photos from storage:', photosToExport.length);
                }
                
                if (savedData && savedData.photoFolders && savedData.photoFolders.length > 0) {
                    foldersToExport = savedData.photoFolders;
                    window.logger.log('Restored photo folders from storage:', foldersToExport.length);
                }
            } catch (error) {
                window.logger.error('Error restoring photos from storage:', error);
            }
        }
        
        if (sortToFolder) {
            // å•Ÿç”¨ç…§ç‰‡æ’åºåˆ°è³‡æ–™å¤¾
            window.logger.log('Photo sorting to folders enabled');
            window.logger.log('Available folders:', foldersToExport.length);
            window.logger.log('Available photos:', photosToExport.length);
            window.logger.log('Assigned photos structure:', assignedPhotos);
            
            const photosFolder = zip.folder("Inspection_Photos");
            
            if (foldersToExport.length > 0) {
                // ä½¿ç”¨ç¾æœ‰çš„ç…§ç‰‡è³‡æ–™å¤¾çµæ§‹
                window.logger.log('Using existing photo folder structure:', foldersToExport.length);
                
                for (const folder of foldersToExport) {
            const folderZip = photosFolder.folder(folder.name);
            
            for (const photo of folder.photos) {
                try {
                            // æª¢æŸ¥æ˜¯å¦åœ¨ file:// å”è­°ä¸‹é‹è¡Œ
                            if (window.location.protocol === 'file:' && photo.dataURL) {
                                // åœ¨ file:// å”è­°ä¸‹ï¼Œç›´æ¥å¾ dataURL å‰µå»º blob
                                const blob = dataURLToBlob(photo.dataURL);
                                folderZip.file(photo.name, blob);
                            } else if (photo.url) {
                                // åœ¨é file:// å”è­°ä¸‹ï¼Œä½¿ç”¨ fetch
                    const response = await fetch(photo.url);
                    const blob = await response.blob();
                    folderZip.file(photo.name, blob);
                            }
                } catch (error) {
                    window.logger.error(`Error adding photo ${photo.name}:`, error);
                }
            }
                }
            } else if (photosToExport.length > 0) {
                // æ²’æœ‰ç¾æˆçš„è³‡æ–™å¤¾çµæ§‹ï¼Œä½†éœ€è¦æ’åºï¼Œå˜—è©¦å¾ assignedPhotos å‰µå»ºè³‡æ–™å¤¾
                window.logger.log('Creating folder structure from assigned photos');
                
                // å¾ assignedPhotos å‰µå»ºè³‡æ–™å¤¾çµæ§‹
                const folderStructure = {};
                
                // éæ­·æ‰€æœ‰ç…§ç‰‡ï¼Œæ ¹æ“š assignedPhotos åˆ†é¡
                for (const photo of photosToExport) {
                    let assignedToCategory = null;
                    
                    // æª¢æŸ¥ç…§ç‰‡è¢«åˆ†é…åˆ°å“ªå€‹åˆ†é¡
                    for (const [category, filenames] of Object.entries(assignedPhotos || {})) {
                        // è™•ç† Set å°è±¡æˆ–æ•¸çµ„
                        const filenameArray = Array.isArray(filenames) ? filenames : Array.from(filenames || []);
                        if (filenameArray.includes(photo.name)) {
                            assignedToCategory = category;
                            break;
                        }
                    }
                    
                    if (assignedToCategory) {
                        if (!folderStructure[assignedToCategory]) {
                            folderStructure[assignedToCategory] = [];
                        }
                        folderStructure[assignedToCategory].push(photo);
                    } else {
                        // æœªåˆ†é…çš„ç…§ç‰‡æ”¾åˆ° "Unassigned" è³‡æ–™å¤¾
                        if (!folderStructure['Unassigned']) {
                            folderStructure['Unassigned'] = [];
                        }
                        folderStructure['Unassigned'].push(photo);
                    }
                }
                
                // å‰µå»ºè³‡æ–™å¤¾ä¸¦æ·»åŠ ç…§ç‰‡
                for (const [categoryName, photos] of Object.entries(folderStructure)) {
                    const folderZip = photosFolder.folder(categoryName);
                    
                    for (const photo of photos) {
                        try {
                            if (photo.dataURL) {
                                const blob = dataURLToBlob(photo.dataURL);
                                folderZip.file(photo.name, blob);
                            }
                        } catch (error) {
                            window.logger.error(`Error adding photo ${photo.name} to ${categoryName}:`, error);
                        }
                    }
                }
            } else {
                window.logger.warn('No photos available for folder sorting');
            }
        } else if (photosToExport.length > 0) {
            // ä¸æ’åºï¼Œç›´æ¥æ·»åŠ æ‰€æœ‰ç…§ç‰‡
            const photosFolder = zip.folder("Inspection_Photos");
            
            for (const photo of photosToExport) {
                try {
                    if (photo.dataURL) {
                        // ç›´æ¥å¾ dataURL å‰µå»º blobï¼Œé¿å…ä½¿ç”¨ fetch
                        const blob = dataURLToBlob(photo.dataURL);
                        photosFolder.file(photo.name, blob);
                    }
    } catch (error) {
                    window.logger.error(`Error adding photo ${photo.name}:`, error);
                }
            }
        } else {
            window.logger.warn('No photos available for export');
        }
        
        window.logger.log('Photos added to ZIP');
    } catch (error) {
        window.logger.error('Error exporting photos:', error);
    }
}

// å°‡ dataURL è½‰æ›ç‚º Blob çš„è¼”åŠ©å‡½æ•¸
function dataURLToBlob(dataURL) {
    try {
        // è§£æ dataURL
        const arr = dataURL.split(',');
        const mime = arr[0].match(/:(.*?);/)[1];
        const bstr = atob(arr[1]);
        let n = bstr.length;
        const u8arr = new Uint8Array(n);
        
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        
        return new Blob([u8arr], { type: mime });
    } catch (error) {
        window.logger.error('Error converting dataURL to blob:', error);
        throw error;
    }
}

// Save as PNE file
const saveAsPNEBtn = document.querySelector('.pne-dropdown-item[data-action="saveas"]');
saveAsPNEBtn.addEventListener('click', async function() {
    // é—œé–‰ä¸‹æ‹‰é¸å–®
    const pneDropdown = document.querySelector('.pne-dropdown');
    if (pneDropdown) {
        pneDropdown.style.display = 'none';
    }
    
    // é¡¯ç¤ºé€²åº¦æŒ‡ç¤ºå™¨
    const showPNESaveLoading = (message = 'æ­£åœ¨æº–å‚™æ•¸æ“š...') => {
        const loadingStatus = document.getElementById('photoUploadLoadingStatus');
        const statusTitle = document.getElementById('photoUploadStatusTitle');
        const statusMessage = document.getElementById('photoUploadStatusMessage');
        if (loadingStatus && statusTitle && statusMessage) {
            statusTitle.textContent = 'æ­£åœ¨ä¿å­˜ PNE æ–‡ä»¶...';
            statusMessage.textContent = message;
            loadingStatus.style.display = 'flex';
        }
    };
    
    const hidePNESaveLoading = () => {
        const loadingStatus = document.getElementById('photoUploadLoadingStatus');
        if (loadingStatus) {
            loadingStatus.style.display = 'none';
        }
    };
    
    try {
        showPNESaveLoading('æ­£åœ¨æ”¶é›†æ•¸æ“š...');
        window.logger.log('Starting PNE file save process...');
        window.logger.log('Total photos:', allPhotos.length);
        // æ”¶é›† localStorage å…§å®¹ï¼ˆé¿å… {...localStorage} åœ¨éƒ¨åˆ†ç€è¦½å™¨å–ä¸åˆ°è³‡æ–™ï¼‰
        const localStorageData = {};
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            localStorageData[key] = localStorage.getItem(key);
        }

        // å®‰å…¨å–å¾—æ¨“å±¤å¹³é¢æ¨™ç±¤/ç¼ºé™·æ¨™è¨˜ï¼ˆé¿å…æœªå®£å‘Šè®Šæ•¸ ReferenceErrorï¼‰
        const floorPlanLabels = (typeof labels !== 'undefined' && Array.isArray(labels))
            ? labels
            : (typeof window !== 'undefined' && Array.isArray(window.labels) ? window.labels : []);
        const floorPlanDefectMarks = (typeof defectMarks !== 'undefined' && Array.isArray(defectMarks))
            ? defectMarks
            : (typeof window !== 'undefined' && Array.isArray(window.defectMarks) ? window.defectMarks : []);

        // æ”¶é›† header æ¬„ä½
        const headerFields = {
            inspectionNo: (document.getElementById('locationId') || {}).value || '',
            inspectionDate: (document.getElementById('inspectionDate') || {}).value || '',
            floor: (document.getElementById('floorHeader') || {}).value || '',
            areaName: (document.getElementById('areaNameHeader') || {}).value || '',
            roomNo: (document.getElementById('roomNo') || {}).value || '',
                sortEnabled: !!(document.getElementById('sortPhotosToFolder') && document.getElementById('sortPhotosToFolder').checked)
        };

        // æ”¶é›†æ‰€æœ‰è³‡æ–™ï¼ŒåŒ…æ‹¬ç…§ç‰‡åˆ†é…è³‡æ–™
        const data = {
            // ç‰ˆæœ¬èˆ‡æ™‚é–“
            version: '7.1.0',
            exportDate: new Date().toISOString(),

            // Header/UI ç‹€æ…‹
            headerFields: headerFields,

            // æª”æ¡ˆè·¯å¾‘è³‡è¨Š
            filePaths: {
                // PDF æª”æ¡ˆè·¯å¾‘ï¼ˆæ¨“å±¤å¹³é¢åœ–ï¼‰- åªä¿å­˜æ–‡ä»¶å¼•ç”¨
                pdfPath: localStorage.getItem('pne_floorplan_filename') || '',
                pdfData: localStorage.getItem('pne_floorplan_data') || '',
                // ç§»é™¤PDF base64æ•¸æ“šï¼Œåªä¿å­˜æ–‡ä»¶å¼•ç”¨
                pdfFileReference: (() => {
                    try {
                        const floorPlanData = JSON.parse(localStorage.getItem('pne_floorplan_data') || '{}');
                        return floorPlanData.fileReference || null;
                    } catch (e) {
                        return null;
                    }
                })(),
                
                // ç…§ç‰‡è³‡æ–™å¤¾è·¯å¾‘
                photoFolderPath: folderNameDisplay.textContent || '',
                photoFolderName: folderNameDisplay.textContent.split('/').pop() || '',
                
                // ç…§ç‰‡æª”æ¡ˆè·¯å¾‘åˆ—è¡¨
                photoFilePaths: allPhotos.map(file => ({
                    name: file.name,
                    webkitRelativePath: file.webkitRelativePath || '',
                    fullPath: file.webkitRelativePath ? `${folderNameDisplay.textContent}/${file.webkitRelativePath}` : file.name
                }))
            },

            // æ–°å¢ï¼šæ–‡ä»¶å¼•ç”¨ç³»çµ±ï¼ˆåŸºæ–¼ JSON çµæ§‹ç¤ºä¾‹ï¼‰
            files: (() => {
                const files = [];
                
                // æ·»åŠ  PDF æ–‡ä»¶å¼•ç”¨
                const pdfFilename = localStorage.getItem('pne_floorplan_filename');
                const pdfData = localStorage.getItem('pne_floorplan_data');
                if (pdfFilename && pdfData) {
                    try {
                        const floorPlanData = JSON.parse(pdfData);
                        files.push({
                            id: 'pdf_floorplan',
                            name: pdfFilename,
                            path: pdfFilename, // ç›¸å°è·¯å¾‘
                            type: 'pdf',
                            description: 'æ¨“å±¤å¹³é¢åœ– PDF æ–‡ä»¶',
                            uploadDate: floorPlanData.uploadDate || new Date().toISOString(),
                            size: `${(floorPlanData.fileSize / 1024 / 1024).toFixed(2)} MB`,
                            fileReference: floorPlanData.fileReference,
                            hasBase64Data: floorPlanData.hasBase64Data || false
                        });
                    } catch (e) {
                        window.logger.error('Error parsing PDF data:', e);
                    }
                }
                
                // æ·»åŠ ç…§ç‰‡æ–‡ä»¶å¼•ç”¨ï¼ˆä¸åŒ…å« dataURL ä»¥æ¸›å°‘æ–‡ä»¶å¤§å°ï¼‰
                allPhotos.forEach((photo, index) => {
                    files.push({
                        id: `photo_${index}`,
                        name: photo.name,
                        path: photo.webkitRelativePath || photo.name,
                        type: 'image',
                        description: `æª¢æŸ¥ç…§ç‰‡ - ${photo.name}`,
                        uploadDate: new Date(photo.lastModified).toISOString(),
                        size: `${(photo.size / 1024 / 1024).toFixed(2)} MB`,
                        webkitRelativePath: photo.webkitRelativePath || '',
                        // ä¸ä¿å­˜ dataURLï¼Œå¾åŸå§‹æ–‡ä»¶å¤¾é‡æ–°è®€å–
                        hasDataURL: !!(photo.dataURL)
                    });
                });
                
                return files;
            })(),

            // ç…§ç‰‡åŸºæœ¬èˆ‡æŒ‡æ´¾çµ±è¨ˆ
            totalPhotos: allPhotos.length,
            totalAssignments: Object.values(assignedPhotos).reduce((sum, photos) => sum + photos.size, 0),
            // å°æ–¼å¤§é‡ç…§ç‰‡ï¼Œä¸ä¿å­˜ dataURL ä»¥é¿å…è¶…éå­—ç¬¦ä¸²é•·åº¦é™åˆ¶
            photoMetadata: (() => {
                const PHOTO_LIMIT_FOR_DATAURL = 500; // è¶…é 500 å¼µç…§ç‰‡æ™‚ä¸ä¿å­˜ dataURL
                const shouldSaveDataURL = allPhotos.length <= PHOTO_LIMIT_FOR_DATAURL;
                
                if (!shouldSaveDataURL) {
                    window.logger.log(`ç…§ç‰‡æ•¸é‡ (${allPhotos.length}) è¶…éé™åˆ¶ (${PHOTO_LIMIT_FOR_DATAURL})ï¼Œä¸ä¿å­˜ dataURL ä»¥æ¸›å°‘æ–‡ä»¶å¤§å°`);
                }
                
                return allPhotos.map(file => {
                    let dataURL = '';
                    
                    // åªæœ‰åœ¨ç…§ç‰‡æ•¸é‡è¼ƒå°‘æ™‚æ‰ä¿å­˜ dataURL
                    if (shouldSaveDataURL) {
                        // å¦‚æœæ²’æœ‰ dataURLï¼Œå˜—è©¦å¾ DOM ä¸­ç²å–
                        dataURL = file.dataURL || '';
                        if (!dataURL) {
                            // ä½¿ç”¨æ­£ç¢ºçš„ selector: data-filename è€Œä¸æ˜¯ data-photo-name
                            const photoItem = document.querySelector(`[data-filename="${file.name}"]`);
                            if (photoItem) {
                                const img = photoItem.querySelector('img');
                                if (img && img.src && img.src.startsWith('data:')) {
                                    dataURL = img.src;
                                }
                            }
                        }
                    }
                    
                    return {
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        lastModified: file.lastModified || Date.now(),
                        webkitRelativePath: file.webkitRelativePath || '',
                        dataURL: dataURL, // å¤§é‡ç…§ç‰‡æ™‚ç‚ºç©ºå­—ç¬¦ä¸²
                        hasDataURL: !!dataURL // æ¨™è¨˜æ˜¯å¦æœ‰ dataURL
                    };
                });
            })(),

            // ä¸»è³‡æ–™è¡¨
            inspectionRecords: submittedData,
            submittedDefectEntries: submittedDefectEntries,
            rowIdCounter: rowIdCounter,
            categories: categories,
            defectTypes: defectTypes,

            // ç…§ç‰‡åˆ†é…è³‡æ–™
            photoAssignments: {
                categoryNumbers: categoryNumbers,
                assignedPhotos: Object.fromEntries(
                    Object.entries(assignedPhotos).map(([key, value]) => [key, Array.from(value)])
                ),
                defectEntries: defectEntries
            },

            // App ç‹€æ…‹
            uploadedFolderPath: folderNameDisplay.textContent,
            submittedFilenames: Array.from(submittedFilenames),
            photoFolders: photoFolders,
            localStorage: localStorageData,

            // æ¨“å±¤å¹³é¢åœ–
            floorPlanLabels: floorPlanLabels,
            floorPlanDefectMarks: floorPlanDefectMarks,
            
            // åµŒå…¥ PDF æª”æ¡ˆæ•¸æ“š
            embeddedPDF: (() => {
                const pdfBase64 = localStorage.getItem('pne_floorplan_base64');
                const pdfData = localStorage.getItem('pne_floorplan_data');
                const pdfFilename = localStorage.getItem('pne_floorplan_filename');
                
                if (pdfBase64 && pdfData && pdfFilename) {
                    try {
                        const floorPlanData = JSON.parse(pdfData);
                        window.logger.log('Embedding PDF in PNE file:', pdfFilename, 'Size:', pdfBase64.length, 'characters');
                        return {
                            filename: pdfFilename,
                            base64Data: pdfBase64,
                            metadata: floorPlanData,
                            hasEmbeddedPDF: true,
                            size: pdfBase64.length
                        };
                    } catch (e) {
                        window.logger.error('Error parsing PDF data for embedding:', e);
                        return null;
                    }
                } else {
                    window.logger.log('No PDF data found for embedding in PNE file');
                    return null;
                }
            })(),
            
            // æ¨“å±¤å¹³é¢åœ–è¦–åœ–ç‹€æ…‹
            floorPlanViewState: {
                scale: window.currentScale || 1.0,
                translateX: window.translateX || 0,
                translateY: window.translateY || 0,
                baseScale: (typeof baseScale !== 'undefined' ? baseScale : (window.baseScale || 1.0)),
                labelSizeScale: (window.labelSizeScale || 24),
                defectMarkSizeScale: (window.defectMarkSizeScale || 24)
            },
            
            // ç…§ç‰‡æäº¤ç‹€æ…‹
            photoSubmissionStatus: {
                submittedPhotos: Array.from(submittedFilenames),
                photoAssignments: Object.fromEntries(
                    Object.entries(assignedPhotos).map(([key, value]) => [key, Array.from(value)])
                )
            },
            
            // ä»»å‹™æ•¸æ“š
            currentTask: currentTask
        };

        // ä½¿ç”¨ Web Worker é€²è¡Œç•°æ­¥ JSON åºåˆ—åŒ–ï¼Œé¿å…é˜»å¡ä¸»ç·šç¨‹
        showPNESaveLoading('æ­£åœ¨åºåˆ—åŒ–æ•¸æ“šï¼ˆé€™å¯èƒ½éœ€è¦ä¸€äº›æ™‚é–“ï¼‰...');
        
        const taskId = 'pne-save-' + Date.now();
        let worker = null;
        let jsonString = null;
        
        try {
            // æª¢æŸ¥æ˜¯å¦æ”¯æŒ Web Worker
            if (typeof Worker !== 'undefined') {
                // å‰µå»º Web Worker
                try {
                    worker = new Worker('js/workers/pne-saver.worker.js');
                    
                    // ç›£è½ Worker æ¶ˆæ¯
                    const workerPromise = new Promise((resolve, reject) => {
                        worker.onmessage = function(e) {
                            const { type, message, progress, result, error, duration, size } = e.data;
                            
                            if (type === 'progress') {
                                // æ›´æ–°é€²åº¦
                                showPNESaveLoading(message || `è™•ç†ä¸­... ${progress}%`);
                                window.logger.log('PNE save progress:', message, progress + '%');
                            } else if (type === 'success') {
                                // åºåˆ—åŒ–æˆåŠŸ
                                window.logger.log('PNE file serialized successfully. Duration:', duration, 'ms, Size:', size, 'bytes');
                                jsonString = result;
                                resolve(result);
                            } else if (type === 'error') {
                                // åºåˆ—åŒ–å¤±æ•—
                                window.logger.error('PNE serialization error:', error);
                                const errorMessage = error && error.message 
                                    ? error.message 
                                    : (error && typeof error === 'string' ? error : 'åºåˆ—åŒ–å¤±æ•—');
                                reject(new Error(errorMessage));
                            }
                        };
                        
                        worker.onerror = function(error) {
                            window.logger.error('Worker error:', error);
                            reject(new Error('Worker åŸ·è¡ŒéŒ¯èª¤: ' + error.message));
                        };
                        
                        // è¨­ç½®è¶…æ™‚ï¼ˆ5åˆ†é˜ï¼‰
                        setTimeout(() => {
                            if (jsonString === null) {
                                reject(new Error('åºåˆ—åŒ–è¶…æ™‚ï¼Œæ•¸æ“šå¯èƒ½éå¤§'));
                            }
                        }, 5 * 60 * 1000);
                    });
                    
                    // ç™¼é€æ•¸æ“šåˆ° Worker
                    showPNESaveLoading('æ­£åœ¨æº–å‚™åºåˆ—åŒ–ä»»å‹™...');
                    worker.postMessage({ data: data, taskId: taskId });
                    
                    // ç­‰å¾… Worker å®Œæˆ
                    await workerPromise;
                    
                } catch (workerError) {
                    window.logger.warn('Web Worker not available, falling back to direct serialization:', workerError);
                    // å¦‚æœ Worker ä¸å¯ç”¨ï¼Œä½¿ç”¨ç›´æ¥åºåˆ—åŒ–ï¼ˆä½†æœƒé˜»å¡ï¼‰
                    showPNESaveLoading('ä½¿ç”¨ç›´æ¥åºåˆ—åŒ–ï¼ˆå¯èƒ½æœƒæš«æ™‚ç„¡éŸ¿æ‡‰ï¼‰...');
                    try {
                        jsonString = JSON.stringify(data, null, 2);
                    } catch (stringifyError) {
                        if (stringifyError.name === 'RangeError' && stringifyError.message.includes('string length')) {
                            // æ•¸æ“šå¤ªå¤§ï¼Œç„¡æ³•åºåˆ—åŒ–
                            hidePNESaveLoading();
                            showNotification('æ•¸æ“šéå¤§ç„¡æ³•ä¿å­˜ã€‚ç…§ç‰‡æ•¸é‡éå¤šæ™‚ï¼Œè«‹æ¸›å°‘ç…§ç‰‡æ•¸é‡æˆ–è¯ç¹«é–‹ç™¼è€…ã€‚', 'error');
                            window.logger.error('Data too large to serialize. Photo count:', allPhotos.length);
                            return;
                        }
                        throw stringifyError;
                    }
                } finally {
                    // æ¸…ç† Worker
                    if (worker) {
                        worker.terminate();
                        worker = null;
                    }
                }
            } else {
                // ç€è¦½å™¨ä¸æ”¯æŒ Web Workerï¼Œä½¿ç”¨ç›´æ¥åºåˆ—åŒ–
                window.logger.warn('Web Worker not supported, using direct serialization');
                showPNESaveLoading('ä½¿ç”¨ç›´æ¥åºåˆ—åŒ–ï¼ˆå¯èƒ½æœƒæš«æ™‚ç„¡éŸ¿æ‡‰ï¼‰...');
                jsonString = JSON.stringify(data, null, 2);
            }
            
        } catch (serializeError) {
            window.logger.error('Serialization error:', serializeError);
            hidePNESaveLoading();
            showNotification('åºåˆ—åŒ–æ•¸æ“šå¤±æ•—: ' + serializeError.message, 'error');
            return;
        }
        
        if (!jsonString) {
            hidePNESaveLoading();
            showNotification('åºåˆ—åŒ–å¤±æ•—ï¼šæœªç”Ÿæˆæ•¸æ“š', 'error');
            return;
        }
        
        // å‰µå»º Blob å’Œä¸‹è¼‰
        showPNESaveLoading('æ­£åœ¨å‰µå»ºæ–‡ä»¶...');
        
        try {
            const blob = new Blob([jsonString], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            // ç”Ÿæˆæ–‡ä»¶åï¼šä»»å‹™åç¨± _ æ—¥æœŸ _ æ™‚é–“
            let fileName = '';
            
            // ç²å–ä»»å‹™åç¨±
            if (currentTask && currentTask.name && currentTask.name.trim()) {
                // æ¸…ç†ä»»å‹™åç¨±ä¸­çš„éæ³•å­—ç¬¦
                const cleanTaskName = currentTask.name.trim().replace(/[\\/:*?"<>|]/g, '_');
                fileName = cleanTaskName;
            } else {
                // å¦‚æœæ²’æœ‰ä»»å‹™åç¨±ï¼Œä½¿ç”¨é»˜èªåç¨±
                let folderName = folderNameDisplay.textContent.trim() || 'unknown';
                folderName = folderName.replace(/[^a-zA-Z0-9_-]/g, '_');
                fileName = `PNE_${folderName}`;
            }
            
            // ç²å–ç•¶å‰æ—¥æœŸå’Œæ™‚é–“
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            
            // çµ„åˆæ–‡ä»¶åï¼šä»»å‹™åç¨± _ æ—¥æœŸ _ æ™‚é–“
            const dateStr = `${year}${month}${day}`;
            const timeStr = `${hours}${minutes}`;
            fileName = `${fileName} _ ${dateStr} _ ${timeStr}`;
            
            // æ·»åŠ  .pne å‰¯æª”å
            if (!fileName.toLowerCase().endsWith('.pne')) {
                fileName += '.pne';
            }
            
            // æ¸…ç†æœ€çµ‚æ–‡ä»¶åä¸­çš„éæ³•å­—ç¬¦
            fileName = fileName.replace(/[\\/:*?"<>|]/g, '_');
            
            a.download = fileName;
            a.href = url;
            a.style.display = 'none';
            document.body.appendChild(a);
            
            // å˜—è©¦è§¸ç™¼ä¸‹è¼‰
            a.click();
            hidePNESaveLoading();
            showNotification('PNE æª”æ¡ˆå·²åŒ¯å‡ºï¼ŒåŒ…å«å®Œæ•´è³‡æ–™ï¼', 'success');
            
            // æ¸…ç†è³‡æº
            setTimeout(() => {
                if (document.body.contains(a)) {
                    document.body.removeChild(a);
                }
                URL.revokeObjectURL(url);
            }, 1000);
            
        } catch (downloadError) {
            window.logger.error('Download failed:', downloadError);
            hidePNESaveLoading();
            
            // å¦‚æœä¸‹è¼‰å¤±æ•—ï¼Œå˜—è©¦åœ¨æ–°çª—å£ä¸­æ‰“é–‹
            try {
                const blob = new Blob([jsonString], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                window.open(url, '_blank');
                showNotification('PNE æª”æ¡ˆå·²åœ¨æ–°çª—å£ä¸­æ‰“é–‹ï¼Œè«‹æ‰‹å‹•ä¿å­˜ï¼', 'info');
            } catch (openError) {
                window.logger.error('Open in new window failed:', openError);
                showNotification('ç„¡æ³•ä¸‹è¼‰æª”æ¡ˆï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨è¨­å®šæˆ–å˜—è©¦åœ¨å…¶ä»–ç€è¦½å™¨ä¸­æ‰“é–‹ï¼', 'error');
            }
        }
    } catch (err) {
        window.logger.error('PNE file save error:', err);
        hidePNESaveLoading();
        showNotification('åŒ¯å‡º PNE æª”æ¡ˆå¤±æ•—: ' + (err.message || err.toString()), 'error');
    }
});
// æ¸…ç†PDFæ•¸æ“šå­˜å„²çš„å‡½æ•¸ï¼ˆå·²æ›´æ–°ï¼šç³»çµ±ä¸å†ä¿å­˜PDF base64æ•¸æ“šï¼‰
function clearPDFDataFromStorage() {
    try {
        // ç³»çµ±ç¾åœ¨åªä¿å­˜æ–‡ä»¶å¼•ç”¨ï¼Œä¸ä¿å­˜PDF base64æ•¸æ“š
        // æ­¤å‡½æ•¸ä¿ç•™ç”¨æ–¼å‘å¾Œå…¼å®¹ï¼Œä½†å¯¦éš›ä¸Šä¸å†éœ€è¦æ¸…ç†base64æ•¸æ“š
        window.logger.log('PDF storage system now only saves file references, no base64 data to clear');
    } catch (error) {
        window.logger.error('Error in PDF storage cleanup:', error);
    }
}

// é©—è­‰PDFæ–‡ä»¶å¼•ç”¨ä¸¦æä¾›é‡æ–°è¼‰å…¥åŠŸèƒ½
function validatePDFFileReference() {
    try {
        const floorPlanData = JSON.parse(localStorage.getItem('pne_floorplan_data') || '{}');
        const filename = localStorage.getItem('pne_floorplan_filename');
        
        if (floorPlanData.fileReference && filename) {
            window.logger.log('PDF file reference found:', floorPlanData.fileReference);
            window.logger.log('PDF filename:', filename);
            
            // é¡¯ç¤ºæç¤ºä¿¡æ¯ï¼Œå‘ŠçŸ¥ç”¨æˆ¶éœ€è¦é‡æ–°ä¸Šå‚³PDF
            if (typeof showNotification === 'function') {
                showNotification(`æª¢æ¸¬åˆ°PDFæ–‡ä»¶å¼•ç”¨ï¼š${filename}ã€‚è«‹é‡æ–°ä¸Šå‚³PDFæ–‡ä»¶ä»¥æŸ¥çœ‹æ¨“å±¤å¹³é¢åœ–ã€‚`, 'info');
            }
            
            return {
                hasReference: true,
                filename: filename,
                fileReference: floorPlanData.fileReference
            };
        }
        
        return { hasReference: false };
    } catch (error) {
        window.logger.error('Error validating PDF file reference:', error);
        return { hasReference: false };
    }
}

// PDFç”ŸæˆåŠŸèƒ½ - å°‡æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜ç¹ªè£½åˆ°PDFä¸Š
async function generateAnnotatedPDF() {
    try {
        // æª¢æŸ¥æ˜¯å¦æœ‰PDFæ–‡ä»¶
        const floorPlanData = JSON.parse(localStorage.getItem('pne_floorplan_data') || '{}');
        if (!floorPlanData.fileReference) {
            showNotification('è«‹å…ˆä¸Šå‚³PDFæ–‡ä»¶', 'error');
            return;
        }

        // åˆå§‹åŒ–æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜æ•¸çµ„ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        if (!window.labels) {
            window.labels = [];
        }
        if (!window.defectMarks) {
            window.defectMarks = [];
        }
        
        // æª¢æŸ¥æ˜¯å¦æœ‰æ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜
        if (window.labels.length === 0 && window.defectMarks.length === 0) {
            showNotification('æ²’æœ‰æ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜éœ€è¦ç¹ªè£½', 'warning');
            return;
        }
        
        window.logger.log('PDF Export - Labels count:', window.labels.length);
        window.logger.log('PDF Export - Defect marks count:', window.defectMarks.length);

        showNotification('æ­£åœ¨ç”Ÿæˆå¸¶æ¨™è¨»çš„PDFæ–‡ä»¶...', 'info');

        // ç²å–åŸå§‹PDFæ–‡ä»¶ï¼ˆéœ€è¦ç”¨æˆ¶é‡æ–°é¸æ“‡ï¼‰
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'application/pdf';
        fileInput.style.display = 'none';
        document.body.appendChild(fileInput);

        fileInput.click();

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) {
                document.body.removeChild(fileInput);
                return;
            }

            try {
                // è®€å–PDFæ–‡ä»¶
                const arrayBuffer = await file.arrayBuffer();
                
                // ä½¿ç”¨pdf-libåŠ è¼‰PDF
                const { PDFDocument, rgb } = PDFLib;
                const pdfDoc = await PDFDocument.load(arrayBuffer);
                const newPdfDoc = await PDFDocument.create();

                // ç²å–é é¢
                const pages = pdfDoc.getPages();
                const [firstPage] = await newPdfDoc.copyPages(pdfDoc, [0]);
                newPdfDoc.addPage(firstPage);

                // ç²å–é é¢å°ºå¯¸
                const { width, height } = firstPage.getSize();
                window.logger.log('PDF page size:', width, height);

                // ç²å–Canvaså°ºå¯¸ï¼ˆç”¨æ–¼åæ¨™è½‰æ›ï¼‰
                const floorPlanCanvas = document.getElementById('floorPlanCanvas');
                
                // ä½¿ç”¨ CSS å°ºå¯¸ï¼Œå› ç‚º canvasPosition æ˜¯åŸºæ–¼ CSS å°ºå¯¸è¨ˆç®—çš„
                const canvasWidth = parseFloat(floorPlanCanvas.style.width) || floorPlanCanvas.width / (window.outputScale || 1);
                const canvasHeight = parseFloat(floorPlanCanvas.style.height) || floorPlanCanvas.height / (window.outputScale || 1);
                
                window.logger.log('Canvas CSS size:', canvasWidth, canvasHeight);
                window.logger.log('Canvas actual size:', floorPlanCanvas.width, floorPlanCanvas.height);
                // æé«˜ PDF å°å‡ºçš„è§£æåº¦
                const exportScale = Math.max(2, Math.min(4, (window.devicePixelRatio || 1) * 1.5));
                window.logger.log('Output scale:', exportScale);

                // åˆå§‹åŒ–æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜æ•¸çµ„ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
                if (!window.labels) {
                    window.labels = [];
                }
                if (!window.defectMarks) {
                    window.defectMarks = [];
                }
                
                window.logger.log('PDF Export - Labels count:', window.labels.length);
                window.logger.log('PDF Export - Defect marks count:', window.defectMarks.length);

                // ç¹ªè£½æ¨™ç±¤
                if (window.labels.length > 0) {
                    window.logger.log('Drawing labels:', window.labels.length);
                    for (const label of window.labels) {
                        // æª¢æŸ¥æ˜¯å¦æœ‰canvasPositionï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨èˆŠåº§æ¨™ç³»çµ±
                        if (!label.canvasPosition && (label.x !== undefined || label.y !== undefined)) {
                            label.canvasPosition = { x: label.x || 0, y: label.y || 0 };
                        }
                        
                        if (label.canvasPosition) {
                            window.logger.log('Drawing label:', label.id, 'Canvas position:', label.canvasPosition);
                            await drawLabelOnPDF(firstPage, label, canvasWidth, canvasHeight, width, height);
                        } else {
                            window.logger.warn('Label missing canvasPosition:', label);
                        }
                    }
                }

                // ç¹ªè£½ç¼ºé™·æ¨™è¨˜
                if (window.defectMarks.length > 0) {
                    window.logger.log('Drawing defect marks:', window.defectMarks.length);
                    window.defectMarks.forEach(defectMark => {
                        // æª¢æŸ¥æ˜¯å¦æœ‰canvasPositionï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨èˆŠåº§æ¨™ç³»çµ±
                        if (!defectMark.canvasPosition && (defectMark.x !== undefined || defectMark.y !== undefined)) {
                            defectMark.canvasPosition = { x: defectMark.x || 0, y: defectMark.y || 0 };
                        }
                        
                        if (defectMark.canvasPosition) {
                            window.logger.log('Drawing defect mark:', defectMark.id, 'Canvas position:', defectMark.canvasPosition);
                            drawDefectMarkOnPDF(firstPage, defectMark, canvasWidth, canvasHeight, width, height);
                        } else {
                            window.logger.warn('Defect mark missing canvasPosition:', defectMark);
                        }
                    });
                }

                // ç”Ÿæˆä¸¦ä¸‹è¼‰PDF
                const pdfBytes = await newPdfDoc.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `annotated-${floorPlanData.filename || 'floorplan'}.pdf`;
                link.click();
                URL.revokeObjectURL(link.href);

                showNotification('å¸¶æ¨™è¨»çš„PDFæ–‡ä»¶å·²ç”Ÿæˆä¸¦ä¸‹è¼‰', 'success');

            } catch (error) {
                window.logger.error('Error generating PDF:', error);
                showNotification('ç”ŸæˆPDFæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            } finally {
                document.body.removeChild(fileInput);
            }
        });

    } catch (error) {
        window.logger.error('Error in generateAnnotatedPDF:', error);
        showNotification('ç”ŸæˆPDFæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
    }
}

// åœ¨PDFä¸Šç¹ªè£½æ¨™ç±¤
async function drawLabelOnPDF(page, label, canvasWidth, canvasHeight, pdfWidth, pdfHeight) {
    try {
        const { rgb } = PDFLib;
        
        // è¼‰å…¥ç²—é«”å­—é«” - åŒ¹é…åŸå§‹æ¨™ç±¤çš„ç²—é«”æ¨£å¼
        const boldFont = await page.doc.embedFont('Helvetica-Bold');
        
        // ä½¿ç”¨ canvasPosition åº§æ¨™é€²è¡Œè½‰æ›ï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨åŸå§‹åº§æ¨™
        const labelX = label.canvasPosition ? label.canvasPosition.x : label.x;
        const labelY = label.canvasPosition ? label.canvasPosition.y : label.y;
        
        // åæ¨™è½‰æ›ï¼šCanvasåæ¨™è½‰æ›ç‚ºPDFåæ¨™
        // ç¢ºä¿ä½¿ç”¨æ­£ç¢ºçš„æ¯”ä¾‹é€²è¡Œè½‰æ›
        const scaleX = pdfWidth / canvasWidth;
        const scaleY = pdfHeight / canvasHeight;
        const pdfX = labelX * scaleX;
        const pdfY = pdfHeight - (labelY * scaleY); // PDFåæ¨™ç³»Yè»¸å‘ä¸Š
        
        window.logger.log('Label coordinate conversion:', {
            labelId: label.id,
            canvasCoord: { x: labelX, y: labelY },
            canvasSize: { width: canvasWidth, height: canvasHeight },
            pdfSize: { width: pdfWidth, height: pdfHeight },
            scale: { x: scaleX, y: scaleY },
            pdfCoord: { x: pdfX, y: pdfY },
            isValidPosition: pdfX >= 0 && pdfX <= pdfWidth && pdfY >= 0 && pdfY <= pdfHeight
        });

        // ç¹ªè£½æ¨™ç±¤æ–‡å­— - åŒ¹é… floor-plan-content æ¨£å¼
        const labelText = label.inspectionNo || '';
        
        // ä½¿ç”¨èˆ‡æ¨“å±¤å¹³é¢åœ–ç›¸åŒçš„å­—é«”å¤§å°è¨ˆç®—
        const baseFontSize = label.baseFontSize || window.labelSizeScale || 24;
        // PDF ä¸­çš„å­—é«”å¤§å°éœ€è¦æ ¹æ“š PDF å°ºå¯¸é€²è¡Œç¸®æ”¾
        const fontSize = Math.max(8, Math.min(20, baseFontSize * (pdfWidth / canvasWidth) * 0.8));
        
        // æª¢æŸ¥æ¨™ç±¤æ–‡å­—å’Œåº§æ¨™æœ‰æ•ˆæ€§
        if (!labelText || labelText.trim() === '') {
            window.logger.warn('Label has no text, skipping:', label.id);
            return;
        }
        
        if (pdfX < 0 || pdfX > pdfWidth || pdfY < 0 || pdfY > pdfHeight) {
            window.logger.warn('Label position is outside PDF bounds, skipping:', {
                labelId: label.id,
                pdfCoord: { x: pdfX, y: pdfY },
                pdfSize: { width: pdfWidth, height: pdfHeight }
            });
            return;
        }
        
        // æ ¹æ“šæ¨™ç±¤ç‹€æ…‹é¸æ“‡é¡è‰² - åŒ¹é… floor-plan-content æ¨£å¼
        let labelColor;
        
        // èª¿è©¦æ—¥èªŒï¼šè¨˜éŒ„æ¨™ç±¤ç‹€æ…‹
        window.logger.log('Label state for PDF:', {
            labelId: label.id,
            inspectionNo: label.inspectionNo,
            submitted: label.submitted,
            assignedToRecord: label.assignedToRecord
        });
        
        if (label.submitted) {
            // å·²æäº¤çš„æ¨™ç±¤æ¨£å¼ï¼ˆäº®è—è‰²ï¼‰
            labelColor = rgb(0, 0.663, 1); // #00A9FF (äº®è—è‰² - å·²æäº¤)
            window.logger.log('Using submitted label color: #00A9FF (bright blue)');
        } else {
            // æœªåˆ†é…æˆ–å·²åˆ†é…çš„æ¨™ç±¤æ¨£å¼ï¼ˆé»ƒè‰²ï¼‰
            labelColor = rgb(1, 0.745, 0); // #FFBE00 (é»ƒè‰² - æœªåˆ†é…/å·²åˆ†é…)
            window.logger.log('Using label color: #FFBE00 (yellow - unassigned/assigned)');
        }
        
        // è¨ˆç®—æ¨™ç±¤çš„å¯¦éš›å°ºå¯¸ï¼ˆè€ƒæ…® paddingï¼‰
        const textWidth = labelText.length * fontSize * 0.6; // ä¼°ç®—æ–‡å­—å¯¬åº¦
        const textHeight = fontSize;
        const paddingX = fontSize * 0.5; // æ°´å¹³ padding
        const paddingY = fontSize * 0.3; // å‚ç›´ padding
        
        // è¨ˆç®—æ¨™ç±¤çš„å·¦ä¸Šè§’ä½ç½®ï¼ˆè€ƒæ…® paddingï¼‰
        const labelLeft = pdfX - (textWidth / 2) - paddingX;
        const labelTop = pdfY - (textHeight / 2) - paddingY;
        
        page.drawText(labelText, {
            x: labelLeft + paddingX,  // æ–‡å­—ä½ç½® = æ¨™ç±¤å·¦é‚Š + padding
            y: pdfY - fontSize/2 + fontSize * 0.1, // å¾®èª¿ï¼šç¨å¾®å‘ä¸Šèª¿æ•´
            size: fontSize,
            color: labelColor,
            font: boldFont, // ä½¿ç”¨ç²—é«”å­—é«”åŒ¹é…åŸå§‹æ¨£å¼
        });
        
        window.logger.log('Successfully drew label on PDF:', {
            labelId: label.id,
            text: labelText,
            canvasPosition: { x: labelX, y: labelY },
            pdfPosition: { x: pdfX, y: pdfY },
            drawPosition: { x: labelLeft + paddingX, y: labelTop + paddingY + textHeight },
            fontSize: fontSize,
            baseFontSize: baseFontSize,
            color: labelColor,
            dimensions: { textWidth, textHeight, paddingX, paddingY },
            canvasSize: { width: canvasWidth, height: canvasHeight },
            pdfSize: { width: pdfWidth, height: pdfHeight }
        });

    } catch (error) {
        window.logger.error('Error drawing label on PDF:', error);
        window.logger.error('Label data:', label);
        window.logger.error('Canvas dimensions:', { canvasWidth, canvasHeight });
        window.logger.error('PDF dimensions:', { pdfWidth, pdfHeight });
    }
}

// è¨ºæ–·å‡½æ•¸ - æª¢æŸ¥æ¨™ç±¤æ•¸æ“šå’Œåº§æ¨™
function diagnoseLabelData() {
    window.logger.log('=== LABEL DATA DIAGNOSIS ===');
    window.logger.log('Labels count:', window.labels ? window.labels.length : 'undefined');
    window.logger.log('Label size scale:', window.labelSizeScale);
    window.logger.log('Current scale:', window.currentScale);
    window.logger.log('Translate:', { x: window.translateX, y: window.translateY });
    
    if (window.labels && window.labels.length > 0) {
        window.labels.forEach((label, index) => {
            window.logger.log(`Label ${index + 1}:`, {
                id: label.id,
                inspectionNo: label.inspectionNo,
                canvasPosition: label.canvasPosition,
                x: label.x,
                y: label.y,
                baseFontSize: label.baseFontSize,
                submitted: label.submitted
            });
        });
    }
    
    const floorPlanCanvas = document.getElementById('floorPlanCanvas');
    if (floorPlanCanvas) {
        window.logger.log('Canvas element:', {
            width: floorPlanCanvas.width,
            height: floorPlanCanvas.height,
            styleWidth: floorPlanCanvas.style.width,
            styleHeight: floorPlanCanvas.style.height
        });
    }
}

// æ¸¬è©¦åº§æ¨™è½‰æ›å‡½æ•¸
function testCoordinateConversion() {
    window.logger.log('=== COORDINATE CONVERSION TEST ===');
    
    const floorPlanCanvas = document.getElementById('floorPlanCanvas');
    if (!floorPlanCanvas) {
        window.logger.error('Floor plan canvas not found');
        return;
    }
    
    // ä½¿ç”¨èˆ‡ PDF åŒ¯å‡ºç›¸åŒçš„å°ºå¯¸è¨ˆç®—
    const canvasWidth = parseFloat(floorPlanCanvas.style.width) || floorPlanCanvas.width / (window.outputScale || 1);
    const canvasHeight = parseFloat(floorPlanCanvas.style.height) || floorPlanCanvas.height / (window.outputScale || 1);
    
    window.logger.log('Canvas dimensions:', { 
        cssWidth: parseFloat(floorPlanCanvas.style.width),
        cssHeight: parseFloat(floorPlanCanvas.style.height),
        actualWidth: floorPlanCanvas.width,
        actualHeight: floorPlanCanvas.height,
        outputScale: window.outputScale,
        calculatedWidth: canvasWidth,
        calculatedHeight: canvasHeight
    });
    
    if (window.labels && window.labels.length > 0) {
        window.labels.forEach((label, index) => {
            const labelX = label.canvasPosition ? label.canvasPosition.x : label.x;
            const labelY = label.canvasPosition ? label.canvasPosition.y : label.y;
            
            // æ¨¡æ“¬ PDF åº§æ¨™è½‰æ›
            const pdfWidth = 595; // A4 å¯¬åº¦
            const pdfHeight = 842; // A4 é«˜åº¦
            
            const pdfX = (labelX / canvasWidth) * pdfWidth;
            const pdfY = pdfHeight - ((labelY / canvasHeight) * pdfHeight);
            
            window.logger.log(`Label ${index + 1} coordinate test:`, {
                canvasPosition: { x: labelX, y: labelY },
                pdfPosition: { x: pdfX, y: pdfY },
                ratio: { x: labelX / canvasWidth, y: labelY / canvasHeight },
                canvasSize: { width: canvasWidth, height: canvasHeight },
                pdfSize: { width: pdfWidth, height: pdfHeight }
            });
        });
    }
}

// åœ¨PDFä¸Šç¹ªè£½ç¼ºé™·æ¨™è¨˜
function drawDefectMarkOnPDF(page, defectMark, canvasWidth, canvasHeight, pdfWidth, pdfHeight) {
    try {
        const { rgb } = PDFLib;
        
        // ä½¿ç”¨ canvasPosition åº§æ¨™é€²è¡Œè½‰æ›ï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨åŸå§‹åº§æ¨™
        const markX = defectMark.canvasPosition ? defectMark.canvasPosition.x : defectMark.x;
        const markY = defectMark.canvasPosition ? defectMark.canvasPosition.y : defectMark.y;
        
        // åæ¨™è½‰æ›ï¼šCanvasåæ¨™è½‰æ›ç‚ºPDFåæ¨™
        // ç¢ºä¿ä½¿ç”¨æ­£ç¢ºçš„æ¯”ä¾‹é€²è¡Œè½‰æ›
        const scaleX = pdfWidth / canvasWidth;
        const scaleY = pdfHeight / canvasHeight;
        const pdfX = markX * scaleX;
        const pdfY = pdfHeight - (markY * scaleY);
        
        // è¨ˆç®—æ–‡å­—æ¡†ä½ç½® - ä½¿ç”¨ connectionPosition æˆ–é è¨­åç§»
        let textboxX, textboxY;
        if (defectMark.connectionPosition) {
            // ä½¿ç”¨å¯¦éš›çš„é€£æ¥ä½ç½®
            const connX = defectMark.connectionPosition.x;
            const connY = defectMark.connectionPosition.y;
            textboxX = connX * scaleX;
            textboxY = pdfHeight - (connY * scaleY);
        } else {
            // ä½¿ç”¨é è¨­åç§»é‡
            const offsetX = defectMark.textboxOffsetX || 80;
            const offsetY = defectMark.textboxOffsetY || 40;
            textboxX = pdfX + (offsetX * scaleX);
            textboxY = pdfY - (offsetY * scaleY);
        }
        
        window.logger.log('Defect mark coordinate conversion:', {
            markId: defectMark.id,
            defectNo: defectMark.defectNo,
            photoNo: defectMark.photoNo,
            canvasCoord: { x: markX, y: markY },
            canvasSize: { width: canvasWidth, height: canvasHeight },
            pdfSize: { width: pdfWidth, height: pdfHeight },
            scale: { x: scaleX, y: scaleY },
            pdfCoord: { x: pdfX, y: pdfY },
            textboxCoord: { x: textboxX, y: textboxY },
            connectionPosition: defectMark.connectionPosition,
            textboxOffset: { 
                x: defectMark.textboxOffsetX, 
                y: defectMark.textboxOffsetY 
            },
            fullDefectMark: defectMark
        });

        // 1. å…ˆç¹ªè£½é€£æ¥ç·šï¼ˆåœ¨æœ€å¾Œé¢çš„åœ–å±¤ï¼‰
        page.drawLine({
            start: { x: pdfX, y: pdfY },
            end: { x: textboxX, y: textboxY },
            thickness: 1, // åŒ¹é… floor-plan-content ä¸­çš„ 1px
            color: rgb(0.863, 0.208, 0.271), // #dc3545 (ç´…è‰²)
        });

        // 2. ç¹ªè£½åœ“è§’æ–‡å­—æ¡† - ä½¿ç”¨ photoNo è€Œä¸æ˜¯ photoNumbers
        const photoNo = defectMark.photoNo || defectMark.photoNumbers || '';
        const textContent = photoNo ? `Photo no.: ${photoNo}` : `Defect ${defectMark.defectNo || defectMark.id || ''}`;
        const textSize = 10;
        const textWidth = Math.max(textContent.length * 6, 120); // æ›´ç²¾ç¢ºçš„å¯¬åº¦è¨ˆç®—
        const textHeight = 20; // æ¨™æº–é«˜åº¦
        const borderRadius = 4; // åœ“è§’åŠå¾‘

        // ç¹ªè£½åœ“è§’çŸ©å½¢èƒŒæ™¯ - ä½¿ç”¨æ›´ç²¾ç¢ºçš„åœ“è§’å¯¦ç¾
        const rectX = textboxX - textWidth/2;
        const rectY = textboxY - textHeight/2;

        // ä¸»çŸ©å½¢ï¼ˆä¸­é–“éƒ¨åˆ†ï¼‰
        page.drawRectangle({
            x: rectX + borderRadius,
            y: rectY,
            width: textWidth - 2 * borderRadius,
            height: textHeight,
            color: rgb(1, 1, 1), // ç™½è‰²èƒŒæ™¯
        });
        
        // å·¦å´çŸ©å½¢
        page.drawRectangle({
            x: rectX,
            y: rectY + borderRadius,
            width: borderRadius,
            height: textHeight - 2 * borderRadius,
            color: rgb(1, 1, 1),
        });
        
        // å³å´çŸ©å½¢
        page.drawRectangle({
            x: rectX + textWidth - borderRadius,
            y: rectY + borderRadius,
            width: borderRadius,
            height: textHeight - 2 * borderRadius,
            color: rgb(1, 1, 1),
        });

        // ç¹ªè£½å››å€‹åœ“è§’
        const corners = [
            { x: rectX + borderRadius, y: rectY + textHeight - borderRadius }, // å·¦ä¸Š
            { x: rectX + textWidth - borderRadius, y: rectY + textHeight - borderRadius }, // å³ä¸Š
            { x: rectX + borderRadius, y: rectY + borderRadius }, // å·¦ä¸‹
            { x: rectX + textWidth - borderRadius, y: rectY + borderRadius }  // å³ä¸‹
        ];
        
        corners.forEach(corner => {
            page.drawCircle({
                x: corner.x,
                y: corner.y,
                size: borderRadius,
                color: rgb(1, 1, 1),
            });
        });

        // ç¹ªè£½ç´…è‰²é‚Šæ¡†
        page.drawRectangle({
            x: rectX,
            y: rectY,
            width: textWidth,
            height: textHeight,
            color: rgb(1, 1, 1, 0), // é€æ˜å¡«å……
            borderColor: rgb(0.863, 0.208, 0.271), // #dc3545 (ç´…è‰²é‚Šæ¡†)
            borderWidth: 1,
        });

        // ç¹ªè£½å®Œç¾å±…ä¸­çš„æ–‡å­—
        const textX = textboxX - (textContent.length * textSize * 0.25); // ç²¾ç¢ºçš„å±…ä¸­è¨ˆç®—
        const textY = textboxY - textSize/2; // å‚ç›´å±…ä¸­
        
        page.drawText(textContent, {
            x: textX,
            y: textY,
            size: textSize,
            color: rgb(0.863, 0.208, 0.271), // #dc3545 (ç´…è‰²æ–‡å­—)
        });

        // 3. æœ€å¾Œç¹ªè£½ç´…è‰²åœ“é»ï¼ˆåœ¨æœ€å‰é¢çš„åœ–å±¤ï¼‰
        const dotRadius = 12; // 24px diameter / 2 = 12px radius
        page.drawCircle({
            x: pdfX,
            y: pdfY,
            size: dotRadius,
            color: rgb(0.863, 0.208, 0.271), // #dc3545 (ç´…è‰²)
        });

        // åœ¨ç´…é»ä¸­ç¹ªè£½ç¼ºé™·ç·¨è™Ÿ - å®Œç¾å±…ä¸­
        const defectNo = defectMark.defectNo || defectMark.id || '';
        if (defectNo) {
            const defectNoStr = defectNo.toString();
            const defectNoSize = 10;
            
            // æ›´ç²¾ç¢ºçš„å±…ä¸­è¨ˆç®— - è€ƒæ…®å­—ç¬¦å¯¬åº¦å·®ç•°å’Œ PDF.js æ¸²æŸ“ç‰¹æ€§
            // æ•¸å­—å­—ç¬¦é€šå¸¸æ¯”å­—æ¯çª„ï¼Œä½¿ç”¨æ›´ç²¾ç¢ºçš„å¯¬åº¦ä¼°ç®—
            let totalTextWidth = 0;
            for (let i = 0; i < defectNoStr.length; i++) {
                const char = defectNoStr[i];
                // æ•¸å­—å­—ç¬¦é€šå¸¸è¼ƒçª„ï¼Œç´„ç‚ºå­—é«”å¤§å°çš„ 50-55%
                if (/\d/.test(char)) {
                    totalTextWidth += defectNoSize * 0.52; // æ›´ç²¾ç¢ºçš„æ•¸å­—å­—ç¬¦å¯¬åº¦
                } else {
                    // å…¶ä»–å­—ç¬¦ä½¿ç”¨æ¨™æº–å¯¬åº¦
                    totalTextWidth += defectNoSize * 0.58;
                }
            }
            
            // æ°´å¹³å±…ä¸­ï¼šåœ“å¿ƒ - æ–‡å­—å¯¬åº¦çš„ä¸€åŠ
            const textX = pdfX - (totalTextWidth / 2);
            
            // å‚ç›´å±…ä¸­ï¼šè€ƒæ…® PDF.js çš„æ–‡å­—åŸºç·šå’Œè¡Œé«˜
            // PDF.js ä¸­æ–‡å­—åŸºç·šåœ¨åº•éƒ¨ï¼Œéœ€è¦è€ƒæ…®ä¸Šå‡éƒ¨åˆ†ï¼ˆascenderï¼‰
            // å°æ–¼æ•¸å­—ï¼Œä¸Šå‡éƒ¨åˆ†ç´„ç‚ºå­—é«”å¤§å°çš„ 70-80%
            const ascenderHeight = defectNoSize * 0.75;
            const textY = pdfY - (ascenderHeight / 2);
            
            window.logger.log('Defect number centering (improved):', {
                defectNo: defectNoStr,
                dotCenter: { x: pdfX, y: pdfY },
                textPosition: { x: textX, y: textY },
                textWidth: totalTextWidth,
                fontSize: defectNoSize,
                dotRadius: dotRadius
            });
            
            page.drawText(defectNoStr, {
                x: textX,
                y: textY,
                size: defectNoSize,
                color: rgb(1, 1, 1), // ç™½è‰²æ–‡å­—
            });
        }


    } catch (error) {
        window.logger.error('Error drawing defect mark on PDF:', error);
    }
}


// è‡ªå‹•è¼‰å…¥ PDF æª”æ¡ˆå‡½æ•¸ï¼ˆå·²æ£„ç”¨ï¼Œåƒ…ä¿ç•™æ–‡ä»¶å¼•ç”¨ï¼‰
async function autoLoadPDFFromBase64(pdfBase64, pdfPath) {
    return new Promise(async (resolve, reject) => {
        try {
            window.logger.log('PDF file reference found:', pdfPath);
            window.logger.log('PDF files are no longer stored in localStorage. Please re-upload the PDF file to view the floor plan.');
            
            // é¡¯ç¤ºæç¤ºä¿¡æ¯ï¼Œå‘ŠçŸ¥ç”¨æˆ¶éœ€è¦é‡æ–°ä¸Šå‚³PDF
            showNotification(`æª¢æ¸¬åˆ°PDFæ–‡ä»¶å¼•ç”¨ï¼š${pdfPath}ã€‚è«‹é‡æ–°ä¸Šå‚³PDFæ–‡ä»¶ä»¥æŸ¥çœ‹æ¨“å±¤å¹³é¢åœ–ã€‚`, 'info');
            
            
            resolve();
        } catch (error) {
            window.logger.error('Error processing PDF file reference:', error);
            reject(error);
        }
    });
}

async function loadPDFFromArrayBuffer(arrayBuffer, pdfPath) {
    const floorPlanOverlay = document.getElementById('floorPlanOverlay');
    const floorPlanCanvas = document.getElementById('floorPlanCanvas');
    const floorPlanViewer = document.getElementById('floorPlanViewer');
    const floorPlanUploadArea = document.getElementById('floorPlanUploadArea');
    const labelLayer = document.getElementById('labelLayer');
    
    // å‰µå»ºå…©å€‹ ArrayBuffer å‰¯æœ¬ï¼Œé¿å…å›  PDF.js è½‰ç§»å°è‡´çš„åˆ†é›¢å•é¡Œ
    const arrayBufferForPdf = arrayBuffer.slice();
    const arrayBufferForBase64 = arrayBuffer.slice();
    
    // è¼‰å…¥PDF.js
    if (typeof pdfjsLib === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
        document.head.appendChild(script);
        await new Promise(resolve => {
            const checkPdfjs = setInterval(() => {
                if (window.pdfjsLib) {
                    clearInterval(checkPdfjs);
                    // é…ç½® PDF.js worker
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    resolve();
                }
            }, 100);
        });
    }
    
    const pdf = await pdfjsLib.getDocument({
        data: arrayBufferForPdf,
        cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/cmaps/',
        cMapPacked: true
    }).promise;
    
    // ç²å–ç¬¬ä¸€é 
    const page = await pdf.getPage(1);
    
    // è¨­ç½®canvaså°ºå¯¸
    baseScale = 1.0;
    const viewport = page.getViewport({ scale: baseScale });
    // æé«˜è¼¸å‡ºè§£æåº¦ï¼Œæ”¯æŒé«˜è§£æåº¦é¡¯ç¤ºå™¨
    const outputScale = Math.max(2, Math.min(4, (window.devicePixelRatio || 1) * 1.5));
    const cssWidth = Math.floor(viewport.width);
    const cssHeight = Math.floor(viewport.height);
    floorPlanCanvas.style.width = cssWidth + 'px';
    floorPlanCanvas.style.height = cssHeight + 'px';
    floorPlanCanvas.width = Math.floor(viewport.width * outputScale);
    floorPlanCanvas.height = Math.floor(viewport.height * outputScale);
    
    // è¨­ç½®æ¨™ç±¤å±¤å°ºå¯¸
    if (labelLayer) {
        labelLayer.style.width = cssWidth + 'px';
        labelLayer.style.height = cssHeight + 'px';
    }
    
    // æ¸²æŸ“PDFåˆ°canvas
    const context = floorPlanCanvas.getContext('2d');
    
    // å„ªåŒ–é«˜è§£æåº¦æ¸²æŸ“
    context.imageSmoothingEnabled = true;
    context.imageSmoothingQuality = 'high';
    
    const renderContext = {
        canvasContext: context,
        viewport: viewport,
        transform: outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null
    };
    
    await page.render(renderContext).promise;
    
    // é¡¯ç¤ºviewer
    floorPlanUploadArea.style.display = 'none';
    floorPlanViewer.style.display = 'flex';
    
    // åˆå§‹åŒ–å¤§å°è¨­å®š
    window.logger.log('Initializing size settings after PDF load');
    
    // è¨­ç½®ç¸®æ”¾å’Œå¹³ç§»äº‹ä»¶
    if (typeof window.setupZoomAndPanEvents === 'function') {
        window.setupZoomAndPanEvents();
        window.logger.log('Zoom and pan events set up after PDF load');
    }
    
    // å¾localStorageè¼‰å…¥æ¨™ç±¤å¤§å°è¨­å®š
    const savedLabelSize = localStorage.getItem('pne_label_size_scale');
    if (savedLabelSize) {
        window.labelSizeScale = parseInt(savedLabelSize);
        window.logger.log('Loaded label size from localStorage:', window.labelSizeScale + 'px');
    } else {
        window.labelSizeScale = window.labelSizeScale || 24;
        window.logger.log('Using default label size:', window.labelSizeScale + 'px');
    }
    
    // å¾localStorageè¼‰å…¥ç¼ºé™·æ¨™è¨˜å¤§å°è¨­å®š
    const savedDefectSize = localStorage.getItem('pne_defect_mark_size_scale');
    if (savedDefectSize) {
        window.defectMarkSizeScale = parseInt(savedDefectSize);
        window.logger.log('Loaded defect mark size from localStorage:', window.defectMarkSizeScale + 'px');
    } else {
        window.defectMarkSizeScale = window.defectMarkSizeScale || 24;
        window.logger.log('Using default defect mark size:', window.defectMarkSizeScale + 'px');
    }
    
    // è¨­ç½®ç¸®æ”¾å’Œå¹³ç§»äº‹ä»¶ç›£è½å™¨
    window.logger.log('Calling setupZoomAndPanEvents from loadPDFFromArrayBuffer');
    if (typeof window.setupZoomAndPanEvents === 'function') {
        window.setupZoomAndPanEvents();
    } else {
        window.logger.log('setupZoomAndPanEvents function not available yet');
    }
    
    // æ‡‰ç”¨ä¿å­˜çš„è¦–åœ–ç‹€æ…‹
    let savedViewState = null;
    try {
        const pneViewState = localStorage.getItem('pne_floorplan_view_state');
        if (pneViewState) {
            savedViewState = JSON.parse(pneViewState);
            window.logger.log('Found saved view state from PNE file:', savedViewState);
        }
    } catch (error) {
        window.logger.error('Error parsing saved view state:', error);
    }
    
    // æ‡‰ç”¨è¦–åœ–ç‹€æ…‹çš„å‡½æ•¸
    function applyViewState(viewState) {
        if (!viewState) return;
        
        window.logger.log('Applying view state:', viewState);
        
        // æ‡‰ç”¨ç¸®æ”¾å’Œå¹³ç§»
        window.currentScale = viewState.scale || 1.0;
        window.translateX = viewState.translateX || 0;
        window.translateY = viewState.translateY || 0;
        
        // æ›´æ–°æ¨™ç±¤å¤§å°
        if (viewState.labelSizeScale) {
            window.labelSizeScale = viewState.labelSizeScale;
            if (typeof updateLabelSizeUI === 'function') {
                updateLabelSizeUI();
            }
        }
        
        // æ›´æ–°ç¼ºé™·æ¨™è¨˜å¤§å°
        if (viewState.defectMarkSizeScale) {
            window.defectMarkSizeScale = viewState.defectMarkSizeScale;
            if (typeof updateDefectMarkSizeUI === 'function') {
                updateDefectMarkSizeUI();
            }
        }
        
        // æ‡‰ç”¨è®Šæ›
        if (typeof window.applyTransform === 'function') {
            window.applyTransform();
            window.logger.log('View state applied successfully');
        } else {
            window.logger.warn('applyTransform function not available');
        }
    }
    
    if (savedViewState) {
        // æ‡‰ç”¨ä¿å­˜çš„è¦–åœ–ç‹€æ…‹
        applyViewState(savedViewState);
        
        // æ¸…é™¤ä¿å­˜çš„è¦–åœ–ç‹€æ…‹
        localStorage.removeItem('pne_floorplan_view_state');
        } else {
            // å˜—è©¦å¾localStorageè¼‰å…¥è¦–åœ–ç‹€æ…‹
            let viewStateRestored = false;
            
            // é¦–å…ˆå˜—è©¦å¾PNEæ–‡ä»¶è¼‰å…¥çš„è¦–åœ–ç‹€æ…‹
            if (typeof loadViewStateFromLocalStorage === 'function') {
                loadViewStateFromLocalStorage();
                window.logger.log('Loaded view state from localStorage');
                
                // æ‡‰ç”¨è¼‰å…¥çš„è¦–åœ–ç‹€æ…‹
                if (typeof window.applyTransform === 'function') {
                    window.applyTransform();
                    viewStateRestored = true;
                }
            }
            
            // å¦‚æœæ²’æœ‰æ¢å¾©æˆåŠŸï¼Œå˜—è©¦å¾å‚™ä»½ä¸­æ¢å¾©
            if (!viewStateRestored) {
                try {
                    const backupViewState = localStorage.getItem('pne_current_view_state');
                    if (backupViewState) {
                        const parsedBackup = JSON.parse(backupViewState);
                        window.logger.log('Found backup view state:', parsedBackup);
                        
                        // æª¢æŸ¥æ™‚é–“æˆ³ï¼Œå¦‚æœå¤ªèˆŠï¼ˆè¶…é24å°æ™‚ï¼‰å‰‡ä¸ä½¿ç”¨
                        const now = Date.now();
                        const stateAge = now - (parsedBackup.timestamp || 0);
                        const maxAge = 24 * 60 * 60 * 1000; // 24å°æ™‚
                        
                        if (stateAge < maxAge) {
                            applyViewState(parsedBackup);
                            viewStateRestored = true;
                            window.logger.log('Restored view state from backup');
                        } else {
                            window.logger.log('Backup view state too old, ignoring');
                        }
                    }
                } catch (error) {
                    window.logger.error('Error restoring backup view state:', error);
                }
            }
            
            // å¦‚æœä»ç„¶æ²’æœ‰æ¢å¾©æˆåŠŸï¼Œä½¿ç”¨é»˜èªè¦–åœ–
            if (!viewStateRestored) {
                // å±…ä¸­é¡¯ç¤º - ä½¿ç”¨å¯ç”¨çš„å‡½æ•¸
                if (typeof zoomTo100AndCenter === 'function') {
                    zoomTo100AndCenter();
                } else if (typeof window.applyTransform === 'function') {
                    // è¨­ç½®é»˜èªè¦–åœ–
                    window.currentScale = 1.0;
                    window.translateX = 0;
                    window.translateY = 0;
                    window.applyTransform();
                }
                window.logger.log('Using default view state');
            }
        }
    
    // ç”Ÿæˆç¸®åœ–
    try {
        window.logger.log('Generating thumbnail...');
        window.logger.log('Floor plan canvas:', {
            width: floorPlanCanvas.width,
            height: floorPlanCanvas.height,
            element: floorPlanCanvas
        });
        
        const thumbMaxW = 640;
        const scaleThumb = Math.min(1, thumbMaxW / floorPlanCanvas.width);
        const tw = Math.max(1, Math.floor(floorPlanCanvas.width * scaleThumb));
        const th = Math.max(1, Math.floor(floorPlanCanvas.height * scaleThumb));
        
        window.logger.log('Thumbnail dimensions:', { tw, th, scaleThumb });
        
        const thumbCanvas = document.createElement('canvas');
        thumbCanvas.width = tw;
        thumbCanvas.height = th;
        const tctx = thumbCanvas.getContext('2d');
        tctx.drawImage(floorPlanCanvas, 0, 0, tw, th);
        const dataUrl = thumbCanvas.toDataURL('image/png');
        
        window.logger.log('Thumbnail data URL generated, length:', dataUrl.length);
        
        const floorplanThumb = document.getElementById('floorplanThumb');
        const floorplanThumbImg = document.getElementById('floorplanThumbImg');
        
        window.logger.log('Thumbnail elements:', {
            floorplanThumb: !!floorplanThumb,
            floorplanThumbImg: !!floorplanThumbImg
        });
        
        if (floorplanThumb && floorplanThumbImg) {
            floorplanThumbImg.src = dataUrl;
            floorplanThumb.style.display = 'flex';
            window.logger.log('Thumbnail displayed successfully');
        } else {
            window.logger.error('Thumbnail elements not found');
        }
    } catch (e) { 
        window.logger.error('Thumbnail generation failed:', e);
        window.logger.log('Floor plan canvas dimensions:', {
            width: floorPlanCanvas.width,
            height: floorPlanCanvas.height
        });
    }
    
    // å°‡ArrayBufferè½‰æ›ç‚ºbase64ä¸¦å­˜å„²ï¼ˆä½¿ç”¨å°ˆç”¨å‰¯æœ¬ï¼Œé¿å…åˆ†é›¢ï¼‰
    const uint8Array = new Uint8Array(arrayBufferForBase64);
    const binaryString = Array.from(uint8Array, byte => String.fromCharCode(byte)).join('');
    const pdfBase64 = btoa(binaryString);
    localStorage.setItem('pne_floorplan_base64', pdfBase64);
    
    // ä¿å­˜PDFæ–‡ä»¶å¼•ç”¨å’Œå…ƒæ•¸æ“šåˆ°localStorage
    const floorPlanData = {
        filename: pdfPath,
        fileSize: arrayBufferForBase64.byteLength,
        lastModified: Date.now(),
        uploadDate: new Date().toISOString(),
        pageCount: pdf.numPages,
        dimensions: {
            width: viewport.width,
            height: viewport.height
        },
        // ä¿å­˜ Canvas CSS å°ºå¯¸ç”¨æ–¼åº§æ¨™è½‰æ›ï¼ˆå› ç‚ºæ¨™ç±¤ä½ç½®æ˜¯åŸºæ–¼ CSS å°ºå¯¸è¨ˆç®—çš„ï¼‰
        canvasWidth: parseFloat(floorPlanCanvas.style.width) || cssWidth,
        canvasHeight: parseFloat(floorPlanCanvas.style.height) || cssHeight,
        labelsCount: (typeof window.labels !== 'undefined' && window.labels) ? window.labels.length : 0,
        defectMarksCount: (typeof window.defectMarks !== 'undefined' && window.defectMarks) ? window.defectMarks.length : 0,
        // ä¿å­˜æ–‡ä»¶å¼•ç”¨
        fileReference: {
            name: pdfPath,
            size: arrayBufferForBase64.byteLength,
            lastModified: Date.now(),
            type: 'application/pdf'
        },
        // æ¨™è¨˜æœ‰ base64 æ•¸æ“šå¯ç”¨æ–¼åŒ¯å‡º
        hasBase64Data: true
    };
    
    localStorage.setItem('pne_floorplan_data', JSON.stringify(floorPlanData));
    localStorage.setItem('pne_floorplan_filename', pdfPath);
    
    // é‡ç½® skipDefectMarksLoad æ¨™èªŒï¼Œå…è¨±ç¼ºé™·æ¨™è¨˜è¼‰å…¥
    window.skipDefectMarksLoad = false;
    window.logger.log('PDF upload: Reset skipDefectMarksLoad flag to allow defect marks loading');
    
    // è¼‰å…¥æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜æ•¸æ“š
    if (typeof loadLabelsFromStorage === 'function') {
        await loadLabelsFromStorage();
        window.logger.log('PDF upload: Labels loaded from storage');
    }
    
    if (typeof loadDefectMarksFromStorage === 'function') {
        await loadDefectMarksFromStorage();
        window.logger.log('PDF upload: Defect marks loaded from storage');
    }
    
    // é‡æ–°æ¸²æŸ“æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜
    if (typeof redrawLabels === 'function') {
        redrawLabels();
        window.logger.log('PDF upload: Labels redrawn');
    }
    
    if (typeof redrawDefectMarks === 'function') {
        redrawDefectMarks();
        window.logger.log('PDF upload: Defect marks redrawn');
    }
    
    // æª¢æŸ¥æ˜¯å¦æœ‰å¾…æ¢å¾©çš„è¦–åœ–ç‹€æ…‹ï¼ˆé é¢é‡æ–°è¼‰å…¥æ™‚ï¼‰
    if (window.pendingViewStateRestore) {
        window.logger.log('Applying pending view state restore after PDF load');
        
        // ä½¿ç”¨æ›´å¯é çš„æ¢å¾©æ©Ÿåˆ¶
        const attemptViewStateRestore = (attempts = 0) => {
            if (attempts >= 10) {
                window.logger.warn('Failed to restore view state after 10 attempts');
                window.pendingViewStateRestore = false;
                return;
            }
            
            if (typeof window.applyTransform === 'function') {
                window.logger.log(`Attempting view state restore (attempt ${attempts + 1})`);
                
                // ç¢ºä¿ PDF canvas å­˜åœ¨ä¸”å·²æ¸²æŸ“
                const floorPlanCanvas = document.getElementById('floorPlanCanvas');
                if (floorPlanCanvas && floorPlanCanvas.width > 0 && floorPlanCanvas.height > 0) {
                    window.applyTransform();
                    window.logger.log('Pending view state applied successfully');
                    
                    // æ›´æ–°æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜å¤§å° UI
                    if (window.labelSizeScale && typeof updateLabelSizeUI === 'function') {
                        updateLabelSizeUI();
                    }
                    if (window.defectMarkSizeScale && typeof updateDefectMarkSizeUI === 'function') {
                        updateDefectMarkSizeUI();
                    }
                    
                    // é‡æ–°è¨­ç½®é›™æ“Šäº‹ä»¶ç›£è½å™¨ï¼Œç¢ºä¿ç¼ºé™·æ¨™è¨˜å‰µå»ºåŠŸèƒ½æ­£å¸¸
                    if (typeof setupDoubleClickHandler === 'function') {
                        setupDoubleClickHandler();
                        window.logger.log('Double-click handler re-initialized after PDF load');
                    }
                    
                    // æ¸…é™¤æ¨™è¨˜
                    window.pendingViewStateRestore = false;
                } else {
                    // Canvas é‚„æ²’æº–å‚™å¥½ï¼Œé‡è©¦
                    setTimeout(() => attemptViewStateRestore(attempts + 1), 100);
                }
            } else {
                // applyTransform é‚„æ²’å®šç¾©ï¼Œé‡è©¦
                setTimeout(() => attemptViewStateRestore(attempts + 1), 100);
            }
        };
        
        // é–‹å§‹æ¢å¾©å˜—è©¦
        attemptViewStateRestore();
    }
    
    window.logger.log('PDF loaded successfully from base64 data');
}


async function autoLoadPDFFromData(pdfData, pdfPath) {
    return new Promise((resolve, reject) => {
        try {
            window.logger.log('PDF file reference found:', pdfPath);
            window.logger.log('PDF files are no longer stored in localStorage. Please re-upload the PDF file to view the floor plan.');
            
            // é¡¯ç¤ºæç¤ºä¿¡æ¯ï¼Œå‘ŠçŸ¥ç”¨æˆ¶éœ€è¦é‡æ–°ä¸Šå‚³PDF
            showNotification(`æª¢æ¸¬åˆ°PDFæ–‡ä»¶å¼•ç”¨ï¼š${pdfPath}ã€‚è«‹é‡æ–°ä¸Šå‚³PDFæ–‡ä»¶ä»¥æŸ¥çœ‹æ¨“å±¤å¹³é¢åœ–ã€‚`, 'info');
            
                    
                    resolve();
                } catch (error) {
            window.logger.error('Error processing PDF file reference:', error);
            reject(error);
        }
    });
}

// æ¢å¾©æ¨“å±¤å¹³é¢åœ–æ¨™ç±¤
function restoreFloorPlanLabels(labelsData) {
    try {
        window.logger.log('Restoring floor plan labels:', labelsData.length);
        
        const labelLayer = document.getElementById('labelLayer');
        if (!labelLayer) {
            window.logger.error('Label layer not found');
            return;
        }
        
        // æ¸…é™¤ç¾æœ‰æ¨™ç±¤
        labelLayer.innerHTML = '';
        
        // æ¢å¾©æ¯å€‹æ¨™ç±¤
        labelsData.forEach(labelData => {
            const labelElement = document.createElement('div');
            labelElement.className = 'floor-plan-label';
            
            // ä½¿ç”¨ä¿å­˜çš„åº§æ¨™ä½ç½®
            if (labelData.x !== undefined && labelData.y !== undefined) {
                labelElement.style.left = labelData.x + 'px';
                labelElement.style.top = labelData.y + 'px';
            }
            
            // ä½¿ç”¨ä¿å­˜çš„å­—é«”å¤§å°
            if (labelData.fontSize !== undefined) {
                labelElement.style.fontSize = labelData.fontSize + 'px';
            } else {
                const labelSizeValue = window.labelSizeScale || 24;
                labelElement.style.fontSize = labelSizeValue + 'px';
            }
            
            labelElement.dataset.labelId = labelData.id;
            
            // è¨­ç½®æ¨™ç±¤å…§å®¹
            labelElement.innerHTML = `
                <div class="label-content">
                    <span class="label-text">${labelData.text || ''}</span>
                    <button class="label-delete-btn" onclick="deleteLabel('${labelData.id}')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
            
            labelLayer.appendChild(labelElement);
        });
        
        window.logger.log('Floor plan labels restored successfully');
    } catch (error) {
        window.logger.error('Error restoring floor plan labels:', error);
    }
}

// æ¢å¾©æ¨“å±¤å¹³é¢åœ–ç¼ºé™·æ¨™è¨˜
function restoreFloorPlanDefectMarks(defectMarksData) {
    try {
        window.logger.log('Restoring floor plan defect marks:', defectMarksData.length);
        
        const labelLayer = document.getElementById('labelLayer');
        if (!labelLayer) {
            window.logger.error('Label layer not found');
            return;
        }
        
        // æ¢å¾©æ¯å€‹ç¼ºé™·æ¨™è¨˜
        defectMarksData.forEach(markData => {
            const markElement = document.createElement('div');
            markElement.className = 'defect-mark-dot';
            
            // ä½¿ç”¨ä¿å­˜çš„åº§æ¨™ä½ç½®
            if (markData.x !== undefined && markData.y !== undefined) {
                markElement.style.left = markData.x + 'px';
                markElement.style.top = markData.y + 'px';
            }
            
            markElement.dataset.markId = markData.id;
            
            // å‰µå»ºç¼ºé™·æ¨™è¨˜å…ƒç´ 
            markElement.innerHTML = `
                <div class="defect-mark-textbox">
                    <span class="defect-mark-number">${markData.number || markData.defectNo || ''}</span>
                    <button class="defect-mark-delete-btn" onclick="deleteDefectMark('${markData.id}')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
            
            labelLayer.appendChild(markElement);
        });
        
        window.logger.log('Floor plan defect marks restored successfully');
    } catch (error) {
        window.logger.error('Error restoring floor plan defect marks:', error);
    }
}

// æ›´æ–°ç…§ç‰‡ç‹€æ…‹åŸºæ–¼æ¨™ç±¤æ•¸æ“š
function updatePhotoStatusFromLabels() {
    window.logger.log('Updating photo status from labels data');
    
    // æ”¶é›†æ‰€æœ‰å·²æäº¤çš„ç…§ç‰‡æ–‡ä»¶å
    const submittedPhotos = new Set();
    const photoLocationMap = new Map(); // ç…§ç‰‡æ–‡ä»¶å -> location ID
    const categoryPhotoMap = new Map(); // ç…§ç‰‡æ–‡ä»¶å -> category assignments
    
    // é¦–å…ˆè™•ç† submittedData ä¸­çš„ç…§ç‰‡ï¼ˆå„ªå…ˆç´šæœ€é«˜ï¼‰
    if (submittedData && submittedData.length > 0) {
        submittedData.forEach(record => {
            if (record.photoFilenames && record.photoFilenames.length > 0) {
                record.photoFilenames.forEach(filename => {
                    submittedPhotos.add(filename);
                    photoLocationMap.set(filename, record.locationId || '');
                });
            }
        });
    }
    
    if (window.labels && Array.isArray(window.labels)) {
        window.labels.forEach(label => {
            // è™•ç†å·²æäº¤çš„ç…§ç‰‡ - æ·»åŠ é©—è­‰ç¢ºä¿ç…§ç‰‡ç¢ºå¯¦å±¬æ–¼è©²æ¨™ç±¤
            if (label.submitted && label.photoFilenames && Array.isArray(label.photoFilenames)) {
                label.photoFilenames.forEach(filename => {
                    // é©—è­‰ç…§ç‰‡æ˜¯å¦çœŸçš„å±¬æ–¼é€™å€‹æ¨™ç±¤
                    const isValidAssignment = validatePhotoLabelAssignment(filename, label);
                    if (isValidAssignment) {
                        submittedPhotos.add(filename);
                        photoLocationMap.set(filename, label.inspectionNo || label.locationId || '');
                    } else {
                        window.logger.warn(`Photo ${filename} is not properly assigned to label ${label.inspectionNo}, skipping`);
                    }
                });
            }
            
            // è™•ç†åˆ†é¡æ¬„ä½ä¸­çš„ç…§ç‰‡ç·¨è™Ÿ - æ·»åŠ æ›´åš´æ ¼çš„é©—è­‰
            categories.forEach(category => {
                const categoryKey = category.id;
                if (label[categoryKey] && label[categoryKey] !== 'N/A') {
                    // è§£æç…§ç‰‡ç·¨è™Ÿï¼Œæ”¯æŒç¯„åœæ ¼å¼ï¼ˆå¦‚ 1234-1236ï¼‰
                    const photoNumbers = [];
                    const parts = label[categoryKey].split(/[,\-]/).map(num => num.trim()).filter(num => num);
                    
                    parts.forEach(part => {
                        // æª¢æŸ¥æ˜¯å¦ç‚ºç¯„åœæ ¼å¼ï¼ˆå¦‚ 1234-1236ï¼‰
                        if (part.includes('-')) {
                            const rangeParts = part.split('-');
                            if (rangeParts.length === 2) {
                                const start = parseInt(rangeParts[0].trim());
                                const end = parseInt(rangeParts[1].trim());
                                if (!isNaN(start) && !isNaN(end) && start <= end) {
                                    // ç”Ÿæˆç¯„åœå…§çš„æ‰€æœ‰ç…§ç‰‡ç·¨è™Ÿ
                                    for (let i = start; i <= end; i++) {
                                        photoNumbers.push(i.toString());
                                    }
                                }
                            }
                        } else {
                            // å–®å€‹ç…§ç‰‡ç·¨è™Ÿ
                            photoNumbers.push(part);
                        }
                    });
                    
                    // æ ¹æ“šç…§ç‰‡ç·¨è™Ÿæ‰¾åˆ°å°æ‡‰çš„ç…§ç‰‡æ–‡ä»¶å - æ·»åŠ é©—è­‰
                    if (allPhotos && allPhotos.length > 0) {
                        photoNumbers.forEach(photoNumber => {
                            allPhotos.forEach(file => {
                                const fileNumber = file.name.match(/\d+/);
                                if (fileNumber && fileNumber[0] === photoNumber) {
                                    // é©—è­‰ç…§ç‰‡æ˜¯å¦çœŸçš„å±¬æ–¼é€™å€‹æ¨™ç±¤çš„é€™å€‹åˆ†é¡
                                    const isValidAssignment = validatePhotoCategoryAssignment(file.name, label, categoryKey);
                                    if (isValidAssignment) {
                                        if (!categoryPhotoMap.has(file.name)) {
                                            categoryPhotoMap.set(file.name, new Set());
                                        }
                                        categoryPhotoMap.get(file.name).add(categoryKey);
                                        
                                        // æ›´æ–° assignedPhotos
                                        if (!assignedPhotos[categoryKey]) {
                                            assignedPhotos[categoryKey] = new Set();
                                        }
                                        assignedPhotos[categoryKey].add(file.name);
                                    } else {
                                        window.logger.warn(`Photo ${file.name} is not properly assigned to label ${label.inspectionNo} category ${categoryKey}, skipping`);
                                    }
                                }
                            });
                        });
                    }
                }
            });
        });
    }
    
    // åŒæ­¥æ›´æ–° submittedFilenames é›†åˆ
    submittedFilenames.clear();
    submittedPhotos.forEach(filename => submittedFilenames.add(filename));
    
    // æ¸…ç† assignedPhotos é›†åˆä¸­ä¸å†éœ€è¦çš„ç…§ç‰‡
    categories.forEach(category => {
        if (assignedPhotos[category.id]) {
            const currentAssignedPhotos = new Set(assignedPhotos[category.id]);
            currentAssignedPhotos.forEach(filename => {
                // æª¢æŸ¥ç…§ç‰‡æ˜¯å¦ä»åœ¨è©²åˆ†é¡ä¸­
                const categoryAssignments = categoryPhotoMap.get(filename);
                if (!categoryAssignments || !categoryAssignments.has(category.id)) {
                    assignedPhotos[category.id].delete(filename);
                }
            });
        }
    });
    
    // æ¸…é™¤æ‰€æœ‰ç…§ç‰‡ç‹€æ…‹ï¼Œç„¶å¾Œé‡æ–°è¨­ç½®ï¼ˆèˆ‡ PNE.html ä¿æŒä¸€è‡´ï¼‰
    document.querySelectorAll('.photo-item').forEach(item => {
        item.classList.remove('submitted', 'assigned');
        const img = item.querySelector('img');
        if (img) {
            img.style.filter = '';
            img.style.opacity = '';
        }
        const statusDiv = item.querySelector('.photo-status');
        if (statusDiv) {
            statusDiv.textContent = '';
            statusDiv.style.display = 'none';
        }
    });
    
    // è™•ç†å·²æäº¤çš„ç…§ç‰‡ï¼ˆå„ªå…ˆç´šæœ€é«˜ï¼‰
    submittedPhotos.forEach(filename => {
        const photoItem = document.querySelector(`.photo-item[data-filename="${filename}"]`);
        if (photoItem) {
            // Mark as submitted
            photoItem.classList.add('submitted');
            
            // Update visual appearance
            const img = photoItem.querySelector('img');
            if (img) {
                img.style.filter = 'grayscale(100%)';
                img.style.opacity = '0.3';
            }
            
            // Update status display
            const statusDiv = photoItem.querySelector('.photo-status');
            if (statusDiv) {
                statusDiv.textContent = `${photoLocationMap.get(filename) || ''}`;
                statusDiv.style.display = 'flex';
                statusDiv.style.zIndex = '10'; // Ensure status is above placeholder
            }
            
            // Update photo number display
            const photoNumberDiv = photoItem.querySelector('.photo-number');
            if (photoNumberDiv) {
                const numberMatch = filename.match(/\d+/);
                const number = numberMatch ? numberMatch[0] : '';
                photoNumberDiv.textContent = number;
            }
        }
    });
    
    // è™•ç†å·²åˆ†é…ä½†æœªæäº¤çš„ç…§ç‰‡
    Object.keys(assignedPhotos).forEach(categoryId => {
        if (assignedPhotos[categoryId] && assignedPhotos[categoryId].size > 0) {
            assignedPhotos[categoryId].forEach(filename => {
                const photoItem = document.querySelector(`.photo-item[data-filename="${filename}"]`);
                if (photoItem && !photoItem.classList.contains('submitted')) {
                    // Check if this photo is still in any submittedData row
                    const isStillSubmitted = submittedData.some(row => 
                        row.photoFilenames && row.photoFilenames.includes(filename)
                    );
                    
                    if (!isStillSubmitted) {
                        // Mark as assigned only if not submitted
                        photoItem.classList.add('assigned');
                        
                        // Update visual appearance
                        const img = photoItem.querySelector('img');
                        if (img) {
                            img.style.filter = 'grayscale(100%)';
                            img.style.opacity = '0.3';
                        }
                        
                        // Update status display to show category
                        const statusDiv = photoItem.querySelector('.photo-status');
                        if (statusDiv) {
                            const categoryName = categories.find(cat => cat.id === categoryId)?.name || categoryId.toUpperCase();
                            statusDiv.textContent = `Assigned to ${categoryName}`;
                            statusDiv.style.display = 'flex';
                            statusDiv.style.zIndex = '10'; // Ensure status is above placeholder
                        }
                        
                        // Update photo number display
                        const photoNumberDiv = photoItem.querySelector('.photo-number');
                        if (photoNumberDiv) {
                            const numberMatch = filename.match(/\d+/);
                            const number = numberMatch ? numberMatch[0] : '';
                            photoNumberDiv.textContent = number;
                        }
                    } else {
                        // If photo is still submitted, ensure it shows as submitted
                        photoItem.classList.remove('assigned');
                        photoItem.classList.add('submitted');
                        const img = photoItem.querySelector('img');
                        if (img) {
                            img.style.filter = 'grayscale(100%)';
                            img.style.opacity = '0.3';
                        }
                        const statusDiv = photoItem.querySelector('.photo-status');
                        if (statusDiv) {
                            // Preserve inspection number if already set, otherwise show 'Submitted'
                            if (!statusDiv.textContent || statusDiv.textContent.trim() === '') {
                                statusDiv.textContent = 'Submitted';
                            }
                            statusDiv.style.display = 'flex';
                            statusDiv.style.zIndex = '10';
                        }
                    }
                }
            });
        }
    });
    
    window.logger.log('Photo status updated from labels data');
    window.logger.log('Updated submittedFilenames:', Array.from(submittedFilenames));
    window.logger.log('Updated category assignments:', categoryPhotoMap);
}

// è™•ç†æ¨™ç±¤è©³ç´°è¡¨æ ¼ä¸­ç…§ç‰‡ç·¨è™Ÿçš„å³æ™‚æ›´æ–°
function handleLabelsDetailTablePhotoUpdate() {
    window.logger.log('Handling labels detail table photo number updates');
    
    // ç›£è½æ¨™ç±¤è©³ç´°è¡¨æ ¼ä¸­çš„è¼¸å…¥è®ŠåŒ–
    const labelsDetailTable = document.getElementById('labelsDetailTable');
    if (labelsDetailTable) {
        // ç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨
        labelsDetailTable.removeEventListener('input', handleLabelsRealtimeUpdate);
        labelsDetailTable.removeEventListener('change', handleLabelsRealtimeUpdate);
        
        // æ·»åŠ æ–°çš„äº‹ä»¶ç›£è½å™¨
        labelsDetailTable.addEventListener('input', handleLabelsRealtimeUpdate);
        labelsDetailTable.addEventListener('change', handleLabelsRealtimeUpdate);
    }
}

// è™•ç†æ¨™ç±¤è©³ç´°è¡¨æ ¼çš„å³æ™‚æ›´æ–°
function handleLabelsRealtimeUpdate(event) {
    const target = event.target;
    if (!target.matches('input[data-field]')) return;
    
    const field = target.dataset.field;
    const index = parseInt(target.dataset.index);
    
    // åˆ†é¡æ¬„ä½ï¼ˆa-jï¼‰ç¾åœ¨æ˜¯åªè®€çš„ï¼Œä¸è™•ç†é€™äº›æ¬„ä½çš„æ›´æ–°
    const categoryFields = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
    if (categoryFields.includes(field)) return;
    
    window.logger.log(`Updating category ${field} for label index ${index}`);
    
    // æ›´æ–°å°æ‡‰çš„æ¨™ç±¤æ•¸æ“š
    if (window.labels && window.labels[index]) {
        const label = window.labels[index];
        const newValue = target.value.trim();
        
        // æ›´æ–°æ¨™ç±¤æ•¸æ“š
        label[field] = newValue || 'N/A';
        
        // ä¿å­˜æ¨™ç±¤æ•¸æ“š
        if (typeof window.saveLabelsToStorage === 'function') {
            window.saveLabelsToStorage();
        }
        
        // å³æ™‚æ›´æ–°ç…§ç‰‡é è¦½ç‹€æ…‹
        setTimeout(() => {
            if (typeof updatePhotoStatusFromLabels === 'function') {
                updatePhotoStatusFromLabels();
            }
        }, 100);
        
        window.logger.log(`Updated label ${label.inspectionNo} category ${field} to: ${newValue}`);
    }
}

// æ›´æ–°ç…§ç‰‡ç‹€æ…‹åŸºæ–¼æª¢æŸ¥è¨˜éŒ„ï¼ˆåƒè€ƒ PNE611.html çš„æ­£ç¢ºå¯¦ç¾ï¼‰
function updatePhotoStatusFromInspectionRecords() {
    window.logger.log('Updating photo status from inspection records');
    
    // ğŸ”§ åªæ¸…é™¤ submitted ç‹€æ…‹,ä¿ç•™ assigned ç‹€æ…‹
    // assigned ç‹€æ…‹ç”± restorePhotoAssignmentStatus() ç®¡ç†
    document.querySelectorAll('.photo-item').forEach(item => {
        // åªç§»é™¤ submitted,ä¸ç§»é™¤ assigned
        item.classList.remove('submitted');
        
        // åªæœ‰ç•¶ç…§ç‰‡æ²’æœ‰è¢« assigned æ™‚,æ‰æ¸…é™¤è¦–è¦ºæ¨£å¼å’Œç‹€æ…‹é¡¯ç¤º
        // å¦‚æœç…§ç‰‡å·²ç¶“ assigned,ä¿ç•™ç°éšæ•ˆæœå’Œç‹€æ…‹é¡¯ç¤º
        if (!item.classList.contains('assigned')) {
            const img = item.querySelector('img');
            if (img) {
                img.style.filter = '';
                img.style.opacity = '';
            }
            
            // åªæœ‰é assigned ç…§ç‰‡æ‰æ¸…é™¤ç‹€æ…‹é¡¯ç¤º
            const statusDiv = item.querySelector('.photo-status');
            if (statusDiv) {
                statusDiv.textContent = '';
                statusDiv.style.display = 'none';
            }
        }
        // å¦‚æœç…§ç‰‡æ˜¯ assigned,ä¿ç•™å…¶ç‹€æ…‹é¡¯ç¤º(ç”± restorePhotoAssignmentStatus è¨­ç½®)
    });
    
    // è™•ç†å·²æäº¤çš„ç…§ç‰‡ï¼ˆå„ªå…ˆç´šæœ€é«˜ï¼‰
    submittedData.forEach(record => {
        if (record.photoFilenames && record.photoFilenames.length > 0) {
            record.photoFilenames.forEach(filename => {
                const photoItem = document.querySelector(`.photo-item[data-filename="${filename}"]`);
                if (photoItem) {
                    // Mark as submitted
                    photoItem.classList.add('submitted');
                    submittedFilenames.add(filename);
                    
                    // Update visual appearance
                    const img = photoItem.querySelector('img');
                    if (img) {
                        img.style.filter = 'grayscale(100%)';
                        img.style.opacity = '0.3';
                    }
                    
                    // Update status display
                    const statusDiv = photoItem.querySelector('.photo-status');
                    if (statusDiv) {
                        statusDiv.textContent = `${record.locationId}`;
                        statusDiv.style.display = 'flex';
                        statusDiv.style.zIndex = '10'; // Ensure status is above placeholder
                    }
                    
                    // Update photo number display
                    const photoNumberDiv = photoItem.querySelector('.photo-number');
                    if (photoNumberDiv) {
                        const numberMatch = filename.match(/\d+/);
                        const number = numberMatch ? numberMatch[0] : '';
                        photoNumberDiv.textContent = number;
                    }
                }
            });
        }
    });
    
    // è™•ç†å·²åˆ†é…ä½†æœªæäº¤çš„ç…§ç‰‡
    Object.keys(assignedPhotos).forEach(categoryId => {
        if (assignedPhotos[categoryId] && assignedPhotos[categoryId].size > 0) {
            assignedPhotos[categoryId].forEach(filename => {
                const photoItem = document.querySelector(`.photo-item[data-filename="${filename}"]`);
                if (photoItem) {
                    // Check if photo is already submitted
                    const isStillSubmitted = submittedData.some(record => 
                        record.photoFilenames && record.photoFilenames.includes(filename)
                    );
                    
                    if (!isStillSubmitted) {
                        // Mark as assigned only if not submitted
                        photoItem.classList.add('assigned');
                        
                        // Update visual appearance
                        const img = photoItem.querySelector('img');
                        if (img) {
                            img.style.filter = 'grayscale(100%)';
                            img.style.opacity = '0.3';
                        }
                        
                        // Update status display to show category
                        const statusDiv = photoItem.querySelector('.photo-status');
                        if (statusDiv) {
                            const categoryName = categories.find(cat => cat.id === categoryId)?.name || categoryId.toUpperCase();
                            statusDiv.textContent = `Assigned to ${categoryName}`;
                            statusDiv.style.display = 'flex';
                            statusDiv.style.zIndex = '10'; // Ensure status is above placeholder
                        }
                        
                        // Update photo number display
                        const photoNumberDiv = photoItem.querySelector('.photo-number');
                        if (photoNumberDiv) {
                            const numberMatch = filename.match(/\d+/);
                            const number = numberMatch ? numberMatch[0] : '';
                            photoNumberDiv.textContent = number;
                        }
                    } else {
                        // Photo is submitted, ensure it shows as submitted
                        photoItem.classList.remove('assigned');
                        photoItem.classList.add('submitted');
                        const img = photoItem.querySelector('img');
                        if (img) {
                            img.style.filter = 'grayscale(100%)';
                            img.style.opacity = '0.3';
                        }
                        const statusDiv = photoItem.querySelector('.photo-status');
                        if (statusDiv) {
                            // Preserve inspection number if already set, otherwise show 'Submitted'
                            if (!statusDiv.textContent || statusDiv.textContent.trim() === '') {
                                statusDiv.textContent = 'Submitted';
                            }
                            statusDiv.style.display = 'flex';
                            statusDiv.style.zIndex = '10';
                        }
                    }
                }
            });
        }
    });
    
    window.logger.log('Photo status update completed');
    
    // Log final status for debugging
    const submittedCount = document.querySelectorAll('.photo-item.submitted').length;
    const assignedCount = document.querySelectorAll('.photo-item.assigned').length;
    const normalCount = document.querySelectorAll('.photo-item:not(.submitted):not(.assigned)').length;
    
    window.logger.log(`Final photo status - Submitted: ${submittedCount}, Assigned: ${assignedCount}, Normal: ${normalCount}`);
}

// æ›´æ–°ç…§ç‰‡æäº¤ç‹€æ…‹é¡¯ç¤º
function updatePhotoSubmissionStatus() {
    window.logger.log('Updating photo submission status display');
    
    // ä½¿ç”¨æ–°çš„å‡½æ•¸ä¾†æ›´æ–°ç…§ç‰‡ç‹€æ…‹
    updatePhotoStatusFromInspectionRecords();
    
    // æ›´æ–°åˆ†é¡é¡¯ç¤º
    categories.forEach(category => {
        updateCategoryDisplay(category.id);
    });
    
    window.logger.log('Photo submission status updated');
}

// è‡ªå‹•è¼‰å…¥ç…§ç‰‡å‡½æ•¸
async function autoLoadPhotosFromPaths(photoFilePaths, photoMetadata) {
    try {
        window.logger.log('Attempting to auto-load photos from paths:', photoFilePaths.length);
        
        // æª¢æŸ¥æ˜¯å¦åœ¨ file:// å”è­°ä¸‹é‹è¡Œ
        if (window.location.protocol === 'file:') {
            window.logger.log('Running in file:// protocol, checking for cached dataURLs');
            
            // åœ¨ file:// å”è­°ä¸‹ï¼Œåªèƒ½ä½¿ç”¨å¿«å–çš„ dataURL
            if (photoMetadata && photoMetadata.some(meta => meta.dataURL && meta.dataURL.trim() !== '')) {
                window.logger.log('Using cached dataURLs for photo restoration in file:// protocol');
                
                // éæ¿¾å‡ºæœ‰æ•ˆçš„ dataURL
                const validPhotos = photoMetadata.filter(meta => 
                    meta.dataURL && 
                    typeof meta.dataURL === 'string' && 
                    meta.dataURL.trim() !== '' &&
                    meta.dataURL.startsWith('data:image/')
                );
                
                window.logger.log(`Found ${validPhotos.length} valid photos with dataURL out of ${photoMetadata.length} total`);
                
                if (validPhotos.length > 0) {
                    allPhotos = validPhotos.map(metadata => ({
                        name: metadata.name,
                        size: metadata.size || 0,
                        type: metadata.type || 'image/jpeg',
                        lastModified: metadata.lastModified || Date.now(),
                        webkitRelativePath: metadata.webkitRelativePath || '',
                        dataURL: metadata.dataURL
                    }));
                    
                    // æ¸²æŸ“ç…§ç‰‡
                    const lazyObserver = initLazyLoading();
                    await renderPhotos(allPhotos, lazyObserver);
                    updateFolderDisplay();
                    updateAddPhotosButtonVisibility();
                    
                    // ğŸ”§ ä¿å­˜ç…§ç‰‡æ•¸æ“šåˆ° IndexedDB
                    console.log('ğŸ’¾ Saving photos to IndexedDB after PNE file load (file:// protocol)...');
                    setTimeout(async () => {
                        await saveDataToStorage();
                        console.log('âœ… Photos saved to IndexedDB after PNE file load');
                    }, 500);
                    
                    showNotification(`å¾ PNE æª”æ¡ˆå¿«å–ä¸­æ¢å¾©äº† ${allPhotos.length} å¼µç…§ç‰‡ (file:// å”è­°)`, 'success');
                    return;
                } else {
                    window.logger.warn('No valid dataURLs found in file:// protocol');
                    showNotification('åœ¨ file:// å”è­°ä¸‹ç„¡æ³•è¼‰å…¥ç…§ç‰‡ï¼Œè«‹æ‰‹å‹•é¸æ“‡ç…§ç‰‡è³‡æ–™å¤¾', 'warning');
                    return;
                }
            } else {
                window.logger.log('No cached dataURLs available in file:// protocol');
                showNotification('åœ¨ file:// å”è­°ä¸‹ç„¡æ³•è‡ªå‹•è¼‰å…¥ç…§ç‰‡ï¼Œè«‹æ‰‹å‹•é¸æ“‡ç…§ç‰‡è³‡æ–™å¤¾', 'info');
                return;
            }
        }
        
        // å¦‚æœæœ‰ dataURLï¼Œç›´æ¥ä½¿ç”¨ï¼ˆé©ç”¨æ–¼ç…§ç‰‡å·²ç¶“åœ¨è¨˜æ†¶é«”ä¸­çš„æƒ…æ³ï¼‰
        if (photoMetadata && photoMetadata.some(meta => meta.dataURL && meta.dataURL.trim() !== '')) {
            window.logger.log('Using cached dataURLs for photo restoration');
            window.logger.log('Photo metadata details:', {
                totalCount: photoMetadata.length,
                withDataURL: photoMetadata.filter(meta => meta.dataURL && meta.dataURL.trim() !== '').length,
                sampleDataURL: photoMetadata.find(meta => meta.dataURL && meta.dataURL.trim() !== '')?.dataURL?.substring(0, 50) + '...'
            });
            allPhotos = photoMetadata.map(metadata => {
                // æª¢æŸ¥ dataURL çš„é¡å‹å’Œå…§å®¹
                let dataURL = metadata.dataURL || '';
                if (typeof dataURL === 'object') {
                    window.logger.warn(`Invalid dataURL type for ${metadata.name}:`, typeof dataURL, dataURL);
                    dataURL = ''; // é‡ç½®ç‚ºç©ºå­—ç¬¦ä¸²
                }
                
                return {
                    name: metadata.name,
                    size: metadata.size || 0,
                    type: metadata.type || 'image/jpeg',
                    lastModified: metadata.lastModified || Date.now(),
                    webkitRelativePath: metadata.webkitRelativePath || '',
                    dataURL: dataURL
                };
            });
            
            // æ¸²æŸ“ç…§ç‰‡
            const lazyObserver = initLazyLoading();
            await renderPhotos(allPhotos, lazyObserver);
            updateFolderDisplay();
            updateAddPhotosButtonVisibility();
            
            // ğŸ”§ ä¿å­˜ç…§ç‰‡æ•¸æ“šåˆ° IndexedDB
            console.log('ğŸ’¾ Saving photos to IndexedDB after PNE file load (cached dataURLs)...');
            setTimeout(async () => {
                await saveDataToStorage();
                console.log('âœ… Photos saved to IndexedDB after PNE file load');
            }, 500);
            
            showNotification(`å¾ PNE æª”æ¡ˆå¿«å–ä¸­æ¢å¾©äº† ${allPhotos.length} å¼µç…§ç‰‡`, 'success');
            return;
        } else {
            window.logger.log('No valid dataURLs found in photo metadata, attempting alternative loading methods');
            window.logger.log('Photo metadata analysis:', {
                totalCount: photoMetadata ? photoMetadata.length : 0,
                hasMetadata: !!photoMetadata,
                sampleMetadata: photoMetadata ? photoMetadata[0] : null,
                dataURLStatus: photoMetadata ? photoMetadata.map(meta => ({
                    name: meta.name,
                    hasDataURL: !!meta.dataURL,
                    dataURLLength: meta.dataURL ? meta.dataURL.length : 0,
                    dataURLPreview: meta.dataURL ? meta.dataURL.substring(0, 20) + '...' : 'none'
                })) : []
            });
        }
        
        // å˜—è©¦ä½¿ç”¨ File System Access API è¼‰å…¥ç…§ç‰‡ï¼ˆå¦‚æœæ”¯æ´ï¼‰
        // æ³¨æ„ï¼šé€™æœƒå½ˆå‡ºç›®éŒ„é¸æ“‡å°è©±æ¡†ï¼Œä¸æ˜¯çœŸæ­£çš„è‡ªå‹•è¼‰å…¥
        if ('showDirectoryPicker' in window) {
            try {
                window.logger.log('Attempting to use File System Access API for photo loading');
                const directoryHandle = await window.showDirectoryPicker();
                const files = [];
                
                for await (const [name, handle] of directoryHandle.entries()) {
                    if (handle.kind === 'file' && /\.(jpe?g|png|gif|bmp|webp)$/i.test(name)) {
                        const file = await handle.getFile();
                        files.push(file);
                    }
                }
                
                if (files.length > 0) {
                    allPhotos = files;
                    const lazyObserver = initLazyLoading();
                    await renderPhotos(allPhotos, lazyObserver);
                    updateFolderDisplay();
                    updateAddPhotosButtonVisibility();
                    
                    // ğŸ”§ ä¿å­˜ç…§ç‰‡æ•¸æ“šåˆ° IndexedDB
                    console.log('ğŸ’¾ Saving photos to IndexedDB after PNE file load (FSA API)...');
                    setTimeout(async () => {
                        await saveDataToStorage();
                        console.log('âœ… Photos saved to IndexedDB after PNE file load');
                    }, 500);
                    
                    showNotification(`å¾é¸å®šç›®éŒ„è¼‰å…¥äº† ${files.length} å¼µç…§ç‰‡`, 'success');
                    return;
                }
            } catch (error) {
                window.logger.log('File System Access API not available or user cancelled:', error);
            }
        }
        
        // å¦‚æœç„¡æ³•è‡ªå‹•è¼‰å…¥ï¼Œé¡¯ç¤ºæç¤ºè¨Šæ¯
        window.logger.log('All auto-loading methods failed, prompting user to manually select folder');
        showNotification('ç„¡æ³•è‡ªå‹•è¼‰å…¥ç…§ç‰‡ï¼Œè«‹æ‰‹å‹•é¸æ“‡ç…§ç‰‡è³‡æ–™å¤¾ä»¥æ¢å¾©ç…§ç‰‡', 'info');
        
    } catch (error) {
        window.logger.error('Error auto-loading photos:', error);
        showNotification('è‡ªå‹•è¼‰å…¥ç…§ç‰‡å¤±æ•—ï¼Œè«‹æ‰‹å‹•é¸æ“‡ç…§ç‰‡è³‡æ–™å¤¾', 'warning');
    }
}

// Open PNE file
const openPNEBtn = document.querySelector('.pne-dropdown-item[data-action="open"]');
openPNEBtn.addEventListener('click', function() {
    // é—œé–‰ä¸‹æ‹‰é¸å–®
    const pneDropdown = document.querySelector('.pne-dropdown');
    if (pneDropdown) {
        pneDropdown.style.display = 'none';
    }
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.pne,application/json';
    input.style.display = 'none';
    input.addEventListener('change', async (e) => {
        if (e.target.files.length > 0) {
            const file = e.target.files[0];
            
            // è¨­ç½® PNE è¼‰å…¥æ¨™èªŒ
            window.isPNELoading = true;
            
            // ä¿å­˜PDF base64æ•¸æ“šï¼Œé¿å…è¢«æ¸…é™¤
            const pdfBase64Data = localStorage.getItem('pne_floorplan_base64');
            const pdfData = localStorage.getItem('pne_floorplan_data');
            const pdfFilename = localStorage.getItem('pne_floorplan_filename');
            
            // æ¸…é™¤æ‰€æœ‰ localStorage æ•¸æ“šï¼Œé¿å…èˆ‡ .pne æ–‡ä»¶æ•¸æ“šè¡çª
            window.logger.log('Clearing all localStorage data before loading PNE file...');
            localStorage.clear();
            window.logger.log('localStorage cleared successfully');
            
            // æ¢å¾©PDFæ•¸æ“š
            if (pdfBase64Data) {
                localStorage.setItem('pne_floorplan_base64', pdfBase64Data);
                window.logger.log('PDF base64 data preserved');
            }
            if (pdfData) {
                localStorage.setItem('pne_floorplan_data', pdfData);
                window.logger.log('PDF metadata preserved');
            }
            if (pdfFilename) {
                localStorage.setItem('pne_floorplan_filename', pdfFilename);
                window.logger.log('PDF filename preserved');
            }
            
            // é‡ç½®æ‰€æœ‰å…¨å±€è®Šé‡
            submittedData = [];
            submittedFilenames = new Set();
            photoFolders = [];
            submittedDefectEntries = [];
            rowIdCounter = 0;
            allPhotos = [];
            window.labels = [];
            window.defectMarks = [];
            
            window.logger.log('Global variables reset');
            
            const text = await file.text();
            try {
                const data = JSON.parse(text);
                
                // é‚„åŸInspection Records
                if (data.inspectionRecords) {
                    submittedData = data.inspectionRecords;
                    console.log('ğŸ” PNE load: Restored submittedData:', submittedData.length, 'records');
                    console.log('ğŸ” submittedData content:', submittedData);
                }
                if (Array.isArray(data.submittedFilenames)) {
                    submittedFilenames = new Set(data.submittedFilenames);
                    console.log('ğŸ” PNE load: Restored submittedFilenames:', submittedFilenames.size, 'files');
                    console.log('ğŸ” submittedFilenames content:', Array.from(submittedFilenames));
                } else {
                    console.log('ğŸ” PNE load: No submittedFilenames found in data');
                }
                if (Array.isArray(data.photoFolders)) {
                    photoFolders = data.photoFolders;
                }
                if (Array.isArray(data.submittedDefectEntries)) {
                    submittedDefectEntries = data.submittedDefectEntries;
                }
                if (typeof data.rowIdCounter === 'number') {
                    rowIdCounter = data.rowIdCounter;
                }
                
                // é‚„åŸä»»å‹™æ•¸æ“š
                if (data.currentTask) {
                    currentTask = data.currentTask;
                    window.hasTaskData = true;
                    console.log('ğŸ“¥ PNE load: Restored current task:', currentTask.name);
                    // æ›´æ–°ä»»å‹™é¡¯ç¤º
                    updateTaskDisplay();
                }
                
                // æ–°å¢:é‚„åŸç…§ç‰‡åˆ†é…è³‡æ–™
                if (data.photoAssignments) {
                    window.logger.log('Restoring photo assignments from PNE file');
                    
                    // é‚„åŸåˆ†é¡ç·¨è™Ÿ
                    if (data.photoAssignments.categoryNumbers) {
                        Object.keys(data.photoAssignments.categoryNumbers).forEach(categoryId => {
                            if (!categoryNumbers[categoryId]) {
                                console.log(`âš ï¸ PNE load: Category ${categoryId} not found in categoryNumbers, creating it`);
                                categoryNumbers[categoryId] = [];
                            }
                            categoryNumbers[categoryId] = data.photoAssignments.categoryNumbers[categoryId] || [];
                        });
                        console.log('ğŸ“‹ PNE load: Restored categoryNumbers:', Object.keys(categoryNumbers).map(k => ({
                            category: k,
                            count: categoryNumbers[k].length
                        })));
                    }
                    
                    // é‚„åŸå·²åˆ†é…çš„ç…§ç‰‡
                    if (data.photoAssignments.assignedPhotos) {
                        let totalAssigned = 0;
                        Object.keys(data.photoAssignments.assignedPhotos).forEach(categoryId => {
                            if (!assignedPhotos[categoryId]) {
                                console.log(`âš ï¸ PNE load: Category ${categoryId} not found in assignedPhotos, creating it`);
                                assignedPhotos[categoryId] = new Set();
                            }
                            assignedPhotos[categoryId] = new Set(data.photoAssignments.assignedPhotos[categoryId] || []);
                            totalAssigned += assignedPhotos[categoryId].size;
                        });
                        console.log('ğŸ“‹ PNE load: Restored assignedPhotos:', {
                            totalCategories: Object.keys(assignedPhotos).length,
                            totalAssignedPhotos: totalAssigned,
                            categoriesWithPhotos: Object.keys(assignedPhotos).filter(k => assignedPhotos[k] && assignedPhotos[k].size > 0)
                        });
                    }
                    
                    // é‚„åŸç¼ºé™·æ¢ç›®
                    if (data.photoAssignments.defectEntries) {
                        window.defectEntries = data.photoAssignments.defectEntries || [];
                        window.logger.log('Restored defect entries from PNE file:', window.defectEntries.length);
                    }
                }
                
                // æ–°å¢ï¼šé‚„åŸç…§ç‰‡å…ƒè³‡æ–™å’Œæª”æ¡ˆè·¯å¾‘
                if (data.photoMetadata) {
                    window.logger.log('Restoring photo metadata from PNE file:', data.photoMetadata.length);
                    // ä¸ç›´æ¥è¨­ç½® allPhotosï¼Œè®“ autoLoadPhotosFromPaths è™•ç†
                    // allPhotos = data.photoMetadata.map(metadata => ({
                    //     name: metadata.name,
                    //     size: metadata.size || 0,
                    //     type: metadata.type || 'image/jpeg',
                    //     lastModified: metadata.lastModified || Date.now(),
                    //     webkitRelativePath: metadata.webkitRelativePath || '',
                    //     dataURL: metadata.dataURL || ''
                    // }));
                }
                
                // æ–°å¢ï¼šé‚„åŸæª”æ¡ˆè·¯å¾‘è³‡è¨Š
                if (data.filePaths) {
                    window.logger.log('Restoring file paths from PNE file');
                    
                    // é‚„åŸ PDF è·¯å¾‘
                    if (data.filePaths.pdfPath) {
                        localStorage.setItem('pne_floorplan_filename', data.filePaths.pdfPath);
                    }
                    if (data.filePaths.pdfData) {
                        localStorage.setItem('pne_floorplan_data', data.filePaths.pdfData);
                    }
                    
                    // é‚„åŸç…§ç‰‡è³‡æ–™å¤¾è·¯å¾‘
                    if (data.filePaths.photoFolderPath) {
                        folderNameDisplay.textContent = data.filePaths.photoFolderPath;
                        window.logger.log('Restored folder name:', data.filePaths.photoFolderPath);
                    }
                    
                    // å¦‚æœæœ‰ç…§ç‰‡æª”æ¡ˆè·¯å¾‘ï¼Œå˜—è©¦è‡ªå‹•è¼‰å…¥ç…§ç‰‡
                    if (data.filePaths.photoFilePaths && data.filePaths.photoFilePaths.length > 0) {
                        window.logger.log('Found photo file paths in PNE file, attempting to auto-load photos');
                        await autoLoadPhotosFromPaths(data.filePaths.photoFilePaths, data.photoMetadata);
                    }
                    
                    // æ›´æ–°UIç‹€æ…‹
                    updateFolderDisplay();
                    updateAddPhotosButtonVisibility();
                    window.logger.log('Updated folder display and add photos button visibility');
                }
                
                // æ–°å¢ï¼šè™•ç†æ–‡ä»¶å¼•ç”¨ç³»çµ± - è·³éæ–‡ä»¶é¡¯ç¤ºå®¹å™¨ï¼Œç›´æ¥åŸ·è¡Œè‡ªå‹•æµç¨‹
                if (data.files && data.files.length > 0) {
                    window.logger.log('Found file references in PNE file:', data.files.length);
                    
                    // ä¸é¡¯ç¤ºæ–‡ä»¶é¡¯ç¤ºå®¹å™¨ï¼Œç›´æ¥åŸ·è¡Œè‡ªå‹•æµç¨‹
                    window.logger.log('Skipping file display container, executing auto workflow...');
                    
                    // 1. é¦–å…ˆç¢ºä¿ç…§ç‰‡é è¦½å€åŸŸå·²æº–å‚™å¥½
                    setTimeout(() => {
                        // ç¢ºä¿ç…§ç‰‡ç¶²æ ¼å¯è¦‹
                        const photoGrid = document.getElementById('photoGrid');
                        if (photoGrid) {
                            photoGrid.style.display = 'grid';
                            window.logger.log('Photo preview area opened');
                        }
                        
                        // æ›´æ–°UIç‹€æ…‹
                        updateFolderDisplay();
                        updateAddPhotosButtonVisibility();
                        window.logger.log('Updated UI state after opening photo preview area');
                        
                        // 2. è‡ªå‹•æ‰“é–‹ç¹ªåœ–æ¨¡å¼
                        setTimeout(() => {
                            const floorPlanOverlay = document.getElementById('floorPlanOverlay');
                            if (floorPlanOverlay) {
                                // Show floor plan overlay
                                floorPlanOverlay.style.zIndex = '1000';
                                floorPlanOverlay.style.display = 'flex';
                                window.logger.log('Drawing mode opened automatically');
                                
                                // èª¿ç”¨å¿…è¦çš„åˆå§‹åŒ–å‡½æ•¸
                                if (typeof checkLabelsDataAndShowContent === 'function') {
                                    // åœ¨èª¿ç”¨å‰æª¢æŸ¥PDFæ•¸æ“šç‹€æ…‹
                                    window.logger.log('Before checkLabelsDataAndShowContent - PDF data check:');
                                    window.logger.log('pne_floorplan_base64 exists:', !!localStorage.getItem('pne_floorplan_base64'));
                                    window.logger.log('pne_floorplan_data exists:', !!localStorage.getItem('pne_floorplan_data'));
                                    window.logger.log('pne_floorplan_filename exists:', !!localStorage.getItem('pne_floorplan_filename'));
                                    
                                    checkLabelsDataAndShowContent();
                                    
                                    // åœ¨èª¿ç”¨å¾Œå†æ¬¡æª¢æŸ¥PDFæ•¸æ“šç‹€æ…‹
                                    window.logger.log('After checkLabelsDataAndShowContent - PDF data check:');
                                    window.logger.log('pne_floorplan_base64 exists:', !!localStorage.getItem('pne_floorplan_base64'));
                                    window.logger.log('pne_floorplan_data exists:', !!localStorage.getItem('pne_floorplan_data'));
                                    window.logger.log('pne_floorplan_filename exists:', !!localStorage.getItem('pne_floorplan_filename'));
                                }
                                
                                // åˆå§‹åŒ–æ»‘å¡ŠåŠŸèƒ½
                                setTimeout(() => {
                                    if (typeof window.initLabelSizeAdjustment === 'function') {
                                        window.initLabelSizeAdjustment();
                                    }
                                    if (typeof window.initDefectMarkSizeAdjustment === 'function') {
                                        window.initDefectMarkSizeAdjustment();
                                    }
                                }, 100);
                                
                                // 3. è‡ªå‹•è¼‰å…¥ä¹‹å‰çš„PDFæ–‡ä»¶
                                setTimeout(() => {
                                    // æª¢æŸ¥PNEæ–‡ä»¶ä¸­çš„PDFæ•¸æ“š
                                    let pdfFileReference = null;
                                    let pdfFileName = '';
                                    
                                    // å¾filePathsä¸­ç²å–PDFæ–‡ä»¶å¼•ç”¨
                                    if (data.filePaths && data.filePaths.pdfFileReference) {
                                        pdfFileReference = data.filePaths.pdfFileReference;
                                        pdfFileName = pdfFileReference.name || '';
                                        window.logger.log('Found PDF file reference in PNE file:', pdfFileName);
                                    }
                                    
                                    // ä¹Ÿæª¢æŸ¥æ˜¯å¦æœ‰PDFè·¯å¾‘
                                    if (!pdfFileName && data.filePaths && data.filePaths.pdfPath) {
                                        pdfFileName = data.filePaths.pdfPath;
                                        window.logger.log('Found PDF path in PNE file:', pdfFileName);
                                    }
                                    
                                    if (pdfFileName) {
                                        window.logger.log('Auto-loading previous PDF file:', pdfFileName);
                                        
                                        // æª¢æŸ¥æ˜¯å¦æœ‰PDFçš„base64æ•¸æ“š
                                        const pdfBase64 = localStorage.getItem('pne_floorplan_base64');
                                        window.logger.log('PDF base64 data check:', {
                                            exists: !!pdfBase64,
                                            length: pdfBase64 ? pdfBase64.length : 0,
                                            firstChars: pdfBase64 ? pdfBase64.substring(0, 50) : 'N/A'
                                        });
                                        
                                        if (pdfBase64) {
                                            try {
                                                // å°‡base64æ•¸æ“šè½‰æ›ç‚ºArrayBuffer
                                                const binaryString = atob(pdfBase64);
                                                const arrayBuffer = new ArrayBuffer(binaryString.length);
                                                const uint8Array = new Uint8Array(arrayBuffer);
                                                for (let i = 0; i < binaryString.length; i++) {
                                                    uint8Array[i] = binaryString.charCodeAt(i);
                                                }
                                                
                                                // ä½¿ç”¨ç¾æœ‰çš„PDFè¼‰å…¥å‡½æ•¸
                                                if (typeof loadPDFFromArrayBuffer === 'function') {
                                                    loadPDFFromArrayBuffer(arrayBuffer, pdfFileName);
                                                    window.logger.log('PDF loaded successfully from base64 data');
                                                } else {
                                                    window.logger.log('loadPDFFromArrayBuffer function not available');
                                                    if (typeof showNotification === 'function') {
                                                        showNotification(`æª¢æ¸¬åˆ°PDFæ–‡ä»¶ï¼š${pdfFileName}ã€‚è«‹æ‰‹å‹•ä¸Šå‚³PDFæ–‡ä»¶ä»¥æŸ¥çœ‹æ¨“å±¤å¹³é¢åœ–ã€‚`, 'info');
                                                    }
                                                }
                                            } catch (error) {
                                                window.logger.error('Error loading PDF from base64:', error);
                                                if (typeof showNotification === 'function') {
                                                    showNotification('è¼‰å…¥PDFæ–‡ä»¶æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹æ‰‹å‹•ä¸Šå‚³PDFæ–‡ä»¶ã€‚', 'error');
                                                }
                                            }
                                        } else {
                                            window.logger.log('No PDF base64 data found in localStorage');
                                            if (typeof showNotification === 'function') {
                                                showNotification(`æª¢æ¸¬åˆ°PDFæ–‡ä»¶å¼•ç”¨ï¼š${pdfFileName}ã€‚è«‹é‡æ–°ä¸Šå‚³PDFæ–‡ä»¶ä»¥æŸ¥çœ‹æ¨“å±¤å¹³é¢åœ–ã€‚`, 'info');
                                            }
                                        }
                                    } else {
                                        window.logger.log('No previous PDF file found in PNE file');
                                    }
                                }, 500); // ç­‰å¾…ç¹ªåœ–æ¨¡å¼å®Œå…¨æ‰“é–‹
                            } else {
                                window.logger.log('floorPlanOverlay element not found');
                            }
                        }, 300); // ç­‰å¾…ç…§ç‰‡é è¦½å€åŸŸæº–å‚™å¥½
                    }, 200); // ç­‰å¾…PNEæ–‡ä»¶è¼‰å…¥å®Œæˆ
                }
                
                // æ³¨æ„ï¼šä¸å†é‚„åŸåˆ†é¡å…§å®¹è³‡æ–™ï¼Œé¿å…é‡æ–°è¼‰å…¥å¾Œä»é¡¯ç¤ºå·²åˆ†é…ç‹€æ…‹
                
                // é‚„åŸè³‡æ–™å¤¾è·¯å¾‘
                if (data.uploadedFolderPath) {
                    folderNameDisplay.textContent = data.uploadedFolderPath;
                }
                
                // æ³¨æ„ï¼šä¸å†é‚„åŸ localStorageï¼Œå› ç‚ºæˆ‘å€‘å·²ç¶“åœ¨é–‹å§‹æ™‚æ¸…é™¤äº†æ‰€æœ‰æ•¸æ“š
                // ç¾åœ¨åªå¾ .pne æ–‡ä»¶æ•¸æ“šä¸­æ¢å¾©å¿…è¦çš„æ•¸æ“š
                
                // é‚„åŸæ¨“å±¤å¹³é¢æ¨™ç±¤
                if (data.floorPlanLabels) {
                    window.labels = Array.isArray(data.floorPlanLabels) ? data.floorPlanLabels : [];
                }
                
                // é‚„åŸæ¨“å±¤å¹³é¢ç¼ºé™·æ¨™è¨˜
                if (data.floorPlanDefectMarks) {
                    window.defectMarks = Array.isArray(data.floorPlanDefectMarks) ? data.floorPlanDefectMarks : [];
                }
                
                // è™•ç†åµŒå…¥çš„ PDF æª”æ¡ˆ
                if (data.embeddedPDF && data.embeddedPDF.hasEmbeddedPDF) {
                    window.logger.log('Found embedded PDF in PNE file:', data.embeddedPDF.filename);
                    
                    try {
                        // å°‡åµŒå…¥çš„ PDF æ•¸æ“šä¿å­˜åˆ° localStorage
                        localStorage.setItem('pne_floorplan_base64', data.embeddedPDF.base64Data);
                        localStorage.setItem('pne_floorplan_data', JSON.stringify(data.embeddedPDF.metadata));
                        localStorage.setItem('pne_floorplan_filename', data.embeddedPDF.filename);
                        
                        window.logger.log('Embedded PDF data saved to localStorage');
                        
                        // è‡ªå‹•è¼‰å…¥ PDF ä¸¦é€²å…¥ç¹ªåœ–æ¨¡å¼
                        await loadEmbeddedPDFAndEnterDrawingMode(data.embeddedPDF);
                        
                    } catch (error) {
                        window.logger.error('Error processing embedded PDF:', error);
                        showNotification('è¼‰å…¥åµŒå…¥çš„ PDF æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤', 'warning');
                    }
                }
                
                // é‚„åŸæ¨“å±¤å¹³é¢åœ–è¦–åœ–ç‹€æ…‹
                if (data.floorPlanViewState) {
                    window.logger.log('Restoring floor plan view state:', data.floorPlanViewState);
                    
                    // ä½¿ç”¨å…¨å±€è®Šé‡
                    if (typeof data.floorPlanViewState.scale === 'number') {
                        window.currentScale = data.floorPlanViewState.scale;
                    }
                    if (typeof data.floorPlanViewState.translateX === 'number') {
                        window.translateX = data.floorPlanViewState.translateX;
                    }
                    if (typeof data.floorPlanViewState.translateY === 'number') {
                        window.translateY = data.floorPlanViewState.translateY;
                    }
                    if (typeof data.floorPlanViewState.baseScale === 'number') {
                        if (typeof baseScale === 'undefined') {
                            window.baseScale = data.floorPlanViewState.baseScale;
                        } else {
                            baseScale = data.floorPlanViewState.baseScale;
                        }
                    }
                    if (typeof data.floorPlanViewState.labelSizeScale === 'number') {
                        window.labelSizeScale = data.floorPlanViewState.labelSizeScale;
                    }
                    if (typeof data.floorPlanViewState.defectMarkSizeScale === 'number') {
                        window.defectMarkSizeScale = data.floorPlanViewState.defectMarkSizeScale;
                    }
                    
                    // æ›´æ–° labelViewState
                    const currentScaleValue = window.currentScale || 1.0;
                    const translateXValue = window.translateX || 0;
                    const translateYValue = window.translateY || 0;
                    
                    if (typeof labelViewState !== 'undefined') {
                        labelViewState = {
                            scale: currentScaleValue,
                            tx: translateXValue,
                            ty: translateYValue
                        };
                    } else {
                        window.labelViewState = {
                            scale: currentScaleValue,
                            tx: translateXValue,
                            ty: translateYValue
                        };
                    }
                }
                
                // é‚„åŸ Header æ¬„ä½
                if (data.headerFields) {
                    try {
                        const h = data.headerFields;
                        const lid = document.getElementById('locationId');
                        const idate = document.getElementById('inspectionDate');
                        const floorInput = document.getElementById('floorHeader');
                        const areaInput = document.getElementById('areaNameHeader');
                        const roomInput = document.getElementById('roomNo');
                        const sortToggleEl = document.getElementById('sortToggle');
                        if (lid && typeof h.inspectionNo === 'string') lid.value = h.inspectionNo;
                        if (idate && typeof h.inspectionDate === 'string') idate.value = h.inspectionDate;
                        if (floorInput && typeof h.floor === 'string') floorInput.value = h.floor;
                        if (areaInput && typeof h.areaName === 'string') areaInput.value = h.areaName;
                        if (roomInput && typeof h.roomNo === 'string') roomInput.value = h.roomNo;
                        if (sortToggleEl && typeof h.sortEnabled === 'boolean') sortToggleEl.checked = h.sortEnabled;
                    } catch(_) {}
                }

                // ğŸ”§ ä½¿ç”¨å®Œæ•´çš„ saveDataToStorage ä¿å­˜æ‰€æœ‰æ¢å¾©çš„æ•¸æ“š
                // åŒ…æ‹¬ç…§ç‰‡åˆ†é… (assignedPhotos, categoryNumbers) å’Œæ‰€æœ‰å…¶ä»–æ•¸æ“š
                window.logger.log('ğŸ’¾ Saving all restored PNE data to IndexedDB (including photo assignments)...');
                
                // å»¶é²ä¿å­˜,ç¢ºä¿ autoLoadPhotosFromPaths å·²ç¶“å®Œæˆä¸¦ä¸” allPhotos å·²æ›´æ–°
                setTimeout(async () => {
                    await saveDataToStorage();
                    window.logger.log('âœ… All PNE data saved to IndexedDB successfully');
                    console.log('ğŸ“Š Saved data includes:', {
                        submittedData: submittedData.length,
                        allPhotos: allPhotos.length,
                        assignedPhotosCategories: Object.keys(assignedPhotos).length,
                        totalAssignedPhotos: Object.values(assignedPhotos).reduce((sum, set) => sum + set.size, 0)
                    });
                }, 1000); // å»¶é² 1 ç§’ç¢ºä¿ç…§ç‰‡å·²åŠ è¼‰
                
                // ä¿å­˜æ¨“å±¤å¹³é¢æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜åˆ° localStorage
                if (window.labels && window.labels.length > 0) {
                    if (typeof window.saveLabelsToStorage === 'function') {
                        window.saveLabelsToStorage();
                        window.logger.log('Labels saved to localStorage:', window.labels.length);
                    }
                }
                if (window.defectMarks && window.defectMarks.length > 0) {
                    saveDefectMarksToStorage();
                    window.logger.log('Defect marks saved to localStorage:', window.defectMarks.length);
                }
                
                window.logger.log('All data successfully saved to localStorage');
                
                // æ¸…é™¤ PNE è¼‰å…¥æ¨™èªŒ
                window.isPNELoading = false;
                
                // æ¢å¾©æ¨“å±¤å¹³é¢åœ–è¦–åœ–ç‹€æ…‹å’Œè¨»è§£ï¼Œä¸¦è‡ªå‹•è¼‰å…¥PDF
                if (data.floorPlanViewState || (window.labels && window.labels.length > 0) || (window.defectMarks && window.defectMarks.length > 0)) {
                    window.logger.log('Restoring floor plan view state and annotations from PNE data');
                    
                    // ä¿å­˜è¦–åœ–ç‹€æ…‹åˆ° localStorage
                    if (data.floorPlanViewState) {
                        try {
                            localStorage.setItem('pne_floorplan_view_state', JSON.stringify(data.floorPlanViewState));
                            window.logger.log('Floor plan view state saved to localStorage');
                        } catch (error) {
                            window.logger.error('Failed to save view state to localStorage:', error);
                        }
                    }
                    
                    // åˆå§‹åŒ–ç¼ºé™·æ¨™è¨˜å¤§å°èª¿æ•´åŠŸèƒ½
                    if (typeof window.initDefectMarkSizeAdjustment === 'function') {
                        window.initDefectMarkSizeAdjustment();
                    }
                    
                    // é‡æ–°è¨­ç½®ç¸®æ”¾å’Œå¹³ç§»åŠŸèƒ½ï¼Œç¢ºä¿åœ¨ PNE æ–‡ä»¶è¼‰å…¥å¾ŒåŠŸèƒ½æ­£å¸¸
                    window.logger.log('Re-initializing zoom and pan functionality after PNE file load');
                    if (typeof window.setupZoomAndPanEvents === 'function') {
                        window.setupZoomAndPanEvents();
                        window.logger.log('Zoom and pan events re-initialized successfully');
                    } else {
                        window.logger.log('setupZoomAndPanEvents function not available yet');
                    }
                    
                    // æª¢æŸ¥PDFæ–‡ä»¶å¼•ç”¨ï¼ˆä¸å†å¾base64è¼‰å…¥ï¼‰
                    if (data.filePaths && data.filePaths.pdfFileReference) {
                        window.logger.log('PDF file reference found in PNE file:', data.filePaths.pdfFileReference);
                        showNotification('æ¨“å±¤å¹³é¢åœ–è¦–åœ–ç‹€æ…‹å’Œè¨»è§£å·²å¾ PNE æª”æ¡ˆä¸­æ¢å¾©ã€‚è«‹é‡æ–°ä¸Šå‚³ PDF æª”æ¡ˆä»¥æŸ¥çœ‹æ¨“å±¤å¹³é¢åœ–ã€‚', 'info');
                    } else if (data.filePaths && data.filePaths.pdfPath) {
                        window.logger.log('PDF file path found in PNE file:', data.filePaths.pdfPath);
                        showNotification('æ¨“å±¤å¹³é¢åœ–è¦–åœ–ç‹€æ…‹å’Œè¨»è§£å·²å¾ PNE æª”æ¡ˆä¸­æ¢å¾©ã€‚è«‹é‡æ–°ä¸Šå‚³ PDF æª”æ¡ˆä»¥æŸ¥çœ‹æ¨“å±¤å¹³é¢åœ–ã€‚', 'info');
                    } else {
                        showNotification('æ¨“å±¤å¹³é¢åœ–è¦–åœ–ç‹€æ…‹å’Œè¨»è§£å·²å¾ PNE æª”æ¡ˆä¸­æ¢å¾©ï¼Œè«‹æ‰‹å‹•ä¸Šå‚³ PDF æª”æ¡ˆä»¥æŸ¥çœ‹', 'success');
                    }
                }
                
                // æ›´æ–°è¡¨æ ¼è¨ˆæ•¸
                updateTableCount();
                
                // é‡å»ºè¡¨æ ¼
                if (submittedData.length > 0) {
                    // æŒ‰æª¢æŸ¥ç·¨è™Ÿæ’åº submittedData
                    submittedData.sort((a, b) => {
                        const aNo = parseInt(a.locationId) || 0;
                        const bNo = parseInt(b.locationId) || 0;
                        return aNo - bNo;
                    });
                    
                    dataTableBody.innerHTML = '';
                    submittedData.forEach(row => {
                        addTableRow(row);
                    });
                }
                
                // æ›´æ–°æ‰€æœ‰åˆ†é¡é¡¯ç¤ºï¼Œç¢ºä¿å·²æäº¤ç‹€æ…‹åœ¨åœ–ç‰‡ä¸Šåæ˜ 
                categories.forEach(category => {
                    updateCategoryDisplay(category.id);
                });
                // é‡æ–°æ¸²æŸ“ç…§ç‰‡ä»¥å¥—ç”¨ submitted æ¨£å¼ï¼ˆå¦‚æœå·²æœ‰ç…§ç‰‡ï¼‰
                if (allPhotos && allPhotos.length > 0) {
                    const lazyObserver = initLazyLoading ? initLazyLoading() : null;
                    renderPhotos(allPhotos, lazyObserver);
                    
                    // æ¢å¾©ç…§ç‰‡æäº¤ç‹€æ…‹
                    if (data.photoSubmissionStatus) {
                        window.logger.log('Restoring photo submission status');
                        
                        // åªæœ‰åœ¨ photoSubmissionStatus.submittedPhotos æœ‰æ•¸æ“šæ™‚æ‰è¦†è“‹ submittedFilenames
                        if (data.photoSubmissionStatus.submittedPhotos && data.photoSubmissionStatus.submittedPhotos.length > 0) {
                            submittedFilenames = new Set(data.photoSubmissionStatus.submittedPhotos);
                            window.logger.log('Restored submittedFilenames from photoSubmissionStatus:', submittedFilenames.size);
                        } else {
                            window.logger.log('photoSubmissionStatus.submittedPhotos is empty, keeping existing submittedFilenames:', submittedFilenames.size);
                        }
                        
                        // æ¢å¾©ç…§ç‰‡åˆ†é…ç‹€æ…‹
                        if (data.photoSubmissionStatus.photoAssignments) {
                            Object.entries(data.photoSubmissionStatus.photoAssignments).forEach(([categoryId, photoNames]) => {
                                if (assignedPhotos[categoryId]) {
                                    assignedPhotos[categoryId] = new Set(photoNames);
                                }
                            });
                        }
                        
                        // ç­‰å¾…ç…§ç‰‡æ¸²æŸ“å®Œæˆå¾Œå†æ›´æ–°ç‹€æ…‹
                        setTimeout(() => {
                            updatePhotoSubmissionStatus();
                            // é©—è­‰ç…§ç‰‡ç‹€æ…‹æ˜¯å¦èˆ‡ç•¶å‰æ¨™ç±¤æ•¸æ“šä¸€è‡´
                            if (typeof updatePhotoStatusFromLabels === 'function') {
                                updatePhotoStatusFromLabels();
                            }
                        }, 100);
                    }
                } else {
                    // æ²’æœ‰ç…§ç‰‡æ™‚æç¤ºé‡æ–°é¸æ“‡è³‡æ–™å¤¾ä»¥æ¢å¾©å¯¦é«”æª”æ¡ˆ
                    showReselectMessage();
                }
                
                // ç„¡è«–æ˜¯å¦æœ‰ç…§ç‰‡æäº¤ç‹€æ…‹æ•¸æ“šï¼Œéƒ½è¦é©—è­‰ç…§ç‰‡ç‹€æ…‹èˆ‡æ¨™ç±¤æ•¸æ“šçš„ä¸€è‡´æ€§
                setTimeout(() => {
                    if (typeof updatePhotoStatusFromLabels === 'function') {
                        updatePhotoStatusFromLabels();
                    }
                }, 200);
                
                // æ›´æ–°ç•«é¢
                updateFolderDisplay();
                if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}
                if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
                
                // æ›´æ–°ç¼ºé™·åˆ†é¡å…§å®¹é¡¯ç¤º
                updateCategoryDisplay('j');
                
                // ç¢ºä¿ç¸®æ”¾å’Œå¹³ç§»åŠŸèƒ½åœ¨ PNE æ–‡ä»¶è¼‰å…¥å¾Œæ­£å¸¸å·¥ä½œ
                window.logger.log('Ensuring zoom and pan functionality is available after PNE file load');
                setTimeout(() => {
                    if (typeof window.setupZoomAndPanEvents === 'function') {
                        window.setupZoomAndPanEvents();
                        window.logger.log('Zoom and pan events set up after PNE file load');
                    } else {
                        window.logger.log('setupZoomAndPanEvents function not available, will retry later');
                        // å¦‚æœå‡½æ•¸é‚„ä¸å¯ç”¨ï¼Œç¨å¾Œå†è©¦
                        setTimeout(() => {
                            if (typeof window.setupZoomAndPanEvents === 'function') {
                                window.setupZoomAndPanEvents();
                                window.logger.log('Zoom and pan events set up on retry');
                            }
                        }, 1000);
                    }
                }, 100);
                
                // é¡¯ç¤ºè¼‰å…¥æˆåŠŸè¨Šæ¯ï¼ŒåŒ…å«çµ±è¨ˆè³‡è¨Š
                let successMsg = 'PNE æª”æ¡ˆè¼‰å…¥æˆåŠŸï¼';
                if (data.totalPhotos) {
                    successMsg += ` (${data.totalPhotos} å¼µç…§ç‰‡, ${data.totalAssignments || 0} å€‹åˆ†é…)`;
                }
                if (data.filePaths && data.filePaths.pdfPath) {
                    successMsg += `, PDF æª”æ¡ˆå·²æ¢å¾©`;
                }
                if (data.embeddedPDF && data.embeddedPDF.hasEmbeddedPDF) {
                    successMsg += `, PDF æª”æ¡ˆ "${data.embeddedPDF.filename}" å·²è¼‰å…¥`;
                }
                if (data.floorPlanLabels && data.floorPlanLabels.length > 0) {
                    successMsg += `, ${data.floorPlanLabels.length} å€‹æ¨™ç±¤å·²æ¢å¾©`;
                }
                if (data.floorPlanDefectMarks && data.floorPlanDefectMarks.length > 0) {
                    successMsg += `, ${data.floorPlanDefectMarks.length} å€‹ç¼ºé™·æ¨™è¨˜å·²æ¢å¾©`;
                }
                if (data.floorPlanViewState) {
                    successMsg += `, è¦–åœ–ç‹€æ…‹å·²æ¢å¾© (ç¸®æ”¾: ${Math.round((data.floorPlanViewState.scale || 1) * 100)}%)`;
                }
                if (data.exportDate) {
                    const exportDate = new Date(data.exportDate);
                    const timeDiff = Date.now() - exportDate.getTime();
                    const daysDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
                    if (daysDiff > 0) {
                        successMsg += ` - åŒ¯å‡ºæ–¼ ${daysDiff} å¤©å‰`;
                    }
                }
                
                showNotification(successMsg, 'success');
                
                // ä¿å­˜åˆ°localStorageä»¥ä¿æŒä¸€è‡´æ€§
                console.log('ğŸ” About to call saveDataToStorage...');
                console.log('ğŸ” Current submittedFilenames before save:', submittedFilenames.size, Array.from(submittedFilenames));
                saveDataToStorage();
                console.log('ğŸ” saveDataToStorage completed');
                
                // æ›´æ–°ç¼ºé™·æ¨™è¨˜å¤§å°UIå’Œå¯¦éš›æ¨™è¨˜å¤§å°
                if (typeof updateDefectMarkSizeUI === 'function') {
                    updateDefectMarkSizeUI();
                }
                if (typeof updateAllDefectMarkSizes === 'function') {
                    updateAllDefectMarkSizes();
                }
                
            } catch (err) {
                showNotification('è¼‰å…¥ PNE æª”æ¡ˆå¤±æ•—: ' + err.message, 'error');
            }
        }
    });
    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
});

// Defects Reportäº’å‹•
const defectPreviewBtn = document.querySelector('.pne-dropdown-item[data-action="preview"]');
const defectPreviewPopup = document.getElementById('defectPreviewPopup');
const closeDefectPreview = document.getElementById('closeDefectPreview');
defectPreviewBtn.addEventListener('click', function() {
    // é—œé–‰ä¸‹æ‹‰é¸å–®
    const pneDropdown = document.querySelector('.pne-dropdown');
    if (pneDropdown) {
        pneDropdown.style.display = 'none';
    }
  defectPreviewPopup.style.display = 'flex';
});
closeDefectPreview.addEventListener('click', function() {
  defectPreviewPopup.style.display = 'none';
});
defectPreviewPopup.addEventListener('click', function(e) {
  if(e.target === defectPreviewPopup) defectPreviewPopup.style.display = 'none';
});


// Export PDFåŠŸèƒ½ï¼ˆæš«æ™‚åœç”¨ - åŠŸèƒ½å³å°‡æ¨å‡ºï¼‰
const exportDefectPDF = document.getElementById('exportDefectPDF');
exportDefectPDF.addEventListener('click', function(e) {
  e.preventDefault();
  // åŠŸèƒ½æš«æ™‚åœç”¨
  showNotification('This function is coming soon!', 'info');
  return false;
  
  // åŸå§‹åŠŸèƒ½ç¨‹å¼ç¢¼ä¿ç•™ä½†åœç”¨
  /*
  const content = document.getElementById('pdfCanvas');
  const opt = {
    margin:       0.3,
    filename:     'Defect_Report.pdf',
    image:        { type: 'jpeg', quality: 0.98 },
    html2canvas:  { scale: 2 },
    jsPDF:        { unit: 'in', format: 'a4', orientation: 'portrait' }
  };
  html2pdf().set(opt).from(content).save();
  */
});

// é é¢è¼‰å…¥æ™‚ä¸è‡ªå‹•é¡¯ç¤º defectPreviewPopupï¼Œä¸”é è¨­ç‚ºéš±è—
document.addEventListener('DOMContentLoaded', function() {
    var popup = document.getElementById('defectPreviewPopup');
    if (popup) popup.style.display = 'none';
});



// Function to update location fields based on inspection number
function updateLocationFromInspectionNo(inspectionNo) {
    // Find the inspection record with matching inspection number
    const inspectionRecord = submittedData.find(row => row.locationId === inspectionNo);
    
    if (inspectionRecord) {
        // Update the location fields with data from inspection record
        document.getElementById('defectFloor').value = inspectionRecord.floor || '';
        document.getElementById('defectAreaName').value = inspectionRecord.areaName || '';
        document.getElementById('defectRoomNo').value = inspectionRecord.roomNo || '';
    } else {
        // Clear the fields if no matching inspection record found
        document.getElementById('defectFloor').value = '';
        document.getElementById('defectAreaName').value = '';
        document.getElementById('defectRoomNo').value = '';
    }
}

// Function to update table defects display
function updateTableDefectsDisplay() {
    // Update all table rows to refresh their defects display
    submittedData.forEach(rowData => {
        if (rowData.j && rowData.j !== 'N/A') {
            const rowElement = document.querySelector(`tr[data-id="${rowData.id}"]`);
            if (rowElement) {
                const defectsCell = rowElement.querySelector('.defects-cell');
                if (defectsCell) {
                    defectsCell.innerHTML = generateDefectsWithButtons(rowData.j, rowData.id);
                }
            }
        }
    });
}

// Function to update Inspection Records Defects based on inspection number
// Helper function to update photo number columns for an inspection record
// This function works the same way as updateCategoryDisplay for categories A-I
function updateInspectionRecordPhotoColumns(inspectionRecord) {
    const recordRowElement = document.querySelector(`tr[data-id="${inspectionRecord.id}"]`);
    if (recordRowElement) {
        const categories = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'];
        categories.forEach((cat, index) => {
            const columnIndex = index + 4; // Categories start at column 4
            
            // Get photo numbers for this category that belong to this inspection record
            const photoNumbers = [];
            
            // Check categoryNumbers for this category and filter by inspection record
            if (categoryNumbers[cat] && categoryNumbers[cat].length > 0) {
                categoryNumbers[cat].forEach(number => {
                    // Check if this photo number belongs to this inspection record
                    // by checking if any defect entry with this category and number belongs to this inspection record
                    const belongsToThisRecord = submittedDefectEntries.some(entry => 
                        entry.category === cat && 
                        entry.locationId === inspectionRecord.locationId && 
                        entry.numbers && 
                        entry.numbers.includes(number)
                    );
                    
                    if (belongsToThisRecord && !photoNumbers.includes(number)) {
                        photoNumbers.push(number);
                    }
                });
            }
            
            // Update the column with formatted numbers (same as updateCategoryDisplay)
            if (photoNumbers.length > 0) {
                const formattedNumbers = formatNumbers(photoNumbers.sort((a, b) => parseInt(a) - parseInt(b)));
                if (recordRowElement.children.length > columnIndex && recordRowElement.children[columnIndex]) {
                    recordRowElement.children[columnIndex].textContent = formattedNumbers;
                }
                inspectionRecord[cat] = formattedNumbers;
            } else {
                if (recordRowElement.children.length > columnIndex && recordRowElement.children[columnIndex]) {
                    recordRowElement.children[columnIndex].textContent = 'N/A';
                }
                inspectionRecord[cat] = 'N/A';
            }
        });
    }
}

// COMPREHENSIVE DATA RENEWAL SYSTEM
// This function handles all data updates when defects are moved between inspection records
// IMPORTANT: Only moves photos for Defects category (J), keeps other categories (A-I) in their original locations
function renewInspectionRecordData(defectEntry, newInspectionNo, oldInspectionNo = null) {
    window.logger.log('=== DATA RENEWAL SYSTEM ===');
    window.logger.log('Defect Entry:', defectEntry);
    window.logger.log('New Inspection No:', newInspectionNo);
    window.logger.log('Old Inspection No:', oldInspectionNo);
    
    // Step 1: Find the inspection records
    const newInspectionRecord = submittedData.find(row => row.locationId === newInspectionNo);
    const oldInspectionRecord = oldInspectionNo ? submittedData.find(row => row.locationId === oldInspectionNo) : null;
    
    if (!newInspectionRecord) {
        window.logger.error('New inspection record not found:', newInspectionNo);
        return;
    }
    
    // Step 2: Get photo filenames for this defect (ONLY FOR DEFECTS CATEGORY J)
    const defectPhotoFilenames = [];
    if (defectEntry.numbers && defectEntry.numbers.length > 0) {
        defectEntry.numbers.forEach(number => {
            allPhotos.forEach(file => {
                const fileName = file.name;
                const numberMatch = fileName.match(/\d+/);
                if (numberMatch && numberMatch[0] === number) {
                    defectPhotoFilenames.push(fileName);
                }
            });
        });
    }
    
    window.logger.log('Defect photo filenames (J category only):', defectPhotoFilenames);
    
    // Step 3: MOVE PHOTOS TO NEW INSPECTION RECORD AND UPDATE CATEGORY ASSIGNMENTS
    // When defect moves to new record, its photos must move to the same category in the new record
    // and be removed from the same category in the old record
    if (oldInspectionRecord && oldInspectionNo !== newInspectionNo) {
        window.logger.log('Moving defect photos between inspection records');
        
        // If this defect has a category (A-I), we need to update the category assignments
        if (defectEntry.category && defectEntry.category !== 'j') {
            window.logger.log(`Updating category ${defectEntry.category.toUpperCase()} assignments`);
            
            defectPhotoFilenames.forEach(filename => {
                const numberMatch = filename.match(/\d+/);
                if (numberMatch) {
                    const photoNumber = numberMatch[0];
                    
                    // Remove photo number from the same category in ALL inspection records
                    // because photo numbers must be unique per category across the system
                    submittedData.forEach(record => {
                        if (record.locationId !== newInspectionNo) {
                            // Check if this record has this photo number in the same category
                            const hasPhotoInSameCategory = submittedDefectEntries.some(entry => 
                                entry.category === defectEntry.category && 
                                entry.locationId === record.locationId && 
                                entry.numbers && 
                                entry.numbers.includes(photoNumber)
                            );
                            
                            if (hasPhotoInSameCategory) {
                                // Remove from old record's photoFilenames
                                const photoIndex = record.photoFilenames.indexOf(filename);
                                if (photoIndex > -1) {
                                    record.photoFilenames.splice(photoIndex, 1);
                                    window.logger.log(`Removed ${filename} from record ${record.locationId} (same category reassignment)`);
                                }
                                
                                // Update folder name for the affected record
                                updateInspectionRecordFolderName(record);
                            }
                        }
                    });
                    
                    // Remove from category numbers and assigned photos globally
                    const categoryNumberIndex = categoryNumbers[defectEntry.category].indexOf(photoNumber);
                    if (categoryNumberIndex > -1) {
                        categoryNumbers[defectEntry.category].splice(categoryNumberIndex, 1);
                        window.logger.log(`Removed photo number ${photoNumber} from category ${defectEntry.category.toUpperCase()} globally`);
                    }
                    
                    assignedPhotos[defectEntry.category].delete(filename);
                    window.logger.log(`Removed ${filename} from assigned photos for category ${defectEntry.category.toUpperCase()}`);
                }
            });
        }
    }
    
    // Step 4: Update photoFilenames for defect photos
    if (oldInspectionRecord && oldInspectionNo !== newInspectionNo) {
        // Remove defect photos from old record (they've already been removed from other categories above)
        defectPhotoFilenames.forEach(filename => {
            const index = oldInspectionRecord.photoFilenames.indexOf(filename);
            if (index > -1) {
                oldInspectionRecord.photoFilenames.splice(index, 1);
                window.logger.log(`Removed ${filename} from old record ${oldInspectionNo}`);
            }
        });
        
        // Add photos to new record (avoid duplicates)
        defectPhotoFilenames.forEach(filename => {
            if (!newInspectionRecord.photoFilenames.includes(filename)) {
                newInspectionRecord.photoFilenames.push(filename);
                window.logger.log(`Added ${filename} to new record ${newInspectionNo}`);
            }
        });
        
        // Update folder names if needed
        updateInspectionRecordFolderName(oldInspectionRecord);
        updateInspectionRecordFolderName(newInspectionRecord);
    }
    
    // Step 5: Update photo status in UI
    defectPhotoFilenames.forEach(filename => {
        const photoItems = document.querySelectorAll('.photo-item');
        for (const item of photoItems) {
            if (item.dataset.filename === filename) {
                const statusDiv = item.querySelector('.photo-status');
                if (statusDiv) {
                    statusDiv.textContent = newInspectionNo;
                }
            }
        }
    });
    
    // Step 6: Update photoFolders array
    if (oldInspectionRecord && oldInspectionNo !== newInspectionNo) {
        // Update old folder - remove defect photos
        const oldFolderIndex = photoFolders.findIndex(folder => folder.locationId === oldInspectionNo);
        if (oldFolderIndex !== -1) {
            defectPhotoFilenames.forEach(filename => {
                const photoIndex = photoFolders[oldFolderIndex].photos.indexOf(filename);
                if (photoIndex > -1) {
                    photoFolders[oldFolderIndex].photos.splice(photoIndex, 1);
                }
            });
            
            // If old folder is empty, remove it
            if (photoFolders[oldFolderIndex].photos.length === 0) {
                photoFolders.splice(oldFolderIndex, 1);
                window.logger.log(`Removed empty folder for ${oldInspectionNo}`);
            }
        }
        
        // Update new folder
        let newFolderIndex = photoFolders.findIndex(folder => folder.locationId === newInspectionNo);
        if (newFolderIndex === -1) {
            // Create new folder if it doesn't exist
            photoFolders.push({
                name: newInspectionRecord.folderName || `${newInspectionNo}_folder`,
                photos: [...defectPhotoFilenames],
                locationId: newInspectionNo
            });
            window.logger.log(`Created new folder for ${newInspectionNo}`);
        } else {
            // Add photos to existing folder (avoid duplicates)
            defectPhotoFilenames.forEach(filename => {
                if (!photoFolders[newFolderIndex].photos.includes(filename)) {
                    photoFolders[newFolderIndex].photos.push(filename);
                }
            });
        }
    }
    
    // Step 7: Save data to storage
    saveDataToStorage();
    
    window.logger.log('=== DATA RENEWAL COMPLETED ===');
    window.logger.log('Updated old record:', oldInspectionRecord);
    window.logger.log('Updated new record:', newInspectionRecord);
    window.logger.log('Updated photoFolders:', photoFolders);
    
    // VERIFICATION: Log the current state of categories after reassignment
    window.logger.log('=== VERIFICATION ===');
    window.logger.log('Current categoryNumbers:', categoryNumbers);
    window.logger.log('Current assignedPhotos:', assignedPhotos);
    
    // Check category reassignment results
    const categories = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'];
    categories.forEach(cat => {
        const numbersInCategory = categoryNumbers[cat] || [];
        const photosInCategory = Array.from(assignedPhotos[cat] || []);
        window.logger.log(`Category ${cat.toUpperCase()}: Numbers=[${numbersInCategory.join(', ')}], Photos=[${photosInCategory.join(', ')}]`);
    });
}

// Helper function to update folder name based on current photos
function updateInspectionRecordFolderName(inspectionRecord) {
    if (!inspectionRecord.photoFilenames || inspectionRecord.photoFilenames.length === 0) {
        inspectionRecord.folderName = '';
        return;
    }
    
    const photoNumbers = [];
    inspectionRecord.photoFilenames.forEach(filename => {
        const numberMatch = filename.match(/\d+/);
        if (numberMatch) {
            photoNumbers.push(parseInt(numberMatch[0]));
        }
    });
    
    if (photoNumbers.length > 0) {
        const minNumber = Math.min(...photoNumbers);
        const maxNumber = Math.max(...photoNumbers);
        const folderDate = formatFolderDate(inspectionRecord.inspectionDateRaw || inspectionRecord.inspectionDate);
        inspectionRecord.folderName = `${inspectionRecord.locationId}_${folderDate} (${minNumber}-${maxNumber})`;
        window.logger.log(`Updated folder name: ${inspectionRecord.folderName}`);
    }
}
// DATA INTEGRITY VALIDATION SYSTEM
// This function validates and ensures data consistency across all data structures
function validateDataIntegrity() {
    window.logger.log('=== DATA INTEGRITY VALIDATION ===');
    
    let validationErrors = [];
    let fixedIssues = [];
    
    // 1. Validate submittedData consistency
    submittedData.forEach(record => {
        if (!record.photoFilenames) {
            record.photoFilenames = [];
            fixedIssues.push(`Fixed missing photoFilenames for record ${record.locationId}`);
        }
        
        // Ensure photoFilenames contains only valid filenames
        const validFilenames = [];
        record.photoFilenames.forEach(filename => {
            const fileExists = allPhotos.some(photo => photo.name === filename);
            if (fileExists) {
                validFilenames.push(filename);
            } else {
                fixedIssues.push(`Removed invalid filename ${filename} from record ${record.locationId}`);
            }
        });
        record.photoFilenames = validFilenames;
    });
    
    // 2. Validate photoFolders consistency
    photoFolders.forEach((folder, index) => {
        const relatedRecord = submittedData.find(record => record.locationId === folder.locationId);
        if (!relatedRecord) {
            photoFolders.splice(index, 1);
            fixedIssues.push(`Removed orphaned folder ${folder.name}`);
            return;
        }
        
        // Ensure folder photos match record photoFilenames
        const validPhotos = [];
        folder.photos.forEach(filename => {
            if (relatedRecord.photoFilenames.includes(filename)) {
                validPhotos.push(filename);
            } else {
                fixedIssues.push(`Removed invalid photo ${filename} from folder ${folder.name}`);
            }
        });
        folder.photos = validPhotos;
    });
    
    // 3. Validate categoryNumbers and assignedPhotos consistency
    categories.forEach(category => {
        const categoryId = category.id;
        
        // Ensure categoryNumbers has corresponding files in assignedPhotos
        const validNumbers = [];
        categoryNumbers[categoryId].forEach(number => {
            const hasCorrespondingFile = Array.from(assignedPhotos[categoryId]).some(filename => {
                const numberMatch = filename.match(/\d+/);
                return numberMatch && numberMatch[0] === number;
            });
            
            if (hasCorrespondingFile) {
                validNumbers.push(number);
            } else {
                fixedIssues.push(`Removed orphaned number ${number} from category ${categoryId.toUpperCase()}`);
            }
        });
        categoryNumbers[categoryId] = validNumbers;
        
        // Ensure assignedPhotos files exist in allPhotos
        const validAssignedPhotos = new Set();
        assignedPhotos[categoryId].forEach(filename => {
            const fileExists = allPhotos.some(photo => photo.name === filename);
            if (fileExists) {
                validAssignedPhotos.add(filename);
            } else {
                fixedIssues.push(`Removed invalid assigned photo ${filename} from category ${categoryId.toUpperCase()}`);
            }
        });
        assignedPhotos[categoryId] = validAssignedPhotos;
    });
    
    // 4. Validate submittedDefectEntries consistency
    // Only validate if submittedData is not empty (to avoid clearing defect entries after clearTable)
    if (submittedData.length > 0) {
        const validDefectEntries = [];
        submittedDefectEntries.forEach(entry => {
            const relatedRecord = submittedData.find(record => record.locationId === entry.locationId);
            if (relatedRecord) {
                validDefectEntries.push(entry);
            } else {
                fixedIssues.push(`Removed orphaned defect entry for location ${entry.locationId}`);
            }
        });
        window.submittedDefectEntries.length = 0;
        window.submittedDefectEntries.push(...validDefectEntries);
    } else {
        window.logger.log('validateDataIntegrity: submittedData is empty, skipping submittedDefectEntries validation');
    }
    
    // 5. Report validation results
    if (validationErrors.length > 0) {
        window.logger.warn('Data integrity validation errors:', validationErrors);
        showNotification(`Found ${validationErrors.length} data integrity issues`, 'warning');
    }
    
    if (fixedIssues.length > 0) {
        window.logger.log('Data integrity issues fixed:', fixedIssues);
        showNotification(`Fixed ${fixedIssues.length} data integrity issues`, 'success');
        
        // Save corrected data
        saveDataToStorage();
    }
    
    window.logger.log('=== DATA INTEGRITY VALIDATION COMPLETED ===');
    return { errors: validationErrors, fixes: fixedIssues };
}

function updateInspectionRecordsDefects(inspectionNo, defectEntry, oldInspectionNo = null) {
    // Generate the defect string
    const defectStr = `${defectEntry.range}_${defectEntry.description}`;
    
    // If old inspection number is provided and different from new one, remove from old record
    if (oldInspectionNo && oldInspectionNo !== inspectionNo) {
        window.logger.log('Moving defect from old record to new record');
        window.logger.log('Old inspection number:', oldInspectionNo);
        window.logger.log('New inspection number:', inspectionNo);
        
        const oldInspectionRecord = submittedData.find(row => row.locationId === oldInspectionNo);
        window.logger.log('Old inspection record found:', !!oldInspectionRecord);
        
        // Store the original photo numbers for this defect category before moving
        const originalPhotoNumbers = defectEntry.numbers ? [...defectEntry.numbers] : [];
        window.logger.log('Original photo numbers for defect:', originalPhotoNumbers);
        
        if (oldInspectionRecord && oldInspectionRecord.j && oldInspectionRecord.j !== 'N/A') {
            window.logger.log('Old inspection record defects before removal:', oldInspectionRecord.j);
            const existingDefects = oldInspectionRecord.j.split('\n');
            // Remove the defect by matching the range and description (without asterisk)
            const oldDefectPattern = `${defectEntry.range}_${defectEntry.description}`;
            window.logger.log('Looking for defect pattern to remove:', oldDefectPattern);
            
            const filteredDefects = existingDefects.filter(defect => {
                const cleanDefect = defect.trim().replace(/^\* /, ''); // Remove asterisk prefix
                const matches = cleanDefect !== oldDefectPattern;
                window.logger.log('Checking defect:', defect, 'clean:', cleanDefect, 'keep:', matches);
                return matches;
            });
            
            oldInspectionRecord.j = filteredDefects.length > 0 ? filteredDefects.join('\n') : 'N/A';
            window.logger.log('Old inspection record defects after removal:', oldInspectionRecord.j);
            
            // Update the old record's row
            const oldRowElement = document.querySelector(`tr[data-id="${oldInspectionRecord.id}"]`);
            if (oldRowElement) {
                // Check if the row has enough columns before updating
                if (oldRowElement.children.length > 13 && oldRowElement.children[13]) {
                    oldRowElement.children[13].innerHTML = generateDefectsWithButtons(oldInspectionRecord.j, oldInspectionRecord.id);
                }
                // Check if there are any remaining imminent danger defects
                const hasRemainingImminentDanger = filteredDefects.some(defect => defect.trim().startsWith('* '));
                oldInspectionRecord.hasImminentDanger = hasRemainingImminentDanger;
                if (oldRowElement.children.length > 14 && oldRowElement.children[14]) {
                    oldRowElement.children[14].textContent = hasRemainingImminentDanger ? 'Yes' : 'No';
                }
                window.logger.log('Updated old record row in table');
            }
        }
    }
    
    // Find the inspection record with matching inspection number
    const inspectionRecord = submittedData.find(row => row.locationId === inspectionNo);
    window.logger.log('New inspection record found:', !!inspectionRecord);
    
    if (inspectionRecord) {
        window.logger.log('New inspection record defects before update:', inspectionRecord.j);
        
        // First, remove the old version of this defect if it exists
        if (inspectionRecord.j && inspectionRecord.j !== 'N/A') {
            const existingDefects = inspectionRecord.j.split('\n');
            // Remove the old version by matching the range and description (without asterisk)
            const oldDefectPattern = `${defectEntry.range}_${defectEntry.description}`;
            window.logger.log('Removing old version of defect pattern:', oldDefectPattern);
            
            const filteredDefects = existingDefects.filter(defect => {
                const cleanDefect = defect.trim().replace(/^\* /, ''); // Remove asterisk prefix
                const matches = cleanDefect !== oldDefectPattern;
                window.logger.log('Checking existing defect:', defect, 'clean:', cleanDefect, 'keep:', matches);
                return matches;
            });
            inspectionRecord.j = filteredDefects.length > 0 ? filteredDefects.join('\n') : 'N/A';
        }
        
        window.logger.log('Adding new defect string:', defectStr);
        // Now add the updated defect
        if (!inspectionRecord.j || inspectionRecord.j === 'N/A') {
            inspectionRecord.j = defectStr;
        } else {
            inspectionRecord.j += '\n' + defectStr;
        }
        
        window.logger.log('New inspection record defects after update:', inspectionRecord.j);
        
        // ç§»é™¤ï¼šä¸å†è‡ªå‹•æ›´æ–° imminent danger ç‹€æ…‹ï¼Œé˜²æ­¢æ„å¤–è®Šæ›´
        // if (typeof updateImminentDangerInInspectionRecords === 'function') {
        //     updateImminentDangerInInspectionRecords();
        // } else {
        //     // å‚™ç”¨é‚è¼¯ï¼šæª¢æŸ¥ç¼ºé™·è¨˜éŒ„ä¸­çš„ imminent danger
        //     if (defectEntry.imminentDanger) {
        //         inspectionRecord.hasImminentDanger = true;
        //     } else {
        //         // Check if there are any remaining imminent danger defects
        //         const allDefects = inspectionRecord.j.split('\n');
        //         inspectionRecord.hasImminentDanger = allDefects.some(defect => defect.trim().startsWith('* '));
        //     }
        // }
        
        // Re-render the specific row in the inspection records table
        const rowElement = document.querySelector(`tr[data-id="${inspectionRecord.id}"]`);
        if (rowElement) {
            // Update the defects column (column 13, index 13)
            if (rowElement.children.length > 13 && rowElement.children[13]) {
                rowElement.children[13].innerHTML = generateDefectsWithButtons(inspectionRecord.j, inspectionRecord.id);
            }
            // Update the imminent danger column (column 14, index 14)
            if (rowElement.children.length > 14 && rowElement.children[14]) {
                rowElement.children[14].textContent = inspectionRecord.hasImminentDanger ? 'Yes' : 'No';
            }
        }
        

        
        // Update categoryNumbers and assignedPhotos when defect moves between inspection records
        if (oldInspectionNo && oldInspectionNo !== inspectionNo && defectEntry.category && defectEntry.category !== 'j') {
            window.logger.log('Updating categoryNumbers and assignedPhotos for defect move');
            window.logger.log('Defect category:', defectEntry.category);
            window.logger.log('Defect photo numbers:', originalPhotoNumbers);
    
            // The category reassignment has already been handled by renewInspectionRecordData
            // We just need to update the category display to reflect the change
            updateCategoryDisplay(defectEntry.category);
        }
        
        // AUTO-ASSIGN DEFECT PHOTOS TO SAME CATEGORY COLUMN
        // If defect has a category (A-I) and photo numbers, auto-assign them to the same category column
        // IMPORTANT: This only affects the defect's own category, not other categories
        if (defectEntry.category && defectEntry.category !== 'j' && defectEntry.numbers && defectEntry.numbers.length > 0) {
            window.logger.log('Auto-assigning defect photos to same category column');
            window.logger.log('Defect category:', defectEntry.category);
            window.logger.log('Defect photo numbers:', defectEntry.numbers);
    
            // SAFETY CHECK: Only modify the defect's own category, preserve other categories
            const targetCategory = defectEntry.category;
        
            // Add the photo numbers to the category if they're not already there
            let addedNumbers = 0;
            defectEntry.numbers.forEach(number => {
                if (!categoryNumbers[targetCategory].includes(number)) {
                    categoryNumbers[targetCategory].push(number);
                    addedNumbers++;
                }
                
                // Also add to assignedPhotos for visual feedback
                allPhotos.forEach(file => {
                    const fileName = file.name;
                    const numberMatch = fileName.match(/\d+/);
                    if (numberMatch && numberMatch[0] === number) {
                        assignedPhotos[targetCategory].add(fileName);
                }
                });
            });

            if (addedNumbers > 0) {
                window.logger.log(`Auto-assigned ${addedNumbers} photo numbers to category ${targetCategory.toUpperCase()}`);
                // Update the category display to show the new numbers
                updateCategoryDisplay(targetCategory);
        }
        
            // VERIFICATION: Check category reassignment results
            window.logger.log('=== CATEGORY REASSIGNMENT CHECK ===');
            window.logger.log(`Target category ${targetCategory.toUpperCase()} now has: ${categoryNumbers[targetCategory].length} numbers`);
            const otherCategories = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'].filter(cat => cat !== targetCategory);
            otherCategories.forEach(cat => {
                window.logger.log(`Category ${cat.toUpperCase()} has: ${categoryNumbers[cat].length} numbers`);
            });
        }
        
        // CALL COMPREHENSIVE DATA RENEWAL SYSTEM
        // This handles all data updates including photoFilenames, photoFolders, and UI updates
        if (oldInspectionNo && oldInspectionNo !== inspectionNo) {
            window.logger.log('Calling data renewal system for defect move');
            renewInspectionRecordData(defectEntry, inspectionNo, oldInspectionNo);
        
            // Validate data integrity after renewal
            validateDataIntegrity();
            }
        
        // Update photo number columns for both old and new inspection records after defect move
        if (oldInspectionNo && oldInspectionNo !== inspectionNo) {
            const oldInspectionRecord = submittedData.find(row => row.locationId === oldInspectionNo);
            
            window.logger.log('Updating photo number columns for both records');
            window.logger.log('Defect category:', defectEntry.category);
            window.logger.log('Defect photo numbers:', originalPhotoNumbers);
            
            // Update both old and new inspection records using the helper function
            if (oldInspectionRecord) {
                updateInspectionRecordPhotoColumns(oldInspectionRecord);
            }
            updateInspectionRecordPhotoColumns(inspectionRecord);
                    } else {
            // Even if not moving between records, update the current record
            updateInspectionRecordPhotoColumns(inspectionRecord);
        }
        
        showNotification(`Defect updated in Inspection Records for ${inspectionNo}`, 'success');
                    
        // Update category tables from inspection records
        if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}
    }
}




// ç§»é™¤ï¼šä¸å†è‡ªå‹•æ›´æ–° Imminent Danger æ¬„ä½ï¼Œé˜²æ­¢æ„å¤–è®Šæ›´
// function updateImminentDangerInInspectionRecords() {
//     // æ­¤å‡½æ•¸å·²è¢«ç¦ç”¨ï¼Œé˜²æ­¢ Imminent Danger æ¬„ä½è¢«è‡ªå‹•ä¿®æ”¹
//     window.logger.log('Imminent danger auto-update disabled to prevent unwanted changes');
// }

// æ–‡ä»¶é¡¯ç¤ºç³»çµ±ï¼ˆåŸºæ–¼ JSON çµæ§‹ç¤ºä¾‹ï¼‰
function createFileDisplaySystem(files) {
    window.logger.log('Creating file display system with', files.length, 'files');
    
    // å‰µå»ºæ–‡ä»¶é¡¯ç¤ºå®¹å™¨
    let fileDisplayContainer = document.getElementById('fileDisplayContainer');
    if (!fileDisplayContainer) {
        fileDisplayContainer = document.createElement('div');
        fileDisplayContainer.id = 'fileDisplayContainer';
        fileDisplayContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            font-family: Arial, sans-serif;
        `;
        
        // å‰µå»ºä¸»å®¹å™¨
        const mainContainer = document.createElement('div');
        mainContainer.style.cssText = `
            background: white;
            border-radius: 12px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        `;
        
        // å‰µå»ºæ¨™é¡Œæ¬„
        const header = document.createElement('div');
        header.style.cssText = `
            background: var(--primary, #1e88e5);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        `;
        header.innerHTML = `
            <h2 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                <i class="fas fa-file-import"></i> æ–‡ä»¶é è¦½å™¨
            </h2>
            <button id="closeFileDisplay" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">
                <i class="fas fa-times"></i>
            </button>
        `;
        
        // å‰µå»ºæ–‡ä»¶ç¶²æ ¼
        const fileGrid = document.createElement('div');
        fileGrid.id = 'fileGrid';
        fileGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        `;
        
        // å‰µå»ºé è¦½å®¹å™¨
        const previewContainer = document.createElement('div');
        previewContainer.id = 'previewContainer';
        previewContainer.style.cssText = `
            background: #f8f9fa;
            padding: 20px;
            border-top: 1px solid #e9ecef;
            min-height: 200px;
            display: none;
        `;
        
        mainContainer.appendChild(header);
        mainContainer.appendChild(fileGrid);
        mainContainer.appendChild(previewContainer);
        fileDisplayContainer.appendChild(mainContainer);
        document.body.appendChild(fileDisplayContainer);
        
        // æ·»åŠ é—œé–‰æŒ‰éˆ•äº‹ä»¶
        const closeBtn = header.querySelector('#closeFileDisplay');
        closeBtn.addEventListener('click', () => {
            fileDisplayContainer.remove();
        });
        
        // é»æ“ŠèƒŒæ™¯é—œé–‰
        fileDisplayContainer.addEventListener('click', (e) => {
            if (e.target === fileDisplayContainer) {
                fileDisplayContainer.remove();
            }
        });
    }
    
    // æ¸²æŸ“æ–‡ä»¶åˆ—è¡¨
    renderFileList(files);
}

function renderFileList(files) {
    const fileGrid = document.getElementById('fileGrid');
    const previewContainer = document.getElementById('previewContainer');
    
    if (!fileGrid) return;
    
    // æ¸…ç©ºç¾æœ‰å…§å®¹
    fileGrid.innerHTML = '';
    
    files.forEach(file => {
        const fileCard = document.createElement('div');
        fileCard.style.cssText = `
            background: white;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        `;
        
        // æ‡¸åœæ•ˆæœ
        fileCard.addEventListener('mouseenter', () => {
            fileCard.style.transform = 'translateY(-2px)';
            fileCard.style.boxShadow = '0 4px 15px rgba(0,0,0,0.2)';
        });
        
        fileCard.addEventListener('mouseleave', () => {
            fileCard.style.transform = 'translateY(0)';
            fileCard.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
        });
        
        // æ–‡ä»¶åœ–æ¨™
        const icon = file.type === 'image' ? 'ğŸ–¼ï¸' : 'ğŸ“„';
        
        fileCard.innerHTML = `
            <div style="font-size: 48px; margin-bottom: 10px;">${icon}</div>
            <div style="font-weight: bold; margin-bottom: 5px; word-break: break-word;">${file.name}</div>
            <div style="color: #666; font-size: 0.9em; margin-bottom: 5px;">${file.type.toUpperCase()}</div>
            <div style="color: #888; font-size: 0.8em;">${file.size}</div>
        `;
        
        // é»æ“Šäº‹ä»¶
        fileCard.addEventListener('click', () => {
            previewFile(file);
            previewContainer.style.display = 'block';
        });
        
        fileGrid.appendChild(fileCard);
    });
}

function previewFile(file) {
    let previewContent = document.getElementById('previewContent');
    if (!previewContent) {
        const previewContainer = document.getElementById('previewContainer');
        if (!previewContainer) return;
        
        const content = document.createElement('div');
        content.id = 'previewContent';
        content.style.cssText = `
            text-align: center;
        `;
        previewContainer.appendChild(content);
        previewContent = content;
    }
    
    if (file.type === 'image') {
        if (file.dataURL) {
            // ä½¿ç”¨ dataURL é¡¯ç¤ºåœ–ç‰‡
            previewContent.innerHTML = `
                <h3 style="color: var(--primary, #1e88e5); margin-bottom: 20px;">${file.name}</h3>
                <img src="${file.dataURL}" alt="${file.name}" style="max-width: 100%; max-height: 500px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);" onerror="handleImageError(this)">
                <p style="margin-top: 15px; color: #666;">ä¸Šå‚³æ—¥æœŸ: ${new Date(file.uploadDate).toLocaleDateString()} | å¤§å°: ${file.size}</p>
            `;
        } else {
            previewContent.innerHTML = `
                <h3 style="color: var(--primary, #1e88e5); margin-bottom: 20px;">${file.name}</h3>
                <div style="padding: 40px; color: #666;">
                    <i class="fas fa-image" style="font-size: 48px; margin-bottom: 15px;"></i>
                    <p>åœ–ç‰‡æ•¸æ“šä¸å¯ç”¨</p>
                    <p style="font-size: 0.9em;">è·¯å¾‘: ${file.path}</p>
                </div>
                <p style="margin-top: 15px; color: #666;">ä¸Šå‚³æ—¥æœŸ: ${new Date(file.uploadDate).toLocaleDateString()} | å¤§å°: ${file.size}</p>
            `;
        }
    } else if (file.type === 'pdf') {
        if (file.hasBase64Data) {
            // å˜—è©¦å¾ localStorage ç²å– PDF base64 æ•¸æ“š
            const pdfBase64 = localStorage.getItem('pne_floorplan_base64');
            if (pdfBase64) {
                const pdfDataUrl = `data:application/pdf;base64,${pdfBase64}`;
                previewContent.innerHTML = `
                    <h3 style="color: var(--primary, #1e88e5); margin-bottom: 20px;">${file.name}</h3>
                    <iframe src="${pdfDataUrl}" style="width: 100%; height: 600px; border: 1px solid #ddd; border-radius: 8px;" title="${file.name}"></iframe>
                    <p style="margin-top: 15px; color: #666;">å¦‚æœ PDF ç„¡æ³•é¡¯ç¤ºï¼Œ<a href="${pdfDataUrl}" target="_blank" style="color: var(--primary, #1e88e5);">é»æ“Šé€™è£¡ä¸‹è¼‰</a></p>
                    <p style="margin-top: 10px; color: #666;">ä¸Šå‚³æ—¥æœŸ: ${new Date(file.uploadDate).toLocaleDateString()} | å¤§å°: ${file.size}</p>
                `;
            } else {
                previewContent.innerHTML = `
                    <h3 style="color: var(--primary, #1e88e5); margin-bottom: 20px;">${file.name}</h3>
                    <div style="padding: 40px; color: #666;">
                        <i class="fas fa-file-pdf" style="font-size: 48px; margin-bottom: 15px;"></i>
                        <p>PDF æ•¸æ“šä¸å¯ç”¨</p>
                        <p style="font-size: 0.9em;">è·¯å¾‘: ${file.path}</p>
                    </div>
                    <p style="margin-top: 15px; color: #666;">ä¸Šå‚³æ—¥æœŸ: ${new Date(file.uploadDate).toLocaleDateString()} | å¤§å°: ${file.size}</p>
                `;
            }
        } else {
            previewContent.innerHTML = `
                <h3 style="color: var(--primary, #1e88e5); margin-bottom: 20px;">${file.name}</h3>
                <div style="padding: 40px; color: #666;">
                    <i class="fas fa-file-pdf" style="font-size: 48px; margin-bottom: 15px;"></i>
                    <p>PDF æ–‡ä»¶å¼•ç”¨</p>
                    <p style="font-size: 0.9em;">è·¯å¾‘: ${file.path}</p>
                </div>
                <p style="margin-top: 15px; color: #666;">ä¸Šå‚³æ—¥æœŸ: ${new Date(file.uploadDate).toLocaleDateString()} | å¤§å°: ${file.size}</p>
            `;
        }
    }
}

function handleImageError(img) {
    img.style.display = 'none';
    const previewContent = document.getElementById('previewContent');
    if (previewContent) {
        previewContent.innerHTML += '<p style="color: red; margin-top: 15px;">éŒ¯èª¤ï¼šåœ–ç‰‡ç„¡æ³•è¼‰å…¥</p>';
    }
}

// Resize Photo æµ®å‹•é¸å–®æ§åˆ¶
document.addEventListener('DOMContentLoaded', function() {
  const resizePhotoWindow = document.getElementById('resizePhotoWindow');
  const resizePhotoOutputBtn = document.getElementById('resizePhotoOutputBtn');
  const resizePhotoCloseBtn = document.getElementById('resizePhotoCloseBtn');
  const resizePhotoMenuItem = document.querySelector('.pne-dropdown-item[data-action="resizephoto"]');
  const quickSelectPhotoFolderBtn = document.getElementById('quickSelectPhotoFolderBtn');
  const resizePhotoOptions = document.getElementById('resizePhotoOptions');
  const quickResizeOutputBtn = document.getElementById('quickResizeOutputBtn');
  const quickSelectedFolderPath = document.getElementById('quickSelectedFolderPath');
  let quickSelectedFiles = [];
  let quickSelectedFolder = '';

  // æª¢æŸ¥æ˜¯å¦æ”¯æ´ webkitdirectory
  function isWebkitDirectorySupported() {
    const input = document.createElement('input');
    return 'webkitdirectory' in input && !/safari/i.test(navigator.userAgent);
  }

  // é»é¸ä¸‹æ‹‰é¸å–®é¡¯ç¤ºæµ®å‹•é¸å–®
  if (resizePhotoMenuItem && resizePhotoWindow) {
    resizePhotoMenuItem.addEventListener('click', function() {
      // é—œé–‰ä¸‹æ‹‰é¸å–®
      const pneDropdown = document.querySelector('.pne-dropdown');
      if (pneDropdown) {
        pneDropdown.style.display = 'none';
      }
      resizePhotoWindow.style.display = 'block';
      quickSelectedFiles = [];
      quickSelectedFolder = '';
      quickSelectedFolderPath.style.display = 'none';
      quickSelectedFolderPath.textContent = '';
    });
  }
  // é—œé–‰æŒ‰éˆ•
  if (resizePhotoCloseBtn && resizePhotoWindow) {
    resizePhotoCloseBtn.addEventListener('click', function() {
      resizePhotoWindow.style.display = 'none';
      quickSelectedFiles = [];
      quickSelectedFolder = '';
      quickSelectedFolderPath.style.display = 'none';
      quickSelectedFolderPath.textContent = '';
    });
  }
  // é»æ“Šå¤–éƒ¨è‡ªå‹•é—œé–‰
  document.addEventListener('mousedown', function(e) {
    if (resizePhotoWindow.style.display === 'block' && !resizePhotoWindow.contains(e.target) && !resizePhotoMenuItem.contains(e.target)) {
      resizePhotoWindow.style.display = 'none';
      quickSelectedFiles = [];
      quickSelectedFolder = '';
      quickSelectedFolderPath.style.display = 'none';
      quickSelectedFolderPath.textContent = '';
    }
  });
  // é¸æ“‡è³‡æ–™å¤¾
  quickSelectPhotoFolderBtn.addEventListener('click', function() {
    if (!isWebkitDirectorySupported()) {
      showNotification('Your browser does not support folder selection. Please use Chrome/Edge for this feature.', 'error');
      return;
    }
    const input = document.createElement('input');
    input.type = 'file';
    input.webkitdirectory = true;
    input.multiple = true;
    input.accept = 'image/*';
    input.style.display = 'none';
    input.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        quickSelectedFiles = Array.from(e.target.files).filter(file => 
            !file.name.startsWith('._') && 
            /\.(jpe?g|png|gif|bmp|webp)$/i.test(file.name)
        );
        // å–å¾—è³‡æ–™å¤¾è·¯å¾‘
        let folderPath = '';
        if (quickSelectedFiles.length > 0 && quickSelectedFiles[0].webkitRelativePath) {
          folderPath = quickSelectedFiles[0].webkitRelativePath.split('/')[0];
        }
        quickSelectedFolder = folderPath;
        quickSelectedFolderPath.textContent = folderPath ? `Selected: ${folderPath}` : '';
        quickSelectedFolderPath.style.display = folderPath ? 'block' : 'none';
      } else {
        quickSelectedFiles = [];
        quickSelectedFolder = '';
        quickSelectedFolderPath.style.display = 'none';
        quickSelectedFolderPath.textContent = '';
      }
    });
    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
  });
  // Output
  quickResizeOutputBtn.addEventListener('click', async function() {
    if (!quickSelectedFiles || quickSelectedFiles.length === 0) {
      showNotification('No photos selected!', 'error');
      return;
    }
    const size = parseInt(document.querySelector('input[name="resizePhotoSizeQuick"]:checked').value, 10);
    let defaultName = quickSelectedFolder ? quickSelectedFolder : 'Resized_Photos';
    let zipFileHandle = null;
    let useFSAPI = false;
    // å˜—è©¦ File System Access API
    if (window.showSaveFilePicker) {
      try {
        zipFileHandle = await window.showSaveFilePicker({
          suggestedName: `${defaultName}.zip`,
          types: [{description: 'ZIP file', accept: {'application/zip': ['.zip']}}]
        });
        useFSAPI = true;
      } catch (e) {
        // ç”¨æˆ¶å–æ¶ˆ
        return;
      }
    }
    const zip = new JSZip();
    for (const file of quickSelectedFiles) {
      const dataUrl = await resizeImageToSize(file, size);
      const blob = dataURLtoBlob(dataUrl);
      zip.file(file.name, blob);
    }
    const zipContent = await zip.generateAsync({type: "blob"});
    if (useFSAPI && zipFileHandle) {
      const writable = await zipFileHandle.createWritable();
      await writable.write(zipContent);
      await writable.close();
      showNotification('Resized photos exported as zip!', 'success');
    } else {
      saveAs(zipContent, `${defaultName}.zip`);
      showNotification('Resized photos exported as zip!', 'success');
    }
    resizePhotoWindow.style.display = 'none';
    quickSelectedFiles = [];
    quickSelectedFolder = '';
    quickSelectedFolderPath.style.display = 'none';
    quickSelectedFolderPath.textContent = '';
  });
});

// ç›£è½ header Inspection no. æ¬„ä½è®ŠåŒ–ï¼ŒåŠæ™‚åŒæ­¥åˆ°æ‰€æœ‰æ–°å¢èœå–®
const headerInspectionNoInput = document.getElementById('locationId');
if (headerInspectionNoInput) {
    headerInspectionNoInput.addEventListener('input', function() {
        // æª¢æŸ¥é‡è¤‡ä¸¦æ›´æ–°è¦–è¦ºç‹€æ…‹
        const inspectionNo = this.value.trim();
        updateDuplicateStatus(this, inspectionNo);
        
        // é‡ç½®æ¨™ç±¤åˆ†é…æ¨™è¨˜ï¼ˆç”¨æˆ¶æ‰‹å‹•è¼¸å…¥æ™‚ï¼‰
        isHeaderFromLabelAssignment = false;
        
        // Defects æ–°å¢èœå–®åŒæ­¥
        if (defectWindow && defectWindow.style.display !== 'none') {
            // åªæœ‰åœ¨ Assign æŒ‰éˆ•é¡¯ç¤ºæ™‚æ‰åŒæ­¥ï¼ˆå³æ–°å¢æ¨¡å¼ï¼‰
            const defectAssignBtn = document.getElementById('defectAssignBtn');
            if (defectAssignBtn && defectAssignBtn.style.display !== 'none') {
                const defectInspectionNoInput = document.getElementById('defectInspectionNo');
                if (defectInspectionNoInput) {
                    defectInspectionNoInput.value = headerInspectionNoInput.value;
                    // åŒæ™‚æ›´æ–°ç¼ºé™·è¼¸å…¥æ¡†çš„é‡è¤‡ç‹€æ…‹
                    updateDuplicateStatus(defectInspectionNoInput, inspectionNo);
                }
            }
        }
        // Defect Summary ç·¨è¼¯èœå–®åŒæ­¥ï¼ˆåŒä¸€å€‹ defectWindowï¼Œä½† Assign æŒ‰éˆ•é¡¯ç¤ºæ‰ç®—æ–°å¢ï¼‰
        // è‹¥æœªä¾†æœ‰ç¨ç«‹çš„ç·¨è¼¯èœå–®ï¼Œè«‹è£œå……å°æ‡‰ ID
    });
    
    // æ·»åŠ å¤±ç„¦äº‹ä»¶ç›£è½å™¨
    headerInspectionNoInput.addEventListener('blur', function() {
        const inspectionNo = this.value.trim();
        updateDuplicateStatus(this, inspectionNo);
    });
}
// Floor Plan Functionality - Initialize after DOM is loaded
document.addEventListener('DOMContentLoaded', async function() {
    // æª¢æŸ¥PDFæ•¸æ“šç‹€æ…‹
    window.logger.log('DOMContentLoaded - PDF data status check:');
    window.logger.log('pne_floorplan_base64 exists:', !!localStorage.getItem('pne_floorplan_base64'));
    window.logger.log('pne_floorplan_data exists:', !!localStorage.getItem('pne_floorplan_data'));
    window.logger.log('pne_floorplan_filename exists:', !!localStorage.getItem('pne_floorplan_filename'));
    
    // æª¢æŸ¥æ‰€æœ‰localStorageéµ
    window.logger.log('All localStorage keys:', Object.keys(localStorage));
    
    // æª¢æŸ¥PDFå…ƒæ•¸æ“šå…§å®¹
    const pdfData = localStorage.getItem('pne_floorplan_data');
    if (pdfData) {
        try {
            const parsed = JSON.parse(pdfData);
            window.logger.log('PDF metadata:', parsed);
        } catch (e) {
            window.logger.log('Error parsing PDF metadata:', e);
        }
    }
    
    // æ¸…ç†PDFæ•¸æ“šå­˜å„²ï¼Œåªä¿ç•™æ–‡ä»¶å¼•ç”¨
    clearPDFDataFromStorage();
    
    // å†æ¬¡æª¢æŸ¥PDFæ•¸æ“šç‹€æ…‹
    window.logger.log('After clearPDFDataFromStorage - PDF data status check:');
    window.logger.log('pne_floorplan_base64 exists:', !!localStorage.getItem('pne_floorplan_base64'));
    window.logger.log('pne_floorplan_data exists:', !!localStorage.getItem('pne_floorplan_data'));
    window.logger.log('pne_floorplan_filename exists:', !!localStorage.getItem('pne_floorplan_filename'));
    
    // é©—è­‰PDFæ–‡ä»¶å¼•ç”¨
    setTimeout(() => {
        validatePDFFileReference();
    }, 1000);
    const floorPlanOverlay = document.getElementById('floorPlanOverlay');
    const closeFloorPlanBtn = document.getElementById('closeFloorPlanBtn');
    const uploadFloorPlanBtn = document.getElementById('uploadFloorPlanBtn');
    const floorPlanFileInput = document.getElementById('floorPlanFileInput');
    const floorPlanUploadArea = document.getElementById('floorPlanUploadArea');
    const floorPlanViewer = document.getElementById('floorPlanViewer');
    
    // Initialize floor plan overlay with hidden state (z-index approach)
    if (floorPlanOverlay) {
        floorPlanOverlay.style.zIndex = '-3'; // Start hidden behind earth tone background layer
        floorPlanOverlay.style.display = 'flex'; // Keep in DOM but hidden
        console.log('ğŸ” Floor plan initialized with z-index approach behind earth tone background');
    }
    const floorPlanCanvas = document.getElementById('floorPlanCanvas');


    // Load PDF.js
    if (typeof pdfjsLib === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
        document.head.appendChild(script);
        // é…ç½® PDF.js worker
        script.onload = function() {
            if (window.pdfjsLib) {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
        };
    }

    // Close floor plan overlay using z-index (preserves DOM state and prevents photo re-rendering)
    function closeFloorPlan() {
        // Check if user is waiting to place defect mark
        if (window.isWaitingForDefectMarkPlacement) {
            window.logger.log('Cannot close floor plan - user must place defect mark first');
            showNotification('Please place the defect mark before closing the floor plan', 'warning');
            return;
        }
        
        // Hide floor plan by moving it behind the earth tone background layer instead of removing it
        floorPlanOverlay.style.zIndex = '-3';
        floorPlanOverlay.style.display = 'flex'; // Keep it in DOM but hidden behind earth tone background
        
        // Reset Quick Label Switch when closing floor plan
        const quickLabelSwitch = document.getElementById('quickLabelSwitch');
        if (quickLabelSwitch) {
            quickLabelSwitch.checked = false;
            window.logger.log('Quick Label Switch reset to OFF when closing floor plan');
        }
        
        // Reset Quick Label mode states
        const floorPlanViewer = document.getElementById('floorPlanViewer');
        const quickLabelInstruction = document.getElementById('quickLabelInstruction');
        if (floorPlanViewer) {
            floorPlanViewer.style.cursor = 'grab';
        }
        if (quickLabelInstruction) {
            quickLabelInstruction.style.display = 'none';
        }
        // Reset mouse tracking
        mouseTrackingActive = false;
        
        // Reset display states when closing
        const labelsDataReminder = document.getElementById('labelsDataReminder');
        const uploadPlaceholder = document.getElementById('uploadPlaceholder');
        if (labelsDataReminder) labelsDataReminder.style.display = 'none';
        if (uploadPlaceholder) uploadPlaceholder.style.display = 'block';
        
        // Skip photo re-rendering when closing floor plan to preserve photo submission status
        // Photos will maintain their current status without being overwritten
        console.log('ğŸ” Closing floor plan - preserving photo status without re-rendering');
    }

    // Close button event
    if (closeFloorPlanBtn) {
        closeFloorPlanBtn.addEventListener('click', closeFloorPlan);
    }

    // Show floor plan overlay using z-index (preserves DOM state and prevents photo re-rendering)
    function showFloorPlan() {
        floorPlanOverlay.style.zIndex = '1000'; // Bring it to front
        floorPlanOverlay.style.display = 'flex';
        console.log('ğŸ” Showing floor plan - preserving photo status without re-rendering');
    }

    // ESC key event
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && floorPlanOverlay.style.zIndex !== '-3') {
            closeFloorPlan();
        }
    });

    // Double Alt/Command key shortcut to open Drawing mode (cross-platform)
    let altKeyPressCount = 0;
    let altKeyTimer = null;
    let lastCtrlClickTime = 0;
    
    document.addEventListener('keydown', function(e) {
        // Check if Alt key (Windows) or Command key (Mac) is pressed
        const isAltKey = e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey; // Alt key (Windows)
        const isCommandKey = e.metaKey && !e.ctrlKey && !e.altKey && !e.shiftKey; // Mac Command key
        
        // Don't interfere with copy/paste operations (Ctrl+C, Ctrl+V, Cmd+C, Cmd+V)
        if (e.key === 'c' || e.key === 'v' || e.key === 'C' || e.key === 'V') {
            return; // Allow normal copy/paste to work
        }
        
        // Ignore if user is clicking on a photo (photo selection with Ctrl/Cmd)
        const activeElement = document.activeElement;
        const isPhotoClick = activeElement && activeElement.classList.contains('photo-item');
        const timeSinceLastCtrlClick = Date.now() - lastCtrlClickTime;
        
        // If user recently clicked with Ctrl/Cmd on a photo, ignore this keydown event
        if (isPhotoClick || timeSinceLastCtrlClick < 300) {
            return;
        }
        
        if (isAltKey || isCommandKey) {
            altKeyPressCount++;
            
            // Clear any existing timer
            if (altKeyTimer) {
                clearTimeout(altKeyTimer);
            }
            
            // Set a timer to reset the count after 500ms
            altKeyTimer = setTimeout(() => {
                altKeyPressCount = 0;
            }, 500);
            
            // If double click detected (count >= 2)
            if (altKeyPressCount >= 2) {
                e.preventDefault();
                altKeyPressCount = 0;
                
                // Open Drawing mode
                if (floorPlanOverlay.style.zIndex === '-3' || !floorPlanOverlay.style.zIndex) {
                    showFloorPlan();
                    checkLabelsDataAndShowContent();
                    
                    // åˆå§‹åŒ–æ»‘å¡ŠåŠŸèƒ½
                    setTimeout(() => {
                        if (typeof window.initLabelSizeAdjustment === 'function') {
                            window.initLabelSizeAdjustment();
                        }
                        if (typeof window.initDefectMarkSizeAdjustment === 'function') {
                            window.initDefectMarkSizeAdjustment();
                        }
                    }, 100);
                    
                    // Show appropriate notification based on platform
                    const keyName = isCommandKey ? 'Command' : 'Alt';
                    showNotification(`Drawing mode opened (Double ${keyName} key)`, 'info');
                }
            }
        }
    });
    
    // Track Ctrl/Cmd clicks on photos to prevent accidental drawing mode activation
    document.addEventListener('click', function(e) {
        // Check if Ctrl/Cmd is pressed and target is a photo
        if ((e.ctrlKey || e.metaKey) && e.target.closest('.photo-item')) {
            lastCtrlClickTime = Date.now();
            // Reset the alt key press count to prevent accidental drawing mode activation
            altKeyPressCount = 0;
            if (altKeyTimer) {
                clearTimeout(altKeyTimer);
                altKeyTimer = null;
            }
        }
    }, true);

    // Add label shortcut key: Cmd+E (Mac) / Ctrl+E (Windows)
    document.addEventListener('keydown', function(e) {
        // Check if Cmd+E (Mac) or Ctrl+E (Windows) is pressed
        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
        const isCmdE = isMac && e.metaKey && e.key === 'e' && !e.ctrlKey && !e.altKey && !e.shiftKey;
        const isCtrlE = !isMac && e.ctrlKey && e.key === 'e' && !e.metaKey && !e.altKey && !e.shiftKey;
        
        if (isCmdE || isCtrlE) {
            e.preventDefault();
            
            // Check if floor plan is loaded
            if (!floorPlanCanvas) {
                showNotification('Please upload a floor plan first', 'warning');
                return;
            }
            
            // Enter label creation mode
            enterLabelCreationMode();
            
            // Focus on inspection no. input after a short delay
            setTimeout(() => {
                const inputInspectionNo = document.getElementById('labelInspectionNo');
                if (inputInspectionNo) {
                    inputInspectionNo.focus();
                    inputInspectionNo.select(); // Select existing text
                }
            }, 100);
        }
    });

    // Upload button event
    if (uploadFloorPlanBtn) {
        uploadFloorPlanBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent global click handler interference
            window.logger.log('Upload floor plan button clicked in Chrome');
            // Preferred: File System Access API
            if (window.showOpenFilePicker) {
                (async () => {
                    try {
                        const [handle] = await window.showOpenFilePicker({
                            types: [{description: 'PDF', accept: {'application/pdf': ['.pdf']}}]
                        });
                        if (handle) {
                            try { await window.storageAdapter.setItem('pne_pdf_file_handle', handle); } catch (e) {}
                            const file = await handle.getFile();
                            uploadFloorPlanBtn.textContent = 'Loading...';
                            uploadFloorPlanBtn.disabled = true;
                            const arrayBuffer = await file.arrayBuffer();
                            await loadPDFFromArrayBuffer(arrayBuffer, file.name);
                            uploadFloorPlanBtn.textContent = 'Choose File';
                            uploadFloorPlanBtn.disabled = false;
                            floorPlanUploadArea.style.display = 'none';
                            floorPlanViewer.style.display = 'flex';
                        }
                    } catch (err) {
                        // fallback to input
            floorPlanFileInput.click();
                    }
                })();
            } else {
                floorPlanFileInput.click();
            }
        });
    }

    // Label state - ä½¿ç”¨æ–°çš„æ¨™ç±¤å±¤ç³»çµ±
    const labelLayer = document.getElementById('labelLayer');
    const labelModalOverlay = document.getElementById('labelModalOverlay');
    const addLabelBtn = document.getElementById('addLabelBtn');
    const labelCreateBtn = document.getElementById('labelCreateBtn');
    const labelCancelBtn = document.getElementById('labelCancelBtn');
    const inputInspectionNo = document.getElementById('labelInspectionNo');
    const inputFloor = document.getElementById('labelFloor');
    const inputAreaName = document.getElementById('labelAreaName');
    const inputRoomNo = document.getElementById('labelRoomNo');
    const inputInspectionDate = document.getElementById('labelInspectionDate');
    
    // Add real-time validation for duplicate inspection numbers in label creation form
    if (inputInspectionNo) {
        inputInspectionNo.addEventListener('input', function() {
            const inspectionNo = this.value.trim();
            const isDuplicate = updateDuplicateStatus(this, inspectionNo);
            
            // Show warning message if duplicate
            if (isDuplicate) {
                // Remove any existing warning
                const existingWarning = this.parentNode.querySelector('.duplicate-warning');
                if (existingWarning) {
                    existingWarning.remove();
                }
                
                // Add warning message after the input element
                const warning = document.createElement('div');
                warning.className = 'duplicate-warning';
                warning.style.color = '#ff0000';
                warning.style.fontSize = '12px';
                warning.style.marginTop = '4px';
                warning.style.marginBottom = '8px';
                warning.textContent = 'This inspection number already exists. Please use a different number.';
                
                // Insert the warning after the input element
                this.parentNode.insertBefore(warning, this.nextSibling);
            } else {
                // Remove warning if not duplicate
                const existingWarning = this.parentNode.querySelector('.duplicate-warning');
                if (existingWarning) {
                    existingWarning.remove();
                }
            }
        });
    }

    // ç‚ºæª¢æŸ¥æ—¥æœŸè¼¸å…¥æ¡†æ·»åŠ äº‹ä»¶ç›£è½å™¨ï¼Œä»¥ä¾¿æ›´æ–°"Assign to New Record"æŒ‰éˆ•ç‹€æ…‹
    if (inputInspectionDate) {
        inputInspectionDate.addEventListener('input', function() {
            updateAssignButtonState();
        });
    }
    
    // ç‚ºæ¨™ç±¤æª¢æŸ¥è™Ÿç¢¼è¼¸å…¥æ¡†æ·»åŠ é‡è¤‡æª¢æŸ¥
    if (inputInspectionNo) {
        inputInspectionNo.addEventListener('input', function() {
            const inspectionNo = this.value.trim();
            updateDuplicateStatus(this, inspectionNo);
        });
        
        inputInspectionNo.addEventListener('blur', function() {
            const inspectionNo = this.value.trim();
            updateDuplicateStatus(this, inspectionNo);
        });
    }

    // è¨­ç½®ç‚ºå…¨å±€è®Šæ•¸ï¼Œä»¥ä¾¿æ»‘å¡ŠåŠŸèƒ½å¯ä»¥è¨ªå•
    window.labels = []; // {id, x, y, inspectionNo, floor, areaName, roomNo, inspectionDate}
    window.defectMarks = []; // {id, x, y, defectNo, recordDate, photoNo, canvasPosition}
    window.isWaitingForDefectMarkPlacement = false; // Track if user needs to place defect mark
    const LABELS_LS_KEY = 'pne_floorplan_labels';
    const DEFECT_MARKS_LS_KEY = 'pne_floorplan_defect_marks';
    const VIEW_LS_KEY = 'pne_floorplan_view';
    let labelViewState = { scale: 1, tx: 0, ty: 0 };
    
    // å‡½æ•¸è²æ˜ - è§£æ±ºå‡½æ•¸æå‡å•é¡Œ
    // é€™äº›å‡½æ•¸å°‡åœ¨å¾Œé¢å®šç¾©ï¼Œä½¿ç”¨ var è²æ˜ä¾†é¿å…æå‡å•é¡Œ
    var loadLabelsFromStorage, loadDefectMarksFromStorage, redrawLabels, redrawDefectMarks;
    var initLabelSizeAdjustment, initDefectMarkSizeAdjustment, setupZoomAndPanEvents;
    
    
    
    
    // è¼‰å…¥æ¨™ç±¤æ•¸æ“šåŠŸèƒ½
    loadLabelsFromStorage = async function() {
        try {
            const parsed = await window.storageAdapter.getItem(LABELS_LS_KEY);
            window.logger.log('Raw labels data from storage:', parsed);
            if (!parsed) {
                window.logger.log('No labels data found in storage');
                return;
            }
            window.logger.log('Parsed labels data:', parsed);
            if (Array.isArray(parsed)) {
                window.labels = parsed;
                window.logger.log('Labels array updated:', window.labels);
            } else {
                window.logger.log('Parsed data is not an array:', typeof parsed);
            }
        } catch(error) {
            window.logger.error('Error loading labels from storage:', error);
        }
    };
    
    // è¼‰å…¥ç¼ºé™·æ¨™è¨˜æ•¸æ“šåŠŸèƒ½
    loadDefectMarksFromStorage = async function() {
        try {
            window.logger.log('loadDefectMarksFromStorage called, skipDefectMarksLoad:', window.skipDefectMarksLoad);
            
            // æª¢æŸ¥æ˜¯å¦æ‡‰è©²è·³éè¼‰å…¥ï¼ˆé é¢é‡æ–°è¼‰å…¥æ™‚ï¼‰
            if (window.skipDefectMarksLoad) {
                window.logger.log('Skipping defect marks load due to skipDefectMarksLoad flag');
                window.defectMarks = [];
                return;
            }
            
            const parsed = await window.storageAdapter.getItem(DEFECT_MARKS_LS_KEY);
            window.logger.log('Raw defect marks data from storage:', parsed);
            if (!parsed) {
                window.logger.log('No defect marks data found in storage');
                window.defectMarks = [];
                return;
            }
            window.logger.log('Parsed defect marks data:', parsed);
            if (Array.isArray(parsed)) {
                window.defectMarks = parsed;
                window.logger.log('Defect marks array updated with', window.defectMarks.length, 'defect marks');
            } else {
                window.logger.log('Parsed defect marks data is not an array:', typeof parsed);
            }
        } catch(error) {
            window.logger.error('Error loading defect marks from storage:', error);
        }
    };
    
    // ç¼ºé™·æ¨™è¨˜å¤§å°ç®¡ç† - ä½¿ç”¨å…¨å±€è®Šé‡
    window.defectMarkSizeScale = window.defectMarkSizeScale || 24; // é»˜èªå¤§å° 24px
    const DEFECT_MARK_SIZE_LS_KEY = 'pne_floorplan_defect_mark_size';
    const deviceScale = window.devicePixelRatio || 1;
    
    // ç°¡åŒ–çš„è®Šæ›ç‹€æ…‹ - ä½¿ç”¨å…¨å±€è®Šé‡
    // ä½¿ç”¨å…¨å±€è®Šé‡ window.currentScale, window.translateX, window.translateY
    window.baseScale = window.baseScale || 1.0;
    
    // æ¨™ç±¤å¤§å°èª¿æ•´ç‹€æ…‹ - ä½¿ç”¨å…¨å±€è®Šé‡
    window.labelSizeScale = window.labelSizeScale || 24; // é»˜èª24px

    window.saveLabelsToStorage = async function() {
        try { 
            await window.storageAdapter.setItem(LABELS_LS_KEY, window.labels); 
            window.logger.log('Labels saved to storage:', window.labels);
        } catch(error) { 
            window.logger.error('Error saving labels to storage:', error);
        }
    };
    window.saveDefectMarksToStorage = async function() {
        try { 
            await window.storageAdapter.setItem(DEFECT_MARKS_LS_KEY, window.defectMarks); 
            window.logger.log('Defect marks saved to storage:', window.defectMarks);
        } catch(error) { 
            window.logger.error('Error saving defect marks to storage:', error);
        }
    };
    
    function saveDefectMarkSizeToLocalStorage() {
        try { 
            localStorage.setItem(DEFECT_MARK_SIZE_LS_KEY, defectMarkSizeScale.toString()); 
            window.logger.log('Defect mark size saved to storage:', defectMarkSizeScale);
        } catch(error) { 
            window.logger.error('Error saving defect mark size to storage:', error);
        }
    }
    
    function loadDefectMarkSizeFromLocalStorage() {
        try {
            const raw = localStorage.getItem(DEFECT_MARK_SIZE_LS_KEY);
            if (!raw) return;
            const parsed = parseInt(raw);
            if (!isNaN(parsed) && parsed >= 5 && parsed <= 60) {
                defectMarkSizeScale = parsed;
            }
        } catch(_) {}
    }
    function saveViewStateToLocalStorage() {
        try { localStorage.setItem(VIEW_LS_KEY, JSON.stringify(labelViewState)); } catch(_) {}
    }
    
    // ä¿å­˜ç•¶å‰è¦–åœ–ç‹€æ…‹ï¼ˆåŒ…å«å®Œæ•´çš„è¦–åœ–ä¿¡æ¯ï¼‰
    function saveCurrentViewState(filename = null) {
        try {
            // å„ªå…ˆä½¿ç”¨å‚³å…¥çš„æ–‡ä»¶åï¼Œå¦å‰‡å¾ localStorage ç²å–
            const currentFilename = filename || localStorage.getItem('pne_floorplan_filename');
            window.logger.log('saveCurrentViewState called. currentFilename:', currentFilename, 'currentScale:', window.currentScale || 1, 'translateX:', window.translateX || 0, 'translateY:', window.translateY || 0);
            
            if (currentFilename) {
                const viewState = {
                    scale: window.currentScale || 1.0,
                    translateX: window.translateX || 0,
                    translateY: window.translateY || 0,
                    baseScale: baseScale || 1.0,
                    labelSizeScale: labelSizeScale || 24,
                    defectMarkSizeScale: defectMarkSizeScale || 24,
                    filename: currentFilename,
                    timestamp: Date.now()
                };
                
                // ä¿å­˜åˆ° localStorageï¼Œä½¿ç”¨æ–‡ä»¶åä½œç‚ºéµçš„ä¸€éƒ¨åˆ†
                const viewStateKey = `pne_view_state_${currentFilename.replace(/[^a-zA-Z0-9]/g, '_')}`;
                localStorage.setItem(viewStateKey, JSON.stringify(viewState));
                window.logger.log('View state saved to localStorage with key:', viewStateKey, 'value:', viewState);
                
                // åŒæ™‚æ›´æ–° labelViewState
                if (typeof labelViewState !== 'undefined') {
                    labelViewState = {
                        scale: viewState.scale,
                        tx: viewState.translateX,
                        ty: viewState.translateY
                    };
                    saveViewStateToLocalStorage();
                    window.logger.log('labelViewState updated:', labelViewState);
                }
                
                window.logger.log('Current view state saved successfully:', viewState);
            } else {
                window.logger.log('No current filename found, cannot save view state');
            }
        } catch (error) {
            window.logger.error('Error saving current view state:', error);
        }
    }
    
    // èª¿è©¦å‡½æ•¸ï¼šåˆ—å‡ºæ‰€æœ‰ä¿å­˜çš„è¦–åœ–ç‹€æ…‹
    function listAllViewStates() {
        window.logger.log('=== All View States in localStorage ===');
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && (key.startsWith('pne_view_state_') || key === 'pne_floorplan_filename' || key === 'labelViewState')) {
                const value = localStorage.getItem(key);
                window.logger.log(`${key}:`, value);
            }
        }
        window.logger.log('=== End of View States ===');
    }
    
    // å°‡èª¿è©¦å‡½æ•¸æ·»åŠ åˆ°å…¨å±€ä½œç”¨åŸŸ
    window.listAllViewStates = listAllViewStates;
    
    // æ‰‹å‹•è§¸ç™¼è¦–åœ–ç‹€æ…‹æ¢å¾©çš„æ¸¬è©¦å‡½æ•¸
    window.testViewStateRestore = function() {
        window.logger.log('=== Testing View State Restore ===');
        const currentFilename = localStorage.getItem('pne_floorplan_filename');
        window.logger.log('Current filename:', currentFilename);
        
        if (currentFilename) {
            const viewStateKey = `pne_view_state_${currentFilename.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const savedViewState = localStorage.getItem(viewStateKey);
            window.logger.log('Saved view state key:', viewStateKey);
            window.logger.log('Saved view state:', savedViewState);
            
            if (savedViewState) {
                try {
                    const viewState = JSON.parse(savedViewState);
                    window.logger.log('Parsed view state:', viewState);
                    
                    // æ‡‰ç”¨è¦–åœ–ç‹€æ…‹
                    // ä½¿ç”¨å…¨å±€è®Šé‡
                    window.currentScale = viewState.scale || 1.0;
                    window.translateX = viewState.translateX || 0;
                    window.translateY = viewState.translateY || 0;
                        
                    if (typeof applyTransform === 'function') {
                        applyTransform();
                        window.logger.log('View state applied manually');
                    }
                } catch (error) {
                    window.logger.error('Error parsing view state:', error);
                }
            } else {
                window.logger.log('No saved view state found');
            }
        } else {
            window.logger.log('No current filename found');
        }
        window.logger.log('=== End Test ===');
    };
    
    function loadViewStateFromLocalStorage() {
        try {
            const raw = localStorage.getItem(VIEW_LS_KEY);
            if (!raw) return;
            const parsed = JSON.parse(raw);
            if (parsed && typeof parsed === 'object') {
                const sc = Number(parsed.scale);
                const tx = Number(parsed.tx);
                const ty = Number(parsed.ty);
                if (!Number.isNaN(sc) && !Number.isNaN(tx) && !Number.isNaN(ty)) {
                    labelViewState = { scale: sc, tx, ty };
                    // åŒæ­¥å…¨åŸŸè®Šæ•¸
                    window.currentScale = sc;
                    window.translateX = tx;
                    window.translateY = ty;
                }
            }
        } catch(_) {}
    }
    let editingLabelId = null;

    // æ›´æ–°"Assign to New Record"æŒ‰éˆ•ç‹€æ…‹çš„å‡½æ•¸
    function updateAssignButtonState() {
        const assignBtn = document.getElementById('assignToNewRecordBtn');
        if (!assignBtn) return;
        
        // æª¢æŸ¥æª¢æŸ¥æ—¥æœŸå­—æ®µæ˜¯å¦å¯è¦‹ï¼ˆåªåœ¨ç·¨è¼¯æ¨¡å¼ä¸‹å¯è¦‹ï¼‰
        const inspectionDateField = document.getElementById('inspectionDateField');
        const isInspectionDateVisible = inspectionDateField && inspectionDateField.style.display !== 'none';
        
        if (!isInspectionDateVisible) {
            // å¦‚æœæª¢æŸ¥æ—¥æœŸå­—æ®µä¸å¯è¦‹ï¼Œç¦ç”¨æŒ‰éˆ•
            assignBtn.disabled = true;
            assignBtn.title = 'Inspection date field is required for this function';
            assignBtn.textContent = 'Assign to New Record';
            return;
        }
        
        const inspectionDate = inputInspectionDate ? inputInspectionDate.value.trim() : '';
        const hasInspectionDate = inspectionDate.length > 0;
        
        // ç§»é™¤å°assignedToRecordçš„æª¢æŸ¥ - å·²åˆ†é…æ¨™ç±¤ä¸å†è®Šè—è‰²
        // const isAlreadyAssigned = editingLabelId && window.labels.find(label => label.id === editingLabelId)?.assignedToRecord;
        
        // åªæª¢æŸ¥æ˜¯å¦å·²æäº¤
        const isSubmitted = editingLabelId && window.labels.find(label => label.id === editingLabelId)?.submitted;
        
        if (isSubmitted) {
            // å¦‚æœæ¨™ç±¤å·²ç¶“è¢«æäº¤ï¼Œç¦ç”¨æŒ‰éˆ•ä¸¦é¡¯ç¤ºç›¸æ‡‰æç¤º
            assignBtn.disabled = true;
            assignBtn.title = 'This label is already assigned to a record';
            assignBtn.textContent = 'Already Assigned';
        } else if (hasInspectionDate) {
            // å¦‚æœæœ‰æª¢æŸ¥æ—¥æœŸä¸”æœªåˆ†é…ï¼Œå•Ÿç”¨æŒ‰éˆ•
            assignBtn.disabled = false;
            assignBtn.title = 'Click to save and assign this label to new record';
            assignBtn.textContent = 'Save and Assign to New Record';
        } else {
            // å¦‚æœæ²’æœ‰æª¢æŸ¥æ—¥æœŸï¼Œç¦ç”¨æŒ‰éˆ•
            assignBtn.disabled = true;
            assignBtn.title = 'Please enter inspection date to enable this function';
            assignBtn.textContent = 'Save and Assign to New Record';
        }
    }

    function openLabelModal(prefill) {
        if (!labelModalOverlay) return;
        
        // æ›´æ–°æ¨¡æ…‹æ¡†æ¨™é¡Œ
        const modalTitle = document.querySelector('.label-modal h4');
        if (modalTitle) {
            modalTitle.textContent = prefill ? 'Edit Label' : 'New Label';
        }
        
        // Show the modal first
        labelModalOverlay.style.display = 'flex';
        
        // Auto number functionality removed
        
        // æ›´æ–°æŒ‰éˆ•æ–‡å­—å’Œç‹€æ…‹
        const createBtn = document.getElementById('labelCreateBtn');
        if (createBtn) {
            if (prefill) {
                // æª¢æŸ¥æ¨™ç±¤æ˜¯å¦å·²æäº¤ï¼ˆäº®è—è‰²ç‹€æ…‹ï¼‰
                const currentLabel = window.labels.find(label => label.id === editingLabelId);
                const isSubmitted = currentLabel?.submitted;
                
                if (isSubmitted) {
                    createBtn.textContent = 'Already Assigned';
                    createBtn.disabled = true;
                    createBtn.title = 'This label is already assigned/submitted and cannot be modified';
                } else {
                    createBtn.textContent = 'Save';
                    createBtn.disabled = false;
                    createBtn.title = 'Save changes to this label';
                }
            } else {
                createBtn.textContent = 'Create';
                createBtn.disabled = false;
                createBtn.title = 'Create new label';
            }
        }
        
        // è™•ç†"Assign to New Record"æŒ‰éˆ•çš„é¡¯ç¤ºå’Œç‹€æ…‹
        const assignBtn = document.getElementById('assignToNewRecordBtn');
        if (assignBtn) {
            if (prefill) {
                // ç·¨è¼¯æ¨¡å¼ä¸‹é¡¯ç¤ºæŒ‰éˆ•
                assignBtn.style.display = 'inline-block';
                
                // æª¢æŸ¥æ¨™ç±¤æ˜¯å¦å·²æäº¤ï¼ˆäº®è—è‰²ç‹€æ…‹ï¼‰
                const currentLabel = window.labels.find(label => label.id === editingLabelId);
                const isSubmitted = currentLabel?.submitted;
                
                if (isSubmitted) {
                    // å¦‚æœæ¨™ç±¤å·²ç¶“è¢«åˆ†é…æˆ–æäº¤ï¼Œç¦ç”¨æŒ‰éˆ•
                    assignBtn.disabled = true;
                    assignBtn.title = 'This label is already assigned/submitted and cannot be reassigned';
                    assignBtn.textContent = 'Already Assigned';
                } else {
                // æ ¹æ“šæª¢æŸ¥æ—¥æœŸè¨­ç½®æŒ‰éˆ•ç‹€æ…‹
                updateAssignButtonState();
                }
            } else {
                // å‰µå»ºæ¨¡å¼ä¸‹éš±è—æŒ‰éˆ•
                assignBtn.style.display = 'none';
            }
        }
        
        // è™•ç†æª¢æŸ¥æ—¥æœŸå­—æ®µçš„é¡¯ç¤º/éš±è—
        const inspectionDateField = document.getElementById('inspectionDateField');
        if (inspectionDateField) {
            if (prefill) {
                // ç·¨è¼¯æ¨¡å¼ä¸‹é¡¯ç¤ºæª¢æŸ¥æ—¥æœŸå­—æ®µ
                inspectionDateField.style.display = 'block';
                // å•Ÿç”¨æª¢æŸ¥æ—¥æœŸè¼¸å…¥æ¡†
                if (inputInspectionDate) {
                    inputInspectionDate.disabled = false;
                }
            } else {
                // å‰µå»ºæ¨¡å¼ä¸‹éš±è—æª¢æŸ¥æ—¥æœŸå­—æ®µ
                inspectionDateField.style.display = 'none';
                // ç¦ç”¨ä¸¦æ¸…ç©ºæª¢æŸ¥æ—¥æœŸè¼¸å…¥æ¡†
                if (inputInspectionDate) {
                    inputInspectionDate.disabled = true;
                    inputInspectionDate.value = '';
                }
            }
        }
        
        // è™•ç†å¯é¸å­—æ®µï¼ˆfloorã€area nameã€room no.ï¼‰çš„é¡¯ç¤º/éš±è—
        const floorField = document.getElementById('floorField');
        const areaNameField = document.getElementById('areaNameField');
        const roomNoField = document.getElementById('roomNoField');
        
        if (floorField && areaNameField && roomNoField) {
            if (prefill) {
                // ç·¨è¼¯æ¨¡å¼ä¸‹é¡¯ç¤ºé€™äº›å­—æ®µ
                floorField.classList.remove('hidden');
                areaNameField.classList.remove('hidden');
                roomNoField.classList.remove('hidden');
            } else {
                // å‰µå»ºæ¨¡å¼ä¸‹éš±è—é€™äº›å­—æ®µ
                floorField.classList.add('hidden');
                areaNameField.classList.add('hidden');
                roomNoField.classList.add('hidden');
            }
        }
        
        // æ·»åŠ æˆ–ç§»é™¤ç·¨è¼¯æ¨¡å¼çš„æç¤ºä¿¡æ¯å’Œæ¨£å¼
        let infoText = document.querySelector('.label-modal .edit-info');
        const labelModal = document.querySelector('.label-modal');
        
        if (prefill && !infoText) {
            // æ·»åŠ ç·¨è¼¯æ¨¡å¼æç¤º
            infoText = document.createElement('div');
            infoText.className = 'edit-info';
            infoText.textContent = `Editing label: ${prefill.inspectionNo || 'Label'} (ID: ${prefill.id})`;
            
            const labelForm = document.querySelector('.label-modal .label-form');
            if (labelForm) {
                labelForm.parentNode.insertBefore(infoText, labelForm);
            }
            
            // æ·»åŠ ç·¨è¼¯æ¨¡å¼CSSé¡
            if (labelModal) {
                labelModal.classList.add('editing');
            }
        } else if (!prefill && infoText) {
            // ç§»é™¤ç·¨è¼¯æ¨¡å¼æç¤º
            infoText.remove();
            
            // ç§»é™¤ç·¨è¼¯æ¨¡å¼CSSé¡
            if (labelModal) {
                labelModal.classList.remove('editing');
            }
        }
        
        if (prefill) {
            inputInspectionNo.value = prefill.inspectionNo || '';
            inputFloor.value = prefill.floor || '';
            inputAreaName.value = prefill.areaName || '';
            inputRoomNo.value = prefill.roomNo || '';
            inputInspectionDate.value = prefill.inspectionDate || '';
            
            // åœ¨è¨­ç½®å€¼å¾Œæ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            updateAssignButtonState();
        } else {
            inputInspectionNo.value = '';
            inputFloor.value = '';
            inputAreaName.value = '';
            inputRoomNo.value = '';
            inputInspectionDate.value = '';
        }
    }
    
    

    function closeLabelModal() {
        if (labelModalOverlay) labelModalOverlay.style.display = 'none';
        editingLabelId = null;
        
        // é‡ç½®æ¨¡æ…‹æ¡†æ¨™é¡Œå’ŒæŒ‰éˆ•æ–‡å­—
        const modalTitle = document.querySelector('.label-modal h4');
        if (modalTitle) {
            modalTitle.textContent = 'New Label';
        }
        
        // Reset input field state
        inputInspectionNo.value = '';
        inputInspectionNo.disabled = false;
        inputInspectionNo.style.backgroundColor = '';
        
        // é‡ç½®å¯é¸å­—æ®µçš„ç‹€æ…‹
        const floorField = document.getElementById('floorField');
        const areaNameField = document.getElementById('areaNameField');
        const roomNoField = document.getElementById('roomNoField');
        
        if (floorField && areaNameField && roomNoField) {
            // éš±è—é€™äº›å­—æ®µï¼ˆå‰µå»ºæ¨¡å¼ï¼‰
            floorField.classList.add('hidden');
            areaNameField.classList.add('hidden');
            roomNoField.classList.add('hidden');
        }
        
        const createBtn = document.getElementById('labelCreateBtn');
        if (createBtn) {
            createBtn.textContent = 'Create';
            // é‡ç½®æŒ‰éˆ•çš„ onclick äº‹ä»¶
            createBtn.onclick = null;
        }
        
        // éš±è—"Assign to New Record"æŒ‰éˆ•
        const assignBtn = document.getElementById('assignToNewRecordBtn');
        if (assignBtn) {
            assignBtn.style.display = 'none';
        }
        
        // ç§»é™¤ç·¨è¼¯æ¨¡å¼æç¤ºä¿¡æ¯å’Œæ¨£å¼
        const infoText = document.querySelector('.label-modal .edit-info');
        if (infoText) {
            infoText.remove();
        }
        
        const labelModal = document.querySelector('.label-modal');
        if (labelModal) {
            labelModal.classList.remove('editing');
        }
        
        // å¦‚æœæ­£åœ¨å‰µå»ºæ¨¡å¼ä¸‹ï¼Œé€€å‡ºå‰µå»ºæ¨¡å¼
        if (isLabelCreationMode) {
            exitLabelCreationMode();
        }
    }
    

    // æ–°çš„æ¨™ç±¤æ¸²æŸ“ç³»çµ± - ä½¿ç”¨DOMå…ƒç´ è€Œécanvas
    window.redrawLabels = function() {
        if (!labelLayer) return;
        
        // ä½¿ç”¨ window.labels è€Œä¸æ˜¯å±€éƒ¨è®Šé‡ labels
        const labelsArray = window.labels || [];
        
        // èª¿è©¦æ—¥èªŒï¼šåƒ…åœ¨é–‹ç™¼ç’°å¢ƒä¸‹è¼¸å‡º
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.logger.log('redrawLabels called. Current labels count:', labelsArray.length);
        }
        
        // æ¸…é™¤æ‰€æœ‰ç¾æœ‰æ¨™ç±¤ï¼ˆä½†ä¿ç•™ç¼ºé™·æ¨™è¨˜ï¼‰
        const labelElements = labelLayer.querySelectorAll('.floor-plan-label');
        labelElements.forEach(element => element.remove());
        // èª¿è©¦æ—¥èªŒï¼šåƒ…åœ¨é–‹ç™¼ç’°å¢ƒä¸‹è¼¸å‡º
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.logger.log('Cleared existing labels from labelLayer');
        }
        
        // ç‚ºæ¯å€‹æ¨™ç±¤å‰µå»ºDOMå…ƒç´ 
        labelsArray.forEach(label => {
            createLabelElement(label);
        });
        
        // æ›´æ–°æ‰€æœ‰æ¨™ç±¤ä½ç½®
        if (typeof window.updateAllLabelPositions === 'function') {
            window.updateAllLabelPositions();
        }
        
        // èª¿è©¦æ—¥èªŒï¼šåƒ…åœ¨é–‹ç™¼ç’°å¢ƒä¸‹è¼¸å‡º
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.logger.log('redrawLabels completed');
        }
    }
    
    // æ›´æ–°æ‰€æœ‰ç¼ºé™·æ¨™è¨˜ä½ç½®
    window.updateAllDefectMarkPositions = function() {
        if (!labelLayer) return;
        
        // ç²å–æ‰€æœ‰ç¼ºé™·æ¨™è¨˜å…ƒç´ 
        const dotElements = labelLayer.querySelectorAll('.defect-mark-dot');
        
        // èª¿è©¦æ—¥èªŒï¼šåƒ…åœ¨é–‹ç™¼ç’°å¢ƒä¸‹è¼¸å‡º
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.logger.log('updateAllDefectMarkPositions called. Found dot elements:', dotElements.length);
        }
        
        dotElements.forEach(dotElement => {
            const defectMarkId = dotElement.dataset.defectMarkId;
            const defectMarkData = window.defectMarks.find(d => d.id == defectMarkId);
            
            if (defectMarkData) {
                const textboxElement = labelLayer.querySelector(`.defect-mark-textbox[data-defect-mark-id="${defectMarkId}"]`);
                const connectionElement = labelLayer.querySelector(`.defect-mark-connection[data-defect-mark-id="${defectMarkId}"]`);
                
                window.logger.log('Found elements for defect mark:', defectMarkId, {
                    textbox: !!textboxElement,
                    connection: !!connectionElement
                });
                
                if (textboxElement && connectionElement) {
                    updateDefectMarkPosition(dotElement, textboxElement, connectionElement, defectMarkData);
                }
            }
        });
    };
    
    // ç¼ºé™·æ¨™è¨˜æ¸²æŸ“ç³»çµ±
    window.redrawDefectMarks = function() {
        if (!labelLayer) {
            window.logger.log('redrawDefectMarks: labelLayer not found');
            return;
        }
        
        window.logger.log('redrawDefectMarks called. Current defect marks count:', window.defectMarks ? window.defectMarks.length : 'defectMarks is undefined');
        window.logger.log('Defect marks data:', window.defectMarks);
        
        // æ¸…é™¤æ‰€æœ‰ç¾æœ‰ç¼ºé™·æ¨™è¨˜ï¼ˆä½†ä¿ç•™æ¨™ç±¤ï¼‰
        const defectMarkElements = labelLayer.querySelectorAll('.defect-mark-dot, .defect-mark-textbox, .defect-mark-connection');
        defectMarkElements.forEach(element => element.remove());
        // èª¿è©¦æ—¥èªŒï¼šåƒ…åœ¨é–‹ç™¼ç’°å¢ƒä¸‹è¼¸å‡º
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.logger.log('Cleared existing defect marks from labelLayer');
        }
        
        // ç‚ºæ¯å€‹ç¼ºé™·æ¨™è¨˜å‰µå»ºDOMå…ƒç´ 
        if (window.defectMarks && window.defectMarks.length > 0) {
        window.defectMarks.forEach(defectMark => {
                window.logger.log('Creating defect mark element for:', defectMark.id);
            createDefectMarkElement(defectMark);
        });
        } else {
            window.logger.log('No defect marks to render');
        }
        
        // æ›´æ–°æ‰€æœ‰ç¼ºé™·æ¨™è¨˜ä½ç½®
        updateAllDefectMarkPositions();
        
        // åŒæ™‚æ›´æ–°æ¨™ç±¤ä½ç½®ä»¥ç¢ºä¿åŒæ­¥
if (typeof window.updateAllLabelPositions === 'function') {
        window.updateAllLabelPositions();
    }
        
        // èª¿è©¦æ—¥èªŒï¼šåƒ…åœ¨é–‹ç™¼ç’°å¢ƒä¸‹è¼¸å‡º
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.logger.log('redrawDefectMarks completed');
        }
    };
    
                function createLabelElement(labelData) {
        const labelElement = document.createElement('div');
        labelElement.className = 'floor-plan-label';
        
        // ç§»é™¤assignedé¡çš„æ·»åŠ  - å·²åˆ†é…æ¨™ç±¤ä¸å†è®Šè—è‰²
        // if (labelData.assignedToRecord) {
        //     labelElement.classList.add('assigned');
        // }
        
        // æª¢æŸ¥æ¨™ç±¤æ˜¯å¦å·²æäº¤ï¼Œå¦‚æœæ˜¯å‰‡æ·»åŠ submittedé¡ï¼ˆè—è‰²ï¼‰
        if (labelData.submitted) {
            labelElement.classList.add('submitted');
        }
        
        // è¨­ç½®æ¨™ç±¤æ–‡å­—å…§å®¹ - åªé¡¯ç¤ºæª¢æŸ¥ç·¨è™Ÿï¼Œä¸é¡¯ç¤ºæ—¥æœŸ
        let labelText = labelData.inspectionNo || `æ¨™ç±¤ ${labelData.id}`;
        
        // ç§»é™¤æ—¥æœŸé¡¯ç¤ºé‚è¼¯ - æ ¹æ“šç”¨æˆ¶è¦æ±‚ï¼Œæ¨™ç±¤åªé¡¯ç¤ºæª¢æŸ¥ç·¨è™Ÿ
        // ä¸å†æ ¹æ“š assignedToRecord æˆ– submitted ç‹€æ…‹ä¾†æ±ºå®šæ˜¯å¦é¡¯ç¤ºæ—¥æœŸ
        labelElement.textContent = labelText;
        labelElement.dataset.labelId = labelData.id;
        
        // è¨­ç½®åŸºç¤å­—é«”å¤§å°
        const baseFontSize = labelData.baseFontSize || labelSizeScale;
        labelElement.style.fontSize = baseFontSize + 'px';
        
        // è¨­ç½®åˆå§‹paddingå€¼
        labelElement.style.padding = '8px 12px';
        
        // ç¢ºä¿æ¨™ç±¤å¯ä»¥æ¥æ”¶é¼ æ¨™äº‹ä»¶
        labelElement.style.pointerEvents = 'auto';
        labelElement.style.zIndex = '1000';
        
        // èª¿è©¦æ—¥èªŒï¼šåƒ…åœ¨é–‹ç™¼ç’°å¢ƒä¸‹è¼¸å‡º
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.logger.log('Label element created with pointer-events:', labelElement.style.pointerEvents);
            window.logger.log('Label element z-index:', labelElement.style.zIndex);
        }
        
        // åˆå§‹ä½ç½®å°‡ç”±updateAllLabelPositionså‡½æ•¸è¨­ç½®
        labelElement.style.left = '0px';
        labelElement.style.top = '0px';
        
        // æ·»åŠ äº‹ä»¶ç›£è½å™¨
        setupLabelEvents(labelElement, labelData);
        
        labelLayer.appendChild(labelElement);
        
        // ç«‹å³æ›´æ–°ä½ç½®
        updateSingleLabelPosition(labelElement, labelData);
        
        return labelElement;
    }
    
    // å‰µå»ºç¼ºé™·æ¨™è¨˜å…ƒç´ 
    function createDefectMarkElement(defectMarkData) {
        // å‰µå»ºç´…è‰²åœ“é»
        const dotElement = document.createElement('div');
        dotElement.className = 'defect-mark-dot';
        dotElement.textContent = defectMarkData.defectNo;
        dotElement.dataset.defectMarkId = defectMarkData.id;
        
        // è¨­ç½®åœ“é»å¤§å°ï¼ˆåŸºç¤å¤§å°ï¼Œç¸®æ”¾æœƒåœ¨ updateDefectMarkPosition ä¸­è™•ç†ï¼‰
        const size = window.defectMarkSizeScale || 24;
        const scaledSize = size * (window.currentScale || 1);
        dotElement.style.width = scaledSize + 'px';
        dotElement.style.height = scaledSize + 'px';
        dotElement.style.fontSize = Math.max(8, scaledSize * 0.5) + 'px'; // å­—é«”å¤§å°ç‚ºç¸®æ”¾å¾Œåœ“é»å¤§å°çš„50%ï¼Œæœ€å°8px
        dotElement.style.borderRadius = (scaledSize / 2) + 'px'; // ç¢ºä¿åœ“é»ä¿æŒåœ“å½¢
        dotElement.style.display = 'flex';
        dotElement.style.alignItems = 'center';
        dotElement.style.justifyContent = 'center';
        
        // å‰µå»ºæ–‡å­—æ¡†
        const textboxElement = document.createElement('div');
        textboxElement.className = 'defect-mark-textbox';
        textboxElement.textContent = 'Photo no.: ' + defectMarkData.photoNo;
        textboxElement.dataset.defectMarkId = defectMarkData.id;
        
        // è¨­ç½®æ–‡å­—æ¡†å¤§å°ï¼ˆåŸºç¤å¤§å°ï¼Œç¸®æ”¾æœƒåœ¨ updateDefectMarkPosition ä¸­è™•ç†ï¼‰
        const fontSize = Math.max(8, scaledSize * 0.4) + 'px'; // å­—é«”å¤§å°ç‚ºç¸®æ”¾å¾Œåœ“é»å¤§å°çš„40%ï¼Œæœ€å°8px
        textboxElement.style.fontSize = fontSize;
        
        // è¨­ç½®å›ºå®šçš„ padding å’Œ border-radiusï¼Œä¸éš¨ç¸®æ”¾è®ŠåŒ–
        textboxElement.style.padding = '5px';
        textboxElement.style.borderRadius = '4px';
        
        // è¨­ç½®æ–‡å­—æ¡†ç‚ºè‡ªå‹•èª¿æ•´å¤§å°ï¼Œä¿æŒ 5px é‚Šè·
        textboxElement.style.width = 'auto';
        textboxElement.style.height = 'auto';
        textboxElement.style.minWidth = 'fit-content';
        textboxElement.style.minHeight = 'fit-content';
        textboxElement.style.display = 'flex';
        textboxElement.style.alignItems = 'center';
        textboxElement.style.justifyContent = 'center';
        
        // å‰µå»ºé€£æ¥ç·šå®¹å™¨
        const connectionElement = document.createElement('div');
        connectionElement.className = 'defect-mark-connection';
        connectionElement.dataset.defectMarkId = defectMarkData.id;
        connectionElement.style.position = 'absolute';
        connectionElement.style.pointerEvents = 'none';
        connectionElement.style.zIndex = '999';
        
        // è¨­ç½®åˆå§‹ä½ç½®
        updateDefectMarkPosition(dotElement, textboxElement, connectionElement, defectMarkData);
        
        // æ·»åŠ åˆ°æ¨™ç±¤å±¤
        labelLayer.appendChild(dotElement);
        labelLayer.appendChild(textboxElement);
        labelLayer.appendChild(connectionElement);
        
        window.logger.log('Defect mark elements added to labelLayer:', {
            dot: dotElement,
            textbox: textboxElement,
            connection: connectionElement
        });
        
        // æ·»åŠ äº‹ä»¶ç›£è½å™¨
        setupDefectMarkEvents(dotElement, textboxElement, defectMarkData);
        
        return { dot: dotElement, textbox: textboxElement, connection: connectionElement };
    }
    
                                // æ›´æ–°ç¼ºé™·æ¨™è¨˜ä½ç½®
    function updateDefectMarkPosition(dotElement, textboxElement, connectionElement, defectMarkData) {
        if (!defectMarkData.canvasPosition) return;
        
        const canvasX = defectMarkData.canvasPosition.x;
        const canvasY = defectMarkData.canvasPosition.y;
        
        // è¨ˆç®—è¢å¹•åº§æ¨™
        const screenX = canvasX * (window.currentScale || 1) + (window.translateX || 0);
        const screenY = canvasY * (window.currentScale || 1) + (window.translateY || 0);
        
        // è¨ˆç®—ç¸®æ”¾å¾Œçš„å°ºå¯¸ï¼ˆèˆ‡æ¨™ç±¤çš„ç¸®æ”¾é‚è¼¯ä¸€è‡´ï¼‰
        const baseDotSize = window.defectMarkSizeScale || 24;
        const scaledDotSize = baseDotSize * (window.currentScale || 1);
        
        // è¨ˆç®—ç¸®æ”¾å¾Œçš„å­—é«”å¤§å°
        const scaledDotFontSize = Math.max(8, scaledDotSize * 0.5); // åœ“é»å­—é«”å¤§å°ç‚ºç¸®æ”¾å¾Œåœ“é»å¤§å°çš„50%
        const scaledTextboxFontSize = Math.max(8, scaledDotSize * 0.4); // æ–‡å­—æ¡†å­—é«”å¤§å°ç‚ºç¸®æ”¾å¾Œåœ“é»å¤§å°çš„40%
        
        // æ›´æ–°åœ“é»å°ºå¯¸å’Œå­—é«”å¤§å°ï¼Œè¨­ç½®ä¸­å¿ƒå°é½Š
        dotElement.style.width = scaledDotSize + 'px';
        dotElement.style.height = scaledDotSize + 'px';
        dotElement.style.fontSize = scaledDotFontSize + 'px';
        dotElement.style.borderRadius = (scaledDotSize / 2) + 'px'; // ç¢ºä¿åœ“é»ä¿æŒåœ“å½¢
        dotElement.style.display = 'flex';
        dotElement.style.alignItems = 'center';
        dotElement.style.justifyContent = 'center';
        
        // æ›´æ–°æ–‡å­—æ¡†å­—é«”å¤§å°å’Œæ¨£å¼
        textboxElement.style.fontSize = scaledTextboxFontSize + 'px';
        
        // è¨­ç½®æ–‡å­—æ¡†ç‚ºè‡ªå‹•èª¿æ•´å¤§å°ï¼Œä¿æŒ 5px é‚Šè·
        const scaledPadding = 5 * (window.currentScale || 1); // ç¸®æ”¾ padding
        textboxElement.style.padding = scaledPadding + 'px';
        textboxElement.style.borderRadius = '4px';
        textboxElement.style.width = 'auto';
        textboxElement.style.height = 'auto';
        textboxElement.style.minWidth = 'fit-content';
        textboxElement.style.minHeight = 'fit-content';
        textboxElement.style.display = 'flex';
        textboxElement.style.alignItems = 'center';
        textboxElement.style.justifyContent = 'center';
        
        // è¨ˆç®—æ–‡å­—æ¡†ä¸­å¿ƒä½ç½®ï¼ˆä½¿ç”¨ç•«å¸ƒåº§æ¨™åç§»ï¼Œèˆ‡åœ“é»å®šä½æ–¹æ³•ä¸€è‡´ï¼‰
        // æ³¨æ„ï¼štextboxOffsetX/Y ç¾åœ¨ä»£è¡¨æ–‡å­—æ¡†ä¸­å¿ƒé»ç›¸å°æ–¼åœ“é»ä¸­å¿ƒé»çš„ç•«å¸ƒåº§æ¨™åç§»
        // é€™æ¨£å¯ä»¥ç¢ºä¿æ–‡å­—æ¡†åœ¨ç¸®æ”¾æ™‚ä¿æŒæ­£ç¢ºçš„ç›¸å°ä½ç½®ï¼Œä¸æœƒç§»å‹•
        // ä¿®æ­£é è¨­åç§»å€¼ï¼Œé¿å…90åº¦ç§»å‹•æ™‚çš„è·³èºå•é¡Œ
        const textboxOffsetX = defectMarkData.textboxOffsetX !== undefined ? defectMarkData.textboxOffsetX : 80;
        const textboxOffsetY = defectMarkData.textboxOffsetY !== undefined ? defectMarkData.textboxOffsetY : 40;
        
        // å°‡ç•«å¸ƒåº§æ¨™åç§»è½‰æ›ç‚ºè¢å¹•åº§æ¨™
        const textboxCenterCanvasX = canvasX + textboxOffsetX;
        const textboxCenterCanvasY = canvasY + textboxOffsetY;
        const textboxCenterScreenX = textboxCenterCanvasX * (window.currentScale || 1) + (window.translateX || 0);
        const textboxCenterScreenY = textboxCenterCanvasY * (window.currentScale || 1) + (window.translateY || 0);
        
        // è¨­ç½®åœ“é»ä½ç½®ï¼ˆä¸­å¿ƒé»ï¼‰
        const dotRadius = scaledDotSize / 2; // ç¸®æ”¾å¾Œçš„åœ“é»åŠå¾‘
        dotElement.style.left = (screenX - dotRadius) + 'px';
        dotElement.style.top = (screenY - dotRadius) + 'px';
        
        // è¨­ç½®æ–‡å­—æ¡†ä½ç½®ï¼ˆä»¥ä¸­å¿ƒé»ç‚ºåŸºæº–ï¼‰
        // ç”±æ–¼æ–‡å­—æ¡†ç¾åœ¨æ˜¯è‡ªå‹•èª¿æ•´å¤§å°ï¼Œæˆ‘å€‘éœ€è¦å…ˆç²å–å…¶å¯¦éš›å°ºå¯¸
        // å¼·åˆ¶é‡æ–°è¨ˆç®—æ–‡å­—æ¡†å°ºå¯¸
        textboxElement.style.display = 'none';
        textboxElement.offsetHeight; // å¼·åˆ¶é‡æ’
        textboxElement.style.display = 'flex';
        
        const textboxRect = textboxElement.getBoundingClientRect();
        const actualTextboxWidth = textboxRect.width;
        const actualTextboxHeight = textboxRect.height;
        
        textboxElement.style.left = (textboxCenterScreenX - actualTextboxWidth / 2) + 'px';
        textboxElement.style.top = (textboxCenterScreenY - actualTextboxHeight / 2) + 'px';
        
        // è¨ˆç®—é€£æ¥ç·šç«¯é» - å¾åœ“é»ä¸­å¿ƒåˆ°æ–‡å­—æ¡†ä¸­å¿ƒ
        const dotCenterX = screenX; // åœ“é»ä¸­å¿ƒX
        const dotCenterY = screenY; // åœ“é»ä¸­å¿ƒY
        
        // ç¢ºä¿æ–‡å­—æ¡†ä¸­å¿ƒé»è¨ˆç®—æ­£ç¢ºï¼ˆä½¿ç”¨å¯¦éš›çš„æ–‡å­—æ¡†ä½ç½®åŠ ä¸Šå°ºå¯¸çš„ä¸€åŠï¼‰
        const actualTextboxCenterX = textboxCenterScreenX;
        const actualTextboxCenterY = textboxCenterScreenY;
        
        // é©—è­‰åº§æ¨™å€¼æ˜¯å¦ç‚ºæœ‰æ•ˆæ•¸å­—
        if (isNaN(dotCenterX) || isNaN(dotCenterY) || isNaN(textboxCenterScreenX) || isNaN(textboxCenterScreenY)) {
            window.logger.error('Invalid coordinates detected:', {
                dotCenterX, dotCenterY, textboxCenterScreenX, textboxCenterScreenY,
                screenX, screenY, textboxOffsetX, textboxOffsetY
            });
            return;
        }
        
        window.logger.log('Updating defect mark position:', {
            defectMarkId: defectMarkData.id,
            canvasPosition: defectMarkData.canvasPosition,
            screenPosition: { x: screenX, y: screenY },
            dotPosition: { left: dotElement.style.left, top: dotElement.style.top },
            textboxPosition: { left: textboxElement.style.left, top: textboxElement.style.top },
            textboxDimensions: { width: actualTextboxWidth, height: actualTextboxHeight },
            connectionEndpoints: { 
                dotCenter: { x: dotCenterX, y: dotCenterY }, 
                textboxCenter: { x: textboxCenterScreenX, y: textboxCenterScreenY } 
            }
        });
        
        updateDefectMarkConnection(connectionElement, dotCenterX, dotCenterY, actualTextboxCenterX, actualTextboxCenterY);
    }
    
    // æ›´æ–°ç¼ºé™·æ¨™è¨˜é€£æ¥ç·š
    function updateDefectMarkConnection(connectionElement, x1, y1, x2, y2) {
        const svgNS = "http://www.w3.org/2000/svg";
        connectionElement.innerHTML = '';
        
        // è¨ˆç®— SVG çš„é‚Šç•Œ
        const minX = Math.min(x1, x2);
        const minY = Math.min(y1, y2);
        const maxX = Math.max(x1, x2);
        const maxY = Math.max(y1, y2);
        
        // æ·»åŠ ä¸€äº›é‚Šè·
        const margin = 50;
        const svgWidth = maxX - minX + margin * 2;
        const svgHeight = maxY - minY + margin * 2;
        
        // å‰µå»º SVG å…ƒç´ 
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", svgWidth);
        svg.setAttribute("height", svgHeight);
        svg.setAttribute("style", `position: absolute; left: ${minX - margin}px; top: ${minY - margin}px; pointer-events: none; z-index: 998;`);
        
        // ç¢ºä¿ SVG çš„ viewBox è¨­ç½®æ­£ç¢º
        svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
        
        // èª¿æ•´ç·šæ¢åº§æ¨™åˆ° SVG çš„ç›¸å°ä½ç½®
        const lineX1 = x1 - minX + margin;
        const lineY1 = y1 - minY + margin;
        const lineX2 = x2 - minX + margin;
        const lineY2 = y2 - minY + margin;
        
        const line = document.createElementNS(svgNS, "line");
        line.setAttribute("x1", lineX1);
        line.setAttribute("y1", lineY1);
        line.setAttribute("x2", lineX2);
        line.setAttribute("y2", lineY2);
        line.setAttribute("stroke", "#dc3545");
        line.setAttribute("stroke-opacity", "0.8");
        // ä¿æŒç·šæ¢å¯¬åº¦å›ºå®šï¼Œä¸éš¨ç¸®æ”¾è®ŠåŒ–
        const strokeWidth = 1;
        line.setAttribute("stroke-width", strokeWidth.toString());
        
        svg.appendChild(line);
        connectionElement.appendChild(svg);
        
        // èª¿è©¦æ—¥èªŒï¼ˆåƒ…åœ¨é–‹ç™¼æ¨¡å¼ä¸‹é¡¯ç¤ºï¼‰
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.logger.log('Connection line updated:', { 
                originalCoords: { x1, y1, x2, y2 },
                svgBounds: { minX, minY, maxX, maxY },
                svgDimensions: { width: svgWidth, height: svgHeight },
                lineCoords: { x1: lineX1, y1: lineY1, x2: lineX2, y2: lineY2 },
                currentScale: window.currentScale || 1,
                strokeWidth: strokeWidth
            });
        }
        
        // é©—è­‰ SVG å…ƒç´ æ˜¯å¦æ­£ç¢ºå‰µå»ºï¼ˆåƒ…åœ¨é–‹ç™¼æ¨¡å¼ä¸‹é¡¯ç¤ºï¼‰
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.logger.log('SVG element created:', svg);
            window.logger.log('Line element created:', line);
            window.logger.log('Connection element children:', connectionElement.children.length);
        }
    }
    
    // è¨ˆç®—ç•«å¸ƒåº§æ¨™çš„è¼”åŠ©å‡½æ•¸ï¼ˆPlan.htmlæ–¹æ³•ï¼‰
    function calculateCanvasPosition(label) {
        // ç²å–PDF canvasçš„å¯¦éš›ä½ç½®
        const canvasRect = floorPlanCanvas.getBoundingClientRect();
        const labelRect = label.getBoundingClientRect();
        
        // è¨ˆç®—æ¨™ç±¤çš„ä¸­å¿ƒé»
        const labelCenterX = labelRect.left + labelRect.width / 2;
        const labelCenterY = labelRect.top + labelRect.height / 2;
        
        // è¨ˆç®—æ¨™ç±¤ç›¸å°æ–¼PDF canvasçš„ä½ç½®ï¼ˆä½¿ç”¨ä¸­å¿ƒé»ï¼‰
        const relativeToCanvasX = labelCenterX - canvasRect.left;
        const relativeToCanvasY = labelCenterY - canvasRect.top;
        
        // è½‰æ›ç‚ºç•«å¸ƒåº§æ¨™ï¼Œç§»é™¤ç•¶å‰çš„è®Šæ›
        // é€™çµ¦äº†æˆ‘å€‘åŸå§‹ç•«å¸ƒåº§æ¨™ç³»çµ±ä¸­çš„ä½ç½®
        const canvasX = (relativeToCanvasX - (window.translateX || 0)) / (window.currentScale || 1);
        const canvasY = (relativeToCanvasY - (window.translateY || 0)) / (window.currentScale || 1);
        
        window.logger.log('Canvas position calculated:', {
            labelCenter: { x: labelCenterX, y: labelCenterY },
            canvasRect: { left: canvasRect.left, top: canvasRect.top },
            relativeToCanvas: { x: relativeToCanvasX, y: relativeToCanvasY },
            canvasPosition: { x: canvasX, y: canvasY },
            scale: window.currentScale || 1,
            offsetX: window.translateX || 0,
            offsetY: window.translateY || 0
        });
        
        return { x: canvasX, y: canvasY };
    }
    
    // æ›´æ–°å–®å€‹æ¨™ç±¤ä½ç½®çš„è¼”åŠ©å‡½æ•¸ - ä»¥ä¸­å¿ƒé»ç‚ºåŸºæº–ï¼ˆä¿®å¾©ç¸®æ”¾åç§»å•é¡Œï¼‰
    function updateSingleLabelPosition(labelElement, labelData) {
        if (!labelElement || !labelData) return;
        
        // æª¢æŸ¥æ˜¯å¦æœ‰ç•«å¸ƒåº§æ¨™ï¼Œå¦‚æœæ²’æœ‰å‰‡å‰µå»ºä¸€å€‹
        if (!labelData.canvasPosition) {
            if (labelData.pdfX !== undefined && labelData.pdfY !== undefined) {
                // å°‡PDFåº§æ¨™è½‰æ›ç‚ºç•«å¸ƒåº§æ¨™
                labelData.canvasPosition = { x: labelData.pdfX, y: labelData.pdfY };
        } else {
                // ä½¿ç”¨èˆŠåº§æ¨™ç³»çµ±
                labelData.canvasPosition = { x: labelData.x || 0, y: labelData.y || 0 };
            }
        }
        
        // ä½¿ç”¨ç•«å¸ƒåº§æ¨™ï¼ˆPlan.htmlæ–¹æ³•ï¼‰
        const canvasX = labelData.canvasPosition.x;
        const canvasY = labelData.canvasPosition.y;
        
        // è¨ˆç®—è¢å¹•åº§æ¨™ï¼šç•«å¸ƒåº§æ¨™ * ç¸®æ”¾ + åç§»
        // é€™è£¡çš„åº§æ¨™æ˜¯ç›¸å°æ–¼PDFå…§å®¹çš„ï¼Œéœ€è¦åŠ ä¸Šåç§»ä¾†å¾—åˆ°è¢å¹•ä½ç½®
        const screenX = canvasX * (window.currentScale || 1) + (window.translateX || 0);
        const screenY = canvasY * (window.currentScale || 1) + (window.translateY || 0);
        
        // è¨ˆç®—ç¸®æ”¾å¾Œçš„å­—é«”å¤§å°
        const baseFontSize = labelData.baseFontSize || window.labelSizeScale;
        const scaledFontSize = baseFontSize * (window.currentScale || 1);
        labelElement.style.fontSize = scaledFontSize + 'px';
        
        // å‹•æ…‹æ›´æ–°paddingï¼Œç¢ºä¿æ¨™ç±¤å½¢ç‹€ä¿æŒå›ºå®š
        const basePaddingX = 12;
        const basePaddingY = 8;
        
        // æŒ‰æ¯”ä¾‹ç¸®æ”¾å…§é‚Šè·
        const scaledPaddingX = Math.max(4, basePaddingX / (window.currentScale || 1));
        const scaledPaddingY = Math.max(4, basePaddingY / (window.currentScale || 1));
        labelElement.style.padding = `${scaledPaddingY}px ${scaledPaddingX}px`;
        
        // å¼·åˆ¶é‡æ’ä»¥ç¢ºä¿å°ºå¯¸è¨ˆç®—æ­£ç¢º
        labelElement.offsetHeight;
        
        // ç²å–å¯¦éš›å°ºå¯¸
        const labelWidth = labelElement.offsetWidth;
        const labelHeight = labelElement.offsetHeight;
        
        // ä½¿ç”¨å¯¦éš›å°ºå¯¸ï¼Œå¦å‰‡ä¼°ç®—
        const finalWidth = labelWidth > 0 ? labelWidth : Math.max(100, scaledFontSize * 8);
        const finalHeight = labelHeight > 0 ? labelHeight : Math.max(30, scaledFontSize * 2);
        
        // å®šä½æ¨™ç±¤ï¼Œä½¿å…¶ä¸­å¿ƒä½æ–¼è¨ˆç®—çš„é»
        labelElement.style.left = (screenX - finalWidth / 2) + 'px';
        labelElement.style.top = (screenY - finalHeight / 2) + 'px';
        
        // ç§»é™¤transformï¼Œå› ç‚ºæˆ‘å€‘ä½¿ç”¨æ‰‹å‹•ç¸®æ”¾
        labelElement.style.transform = 'none';
        
        // èª¿è©¦æ—¥èªŒï¼šåƒ…åœ¨é–‹ç™¼ç’°å¢ƒä¸‹è¼¸å‡º
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.logger.log('Label position updated:', {
                labelId: labelData.id,
                canvasPosition: { x: canvasX, y: canvasY },
                screenPosition: { x: screenX, y: screenY },
                finalPosition: { 
                    left: (screenX - finalWidth / 2) + 'px',
                    top: (screenY - finalHeight / 2) + 'px'
                },
                scale: window.currentScale || 1,
                translate: { x: window.translateX || 0, y: window.translateY || 0 },
                dimensions: { width: finalWidth, height: finalHeight }
            });
        }
    }
    
    // é‡æ–°å¯¦ç¾æ¨™ç±¤ä½ç½®åŒæ­¥å‡½æ•¸ - ä½¿ç”¨Plan.htmlçš„æ–¹æ³•
    // å°‡å‡½æ•¸å®šç¾©ç‚ºå…¨å±€å‡½æ•¸ï¼Œç¢ºä¿åœ¨applyTransformä¸­å¯ä»¥èª¿ç”¨
    window.updateAllLabelPositions = function() {
        if (!labelLayer) return;
        
        // éš±è—æ‰€æœ‰åˆªé™¤æŒ‰éˆ•ï¼ˆç•¶æ¨™ç±¤ä½ç½®æ›´æ–°æ™‚ï¼‰
        hideAllDeleteButtons();
        
        // ç²å–æ‰€æœ‰æ¨™ç±¤å…ƒç´ 
        const labelElements = labelLayer.querySelectorAll('.floor-plan-label');
        
        // ä½¿ç”¨ window.labels è€Œä¸æ˜¯å±€éƒ¨è®Šé‡ labels
        const labelsArray = window.labels || [];
        
        labelElements.forEach(labelElement => {
            const labelId = labelElement.dataset.labelId;
            const labelData = labelsArray.find(l => l.id == labelId);
            
            if (labelData) {
                // ä½¿ç”¨çµ±ä¸€çš„ä½ç½®æ›´æ–°å‡½æ•¸ï¼Œç¢ºä¿ä¸­å¿ƒé»å®šä½
                updateSingleLabelPosition(labelElement, labelData);
            }
        });
    }
    
    // é˜²æŠ–è®Šæ•¸
    let transformDebounceTimer = null;
    
    // å…¨å±€çš„applyTransformå‡½æ•¸ - ç”¨æ–¼æ›´æ–°PDFè®Šæ›å’Œæ¨™ç±¤ä½ç½®
    window.applyTransform = function() {
        const floorPlanCanvas = document.getElementById('floorPlanCanvas');
        if (!floorPlanCanvas) return;
        
        const t = `translate(${window.translateX || 0}px, ${window.translateY || 0}px) scale(${window.currentScale || 1})`;
        floorPlanCanvas.style.transform = t;
        
        // ç«‹å³æ›´æ–°æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜ä½ç½®ï¼ˆç„¡å»¶é²ï¼‰
        if (typeof window.updateAllLabelPositions === 'function') {
            window.updateAllLabelPositions();
        }
        if (typeof window.updateAllDefectMarkPositions === 'function') {
            window.updateAllDefectMarkPositions();
        }
        
        // æª¢æŸ¥æ˜¯å¦æœ‰å¾…æ¢å¾©çš„è¦–åœ–ç‹€æ…‹ï¼ˆç”¨æˆ¶äº’å‹•è§¸ç™¼çš„æ¢å¾©ï¼‰
        if (window.pendingViewStateRestore) {
            window.logger.log('View state restore triggered by user interaction');
            window.pendingViewStateRestore = false;
            
            // æ›´æ–°æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜å¤§å° UI
            if (window.labelSizeScale && typeof updateLabelSizeUI === 'function') {
                updateLabelSizeUI();
            }
            if (window.defectMarkSizeScale && typeof updateDefectMarkSizeUI === 'function') {
                updateDefectMarkSizeUI();
            }
            
            // é‡æ–°è¨­ç½®é›™æ“Šäº‹ä»¶ç›£è½å™¨
            if (typeof setupDoubleClickHandler === 'function') {
                setupDoubleClickHandler();
                window.logger.log('Double-click handler re-initialized after user interaction');
            }
        }
        
        // æ¸…é™¤ä¹‹å‰çš„é˜²æŠ–è¨ˆæ™‚å™¨
        if (transformDebounceTimer) {
            clearTimeout(transformDebounceTimer);
        }
        
        // ä½¿ç”¨é˜²æŠ–ä¾†æ¸›å°‘é‡è¤‡çš„ç‹€æ…‹ä¿å­˜
        transformDebounceTimer = setTimeout(() => {
            // ä¿å­˜è¦–åœ–ç‹€æ…‹
            if (typeof labelViewState !== 'undefined') {
                labelViewState = { scale: window.currentScale || 1, tx: window.translateX || 0, ty: window.translateY || 0 };
                saveViewStateToLocalStorage();
            }
            
            // èª¿è©¦æ—¥èªŒ
            window.logger.log('Transform applied:', {
                scale: window.currentScale || 1,
                translateX: window.translateX || 0,
                translateY: window.translateY || 0,
                transform: t
            });
        }, 100); // 100ms é˜²æŠ–å»¶é²ï¼Œåƒ…ç”¨æ–¼ç‹€æ…‹ä¿å­˜
    }
    
    // ç¸®æ”¾è‡³100%ä¸¦å±…ä¸­å‡½æ•¸
    function zoomTo100AndCenter() {
        if (!floorPlanCanvas || !floorPlanViewer) {
            window.logger.log('Floor plan canvas or viewer not available');
            return;
        }
        
        // è¨­ç½®ç¸®æ”¾ç‚º100%
        window.currentScale = 1.0;
        
        // ç²å–PDFå…§å®¹å’Œè¦–çª—çš„å°ºå¯¸
        const canvasRect = floorPlanCanvas.getBoundingClientRect();
        const viewerRect = floorPlanViewer.getBoundingClientRect();
        
        // è¨ˆç®—å±…ä¸­æ‰€éœ€çš„åç§»é‡
        // å°‡PDFå…§å®¹å±…ä¸­æ–¼è¦–çª—ä¸­
        const centerX = (viewerRect.width - canvasRect.width) / 2;
        const centerY = (viewerRect.height - canvasRect.height) / 2;
        
        // è¨­ç½®åç§»é‡ä»¥å±…ä¸­é¡¯ç¤º
        window.translateX = centerX;
        window.translateY = centerY;
        
        // æ‡‰ç”¨è®Šæ›
        if (typeof window.applyTransform === 'function') {
            window.applyTransform();
        }
        
        // ä¿å­˜è¦–åœ–ç‹€æ…‹
        saveCurrentViewState();
        
        window.logger.log('Zoomed to 100% and centered:', {
            scale: window.currentScale,
            translateX: window.translateX,
            translateY: window.translateY,
            canvasSize: { width: canvasRect.width, height: canvasRect.height },
            viewerSize: { width: viewerRect.width, height: viewerRect.height }
        });
        
        showNotification('Zoomed to 100% and centered', 'success');
    }
    
    // é¡¯ç¤ºæ¨™ç±¤è©³ç´°ä¿¡æ¯å½ˆå‡ºè¡¨æ ¼
    window.showLabelsDetailPopup = function() {
        const popup = document.getElementById('labelsDetailPopup');
        const tableBody = document.getElementById('labelsDetailTableBody');
        
        if (!popup || !tableBody) {
            window.logger.error('Labels detail popup elements not found');
            return;
        }
        
        // æ¸…ç©ºè¡¨æ ¼å…§å®¹
        tableBody.innerHTML = '';
        
        // ä½¿ç”¨ window.labels è€Œä¸æ˜¯å±€éƒ¨è®Šé‡ labels
        const labelsArray = window.labels || [];
        
        if (labelsArray.length === 0) {
            const row = document.createElement('tr');
            row.innerHTML = '<td colspan="17" style="text-align: center; color: #666; font-style: italic;">No labels found</td>';
            tableBody.appendChild(row);
        } else {
            // æŒ‰æª¢æŸ¥è™Ÿç¢¼æ’åºï¼ˆæ•¸å­—æ’åºï¼Œå¾1é–‹å§‹ï¼‰
            const sortedLabels = [...labelsArray].sort((a, b) => {
                const aNo = parseInt(a.inspectionNo) || 0;
                const bNo = parseInt(b.inspectionNo) || 0;
                return aNo - bNo;
            });
            
            sortedLabels.forEach((label, index) => {
                const row = document.createElement('tr');
                row.dataset.labelId = label.id;
                row.dataset.labelIndex = index;
                row.innerHTML = `
                    <td class="action-buttons">
                        <button class="btn-delete-label" onclick="deleteLabelFromDetailTable('${label.id}', ${index})" title="åˆªé™¤æ¨™ç±¤è¨˜éŒ„">
                            <i class="fas fa-trash"></i>
                        </button>
                    </td>
                    <td><input type="text" value="${label.inspectionNo || ''}" data-field="inspectionNo" data-index="${index}" readonly></td>
                    <td><input type="text" value="${label.floor || ''}" data-field="floor" data-index="${index}"></td>
                    <td><input type="text" value="${label.areaName || ''}" data-field="areaName" data-index="${index}"></td>
                    <td><input type="text" value="${label.roomNo || ''}" data-field="roomNo" data-index="${index}"></td>
                    <td><input type="date" value="${label.inspectionDate || ''}" data-field="inspectionDate" data-index="${index}"></td>
                    <td><div class="label-content">${formatLabelItems(label.a || '')}</div></td>
                    <td><div class="label-content">${formatLabelItems(label.b || '')}</div></td>
                    <td><div class="label-content">${formatLabelItems(label.c || '')}</div></td>
                    <td><div class="label-content">${formatLabelItems(label.d || '')}</div></td>
                    <td><div class="label-content">${formatLabelItems(label.e || '')}</div></td>
                    <td><div class="label-content">${formatLabelItems(label.f || '')}</div></td>
                    <td><div class="label-content">${formatLabelItems(label.g || '')}</div></td>
                    <td><div class="label-content">${formatLabelItems(label.h || '')}</div></td>
                    <td><div class="label-content">${formatLabelItems(label.i || '')}</div></td>
                    <td><div class="defect-content">${generateDefectsWithButtons(getDefectsFromDefectsDetailTable(label.inspectionNo), label.id)}</div></td>
                `;
                tableBody.appendChild(row);
            });
        }
        
        // é¡¯ç¤ºå½ˆå‡ºè¡¨æ ¼
        popup.style.display = 'flex';
        
        // æ·»åŠ è‡ªå‹•ä¿å­˜åŠŸèƒ½
        addAutoSaveListeners('labels');
        
        // é‡æ–°åˆå§‹åŒ–å¯¦æ™‚è¼¸å…¥ç›£è½å™¨ï¼ˆç¢ºä¿æ–°å‰µå»ºçš„è¼¸å…¥å­—æ®µæœ‰ç›£è½å™¨ï¼‰
        initRealtimeInputListeners();
        
        // è¨­ç½®æ¨™ç±¤è©³ç´°è¡¨æ ¼çš„ç…§ç‰‡ç·¨è™Ÿå³æ™‚æ›´æ–°åŠŸèƒ½
        if (typeof handleLabelsDetailTablePhotoUpdate === 'function') {
            handleLabelsDetailTablePhotoUpdate();
        }
        
        // æ¸…é™¤å¤šé¸ç‹€æ…‹
        clearAllSelections();
        updateMultiSelectUI();
    }
    
    // é¡¯ç¤ºç¼ºé™·æ¨™è¨˜è©³ç´°ä¿¡æ¯å½ˆå‡ºè¡¨æ ¼
    window.showDefectsDetailPopup = function() {
        const popup = document.getElementById('defectsDetailPopup');
        const tableBody = document.getElementById('defectsDetailTableBody');
        
        if (!popup || !tableBody) {
            window.logger.error('Defects detail popup elements not found');
            return;
        }
        
        // æ¸…ç©ºè¡¨æ ¼å…§å®¹
        tableBody.innerHTML = '';
        
        // ä½¿ç”¨ window.defectEntries è€Œä¸æ˜¯ window.defectMarksï¼Œå› ç‚ºæˆ‘å€‘è¦é¡¯ç¤ºä¾†è‡ª defect-form çš„æ•¸æ“š
        if (window.defectEntries.length === 0) {
            const row = document.createElement('tr');
            row.innerHTML = '<td colspan="20" style="text-align: center; color: #666; font-style: italic;">No defect entries found</td>';
            tableBody.appendChild(row);
        } else {
            window.defectEntries.forEach((defect, index) => {
                const row = document.createElement('tr');
                row.dataset.defectId = defect.id;
                row.dataset.defectNo = defect.defectNo;
                row.dataset.defectIndex = index;
                
                // å°‡åˆ†é¡ä»£ç¢¼è½‰æ›ç‚ºå®Œæ•´çš„åˆ†é¡åç¨±
                const getCategoryName = (categoryCode) => {
                    const category = categories.find(cat => cat.id === categoryCode);
                    return category ? category.name : categoryCode;
                };
                
                row.innerHTML = `
                    <td><input type="text" value="${defect.defectNo || ''}" data-field="defectNo" data-index="${index}" readonly></td>
                    <td><input type="text" value="${defect.locationId || defect.inspectionNo || ''}" data-field="locationId" data-index="${index}" readonly></td>
                     <td><input type="text" value="${defect.imminentDanger ? 'Yes' : 'No'}" data-field="imminentDanger" data-index="${index}" readonly></td>
                    <td><input type="date" value="${defect.inspectionDate || ''}" data-field="inspectionDate" data-index="${index}" readonly></td>
                    <td><input type="text" value="${defect.floor || ''}" data-field="floor" data-index="${index}" readonly></td>
                    <td><input type="text" value="${defect.areaName || ''}" data-field="areaName" data-index="${index}" readonly></td>
                    <td><input type="text" value="${defect.roomNo || ''}" data-field="roomNo" data-index="${index}" readonly></td>
                    <td><div class="defect-content">${formatDefectPhotoNumbers(defect.photoNumbers || '')}</div></td>
                    <td><div class="defect-content">${formatDefectCategory(getCategoryName(defect.category) || '')}</div></td>
                    <td><div class="defect-content">${formatDefectType(defect.defectType || defect.description || '')}</div></td>
                    <td><textarea data-field="descriptionConstruction" data-index="${index}" class="defect-textarea" readonly>${defect.descriptionConstruction || ''}</textarea></td>
                    <td><input type="text" value="${defect.existingCondition || ''}" data-field="existingCondition" data-index="${index}" readonly></td>
                    <td><input type="text" value="${defect.humidity || ''}" data-field="humidity" data-index="${index}" readonly></td>
                    <td><input type="text" value="${defect.moisture || ''}" data-field="moisture" data-index="${index}" readonly></td>
                    <td><input type="text" value="${defect.chloride || ''}" data-field="chloride" data-index="${index}" readonly></td>
                    <td><input type="text" value="${defect.carbonation || ''}" data-field="carbonation" data-index="${index}" readonly></td>
                    <td><textarea data-field="remedialWorks" data-index="${index}" class="defect-textarea" readonly>${defect.remedialWorks || ''}</textarea></td>
                    <td><textarea data-field="preventiveWorks" data-index="${index}" class="defect-textarea" readonly>${defect.preventiveWorks || ''}</textarea></td>
                    <td><textarea data-field="remarks" data-index="${index}" class="defect-textarea" readonly>${defect.remarks || ''}</textarea></td>
                `;
                tableBody.appendChild(row);
            });
        }
        
        // é¡¯ç¤ºå½ˆå‡ºè¡¨æ ¼
        popup.style.display = 'flex';
        
        // æ·»åŠ è‡ªå‹•ä¿å­˜åŠŸèƒ½
        addAutoSaveListeners('defects');
        
        // é‡æ–°åˆå§‹åŒ–å¯¦æ™‚è¼¸å…¥ç›£è½å™¨ï¼ˆç¢ºä¿æ–°å‰µå»ºçš„è¼¸å…¥å­—æ®µæœ‰ç›£è½å™¨ï¼‰
        initRealtimeInputListeners();
        
        // æ¸…é™¤å¤šé¸ç‹€æ…‹
        clearAllSelections();
        updateMultiSelectUI();
    }
    
    // ä¿å­˜æ¨™ç±¤æ›´æ”¹
    function saveLabelsChanges() {
        const tableBody = document.getElementById('labelsDetailTableBody');
        const inputs = tableBody.querySelectorAll('input[data-field]');
        
        let hasChanges = false;
        
        inputs.forEach(input => {
            const index = parseInt(input.dataset.index);
            const field = input.dataset.field;
            let value;
            
            // è™•ç†checkboxå­—æ®µ
            if (input.type === 'checkbox') {
                value = input.checked;
            } else {
                value = input.value.trim();
            }
            
            // æª¢æŸ¥æ¬„ä½æ˜¯å¦ç‚ºåªè®€ï¼Œå¦‚æœæ˜¯å‰‡ä¸é€²è¡Œä¿å­˜
            if (input.readOnly) {
                return;
            }
            
            // è™•ç†æ‰€æœ‰å­—æ®µï¼Œä½†è·³éåªè®€çš„åˆ†é¡å­—æ®µï¼ˆa-jï¼‰
            const editableFields = ['floor', 'areaName', 'roomNo', 'inspectionDate', 'imminentDanger'];
            if (window.labels && window.labels[index] && editableFields.includes(field)) {
                if (window.labels[index][field] !== value) {
                    window.labels[index][field] = value;
                    hasChanges = true;
                }
            }
        });
        
        if (hasChanges) {
            // ä¸åœ¨é€™è£¡è¨­ç½® submitted ç‹€æ…‹ï¼Œæ¨™ç±¤åªåœ¨å¾åˆ†é¡å…§å®¹æäº¤æ™‚æ‰è®Šè—è‰²
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å„²
            if (typeof window.saveLabelsToStorage === 'function') {
                window.saveLabelsToStorage();
            }
            
            // åŒæ™‚ä¿å­˜åˆ°ä¸»æ•¸æ“šå­˜å„²
            saveDataToStorage();
            
            // ç§»é™¤æ¨™ç±¤é‡æ–°æ¸²æŸ“ - æ ¹æ“šç”¨æˆ¶è¦æ±‚ï¼Œæ›´æ–°æ¨™ç±¤è©³ç´°è¡¨æ ¼æ™‚ä¸æ”¹è®Šæ¨“å±¤å¹³é¢åœ–ä¸­çš„æ¨™ç±¤
            // if (typeof window.redrawLabels === 'function') {
            //     window.redrawLabels();
            // }
            
            // åŒæ­¥æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼
            syncLabelsToInspectionRecords();
            
            // æ›´æ–°åˆ†é¡è¡¨æ ¼
            if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}
            
            // é¡¯ç¤ºæˆåŠŸé€šçŸ¥
            showNotification('Labels updated successfully!', 'success');
            
            // é—œé–‰å½ˆå‡ºè¡¨æ ¼
            const popup = document.getElementById('labelsDetailPopup');
            if (popup) {
                popup.style.display = 'none';
            }
        } else {
            showNotification('No changes to save.', 'info');
        }
    }
    
    // ä¿å­˜ç¼ºé™·æ¨™è¨˜æ›´æ”¹
    function saveDefectsChanges() {
        const tableBody = document.getElementById('defectsDetailTableBody');
        const inputs = tableBody.querySelectorAll('input[data-field], textarea[data-field]');
        
        let hasChanges = false;
        
        // æŒ‰ç´¢å¼•åˆ†çµ„è¼¸å…¥
        const changesByIndex = {};
        
        inputs.forEach(input => {
            const index = parseInt(input.dataset.index);
            const field = input.dataset.field;
            
            // æª¢æŸ¥æ¬„ä½æ˜¯å¦ç‚ºåªè®€ï¼Œå¦‚æœæ˜¯å‰‡ä¸é€²è¡Œä¿å­˜
            if (input.readOnly) {
                return;
            }
            
            const value = input.value.trim();
            
            if (!changesByIndex[index]) {
                changesByIndex[index] = {};
            }
            changesByIndex[index][field] = value;
        });
        
        // æ‡‰ç”¨æ›´æ”¹åˆ° defectEntries
        Object.keys(changesByIndex).forEach(indexStr => {
            const index = parseInt(indexStr);
            const changes = changesByIndex[index];
            
            if (window.defectEntries[index]) {
                // æ›´æ–°æ‰€æœ‰å­—æ®µ
                Object.keys(changes).forEach(field => {
                    if (window.defectEntries[index][field] !== changes[field]) {
                        window.defectEntries[index][field] = changes[field];
                            hasChanges = true;
                    }
                });
            }
        });
        
        if (hasChanges) {
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å„²
            saveDataToStorage();
            
            // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼
            if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
            
            // é¡¯ç¤ºæˆåŠŸé€šçŸ¥
            showNotification('Defect entries updated successfully!', 'success');
            
            // é—œé–‰å½ˆå‡ºè¡¨æ ¼
            const popup = document.getElementById('defectsDetailPopup');
            if (popup) {
                popup.style.display = 'none';
            }
        } else {
            showNotification('No changes to save.', 'info');
        }
    }
    
    // æ–°çš„æ¨™ç±¤äº‹ä»¶è™•ç†ç³»çµ±
    function setupLabelEvents(labelElement, labelData) {
        let isDragging = false;
        let dragStartTimer = null;
        let dragStartData = null;
        
        // é¼ æ¨™æŒ‰ä¸‹é–‹å§‹æ‹–æ›³
        labelElement.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // éš±è—åˆªé™¤æŒ‰éˆ•ï¼ˆç•¶é–‹å§‹æ‹–æ›³æ™‚ï¼‰
            hideAllDeleteButtons();
            
            // è¨˜éŒ„é–‹å§‹çš„é¼ æ¨™ä½ç½®å’Œæ¨™ç±¤çš„ç•«å¸ƒåº§æ¨™
            const startMouseX = e.clientX;
            const startMouseY = e.clientY;
            const startCanvasX = labelData.canvasPosition ? labelData.canvasPosition.x : 0;
            const startCanvasY = labelData.canvasPosition ? labelData.canvasPosition.y : 0;
            
            // æ·»åŠ æ‹–æ‹½æº–å‚™ç‹€æ…‹çš„è¦–è¦ºåé¥‹
            labelElement.classList.add('drag-preparing');
            
            // é¡¯ç¤ºæº–å‚™æ‹–æ‹½æç¤º
            showNotification('Hold for 0.3 seconds to start dragging', 'info');
            
            // è¨­ç½®0.3ç§’å»¶é²ä¾†é–‹å§‹æ‹–æ‹½
            dragStartTimer = setTimeout(function() {
                // ç§»é™¤æº–å‚™ç‹€æ…‹ï¼Œé–‹å§‹æ‹–æ‹½
                labelElement.classList.remove('drag-preparing');
                isDragging = true;
                labelElement.classList.add('dragging');
                
                // é¡¯ç¤ºæ‹–æ‹½é–‹å§‹æç¤º
                showNotification('Label drag started - you can now move the label', 'success');
            
            // æ·»åŠ å…¨åŸŸäº‹ä»¶ç›£è½å™¨
            const onMouseMove = function(e) {
                if (!isDragging) return;
                
                // è¨ˆç®—é¼ æ¨™ç§»å‹•çš„è·é›¢ï¼ˆå±å¹•åƒç´ ï¼‰
                const deltaX = e.clientX - startMouseX;
                const deltaY = e.clientY - startMouseY;
                
                // å°‡åƒç´ ç§»å‹•è·é›¢è½‰æ›ç‚ºç•«å¸ƒåº§æ¨™è·é›¢
                // ä½¿ç”¨ç•¶å‰çš„ç¸®æ”¾æ¯”ä¾‹é€²è¡Œè½‰æ›
                const canvasDeltaX = deltaX / (window.currentScale || 1);
                // ä¸éœ€è¦åè½‰Yè»¸ï¼Œå› ç‚ºæˆ‘å€‘ä½¿ç”¨çš„æ˜¯ç•«å¸ƒåº§æ¨™ç³»çµ±
                const canvasDeltaY = deltaY / (window.currentScale || 1);
                
                // æ›´æ–°æ¨™ç±¤çš„ç•«å¸ƒåº§æ¨™
                if (!labelData.canvasPosition) {
                    labelData.canvasPosition = { x: 0, y: 0 };
                }
                labelData.canvasPosition.x = startCanvasX + canvasDeltaX;
                labelData.canvasPosition.y = startCanvasY + canvasDeltaY;
                
                // ç«‹å³æ›´æ–°æ¨™ç±¤çš„è¦–è¦ºä½ç½®
                updateSingleLabelPosition(labelElement, labelData);
            };
            
            const onMouseUp = function() {
                isDragging = false;
                labelElement.classList.remove('dragging');
                if (typeof window.saveLabelsToStorage === 'function') {
                    window.saveLabelsToStorage();
                }
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            }, 300); // 0.3ç§’å»¶é²
            
            // ä¿å­˜æ‹–æ‹½é–‹å§‹æ•¸æ“šï¼Œç”¨æ–¼å–æ¶ˆæ‹–æ‹½
            dragStartData = {
                startMouseX: startMouseX,
                startMouseY: startMouseY,
                startCanvasX: startCanvasX,
                startCanvasY: startCanvasY
            };
        });
        
        // é¼ æ¨™æŠ¬èµ·æ™‚å–æ¶ˆæ‹–æ‹½é–‹å§‹è¨ˆæ™‚å™¨
        labelElement.addEventListener('mouseup', function(e) {
            if (dragStartTimer) {
                clearTimeout(dragStartTimer);
                dragStartTimer = null;
            }
            if (dragStartData) {
                dragStartData = null;
            }
            // ç§»é™¤æ‹–æ‹½æº–å‚™ç‹€æ…‹
            labelElement.classList.remove('drag-preparing');
        });
        
        // é¼ æ¨™é›¢é–‹æ¨™ç±¤æ™‚å–æ¶ˆæ‹–æ‹½é–‹å§‹è¨ˆæ™‚å™¨
        labelElement.addEventListener('mouseleave', function(e) {
            if (dragStartTimer) {
                clearTimeout(dragStartTimer);
                dragStartTimer = null;
            }
            if (dragStartData) {
                dragStartData = null;
            }
            // ç§»é™¤æ‹–æ‹½æº–å‚™ç‹€æ…‹
            labelElement.classList.remove('drag-preparing');
        });
        
        // å³éµé¡¯ç¤ºåˆªé™¤æŒ‰éˆ•
        labelElement.addEventListener('contextmenu', function(e) {
            window.logger.log('Right-click detected on label:', labelData.id);
            window.logger.log('Event:', e);
            window.logger.log('Label element:', labelElement);
            
            e.preventDefault();
            e.stopPropagation();
            
            try {
                showDeleteButton(labelElement, labelData);
                window.logger.log('showDeleteButton called successfully');
            } catch (error) {
                window.logger.error('Error in showDeleteButton:', error);
            }
        });
        
        // é›™æ“Šæ¨™ç±¤ - æ ¹æ“šé¡è‰²æ±ºå®šè¡Œç‚º
        labelElement.addEventListener('dblclick', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // æª¢æŸ¥æ¨™ç±¤æ˜¯å¦å·²æäº¤ï¼ˆè—è‰²ï¼‰
            if (labelData.submitted) {
                // è—è‰²æ¨™ç±¤ï¼šé–‹å•Ÿæª¢æŸ¥è©³ç´°è¦–çª—
                showInspectionDetailsWindow(labelData);
            } else {
                // é»ƒè‰²æ¨™ç±¤ï¼šé–‹å•Ÿç·¨è¼¯é¸å–®
                editingLabelId = labelData.id;
                openLabelModal(labelData);
            }
        });
    }

    // é¡¯ç¤ºåˆªé™¤æŒ‰éˆ•å‡½æ•¸
    function showDeleteButton(labelElement, labelData) {
        window.logger.log('showDeleteButton called for label:', labelData.id);
        window.logger.log('Label element:', labelElement);
        
        // éš±è—æ‰€æœ‰ç¾æœ‰çš„åˆªé™¤æŒ‰éˆ•
        hideAllDeleteButtons();
        
        // å‰µå»ºåˆªé™¤æŒ‰éˆ•
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'label-delete-btn';
        deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
        deleteBtn.title = `Delete Label: ${labelData.inspectionNo || 'Label'}`;
        deleteBtn.setAttribute('aria-label', `Delete label ${labelData.inspectionNo || 'Label'}`);
        
        // ç¢ºä¿æŒ‰éˆ•å¯ä»¥æ¥æ”¶äº‹ä»¶
        deleteBtn.style.pointerEvents = 'auto';
        deleteBtn.style.zIndex = '1001';
        deleteBtn.style.position = 'absolute';
        deleteBtn.style.top = '-30px';
        deleteBtn.style.right = '-10px';
        deleteBtn.style.width = '24px';
        deleteBtn.style.height = '24px';
        deleteBtn.style.background = '#dc3545'; /* ç´…è‰²èƒŒæ™¯ */
        deleteBtn.style.color = 'white';
        deleteBtn.style.border = 'none';
        deleteBtn.style.borderRadius = '50%';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.style.display = 'flex';
        deleteBtn.style.alignItems = 'center';
        deleteBtn.style.justifyContent = 'center';
        deleteBtn.style.fontSize = '12px';
        deleteBtn.style.boxShadow = '0 2px 8px rgba(220, 53, 69, 0.3)';
        deleteBtn.style.transition = 'all 0.2s ease';
        
        window.logger.log('Delete button created:', deleteBtn);
        
        // æ·»åŠ é»æ“Šåˆªé™¤äº‹ä»¶
        deleteBtn.addEventListener('click', function(e) {
            window.logger.log('Delete button click event triggered');
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            window.logger.log('Delete button clicked for label:', labelData.id);
            window.logger.log('Event target:', e.target);
            window.logger.log('Event currentTarget:', e.currentTarget);
            
            // ç›´æ¥åˆªé™¤æ¨™ç±¤ï¼Œç„¡éœ€ç¢ºèª
            window.logger.log('Deleting label:', labelData.id);
            
            const index = window.labels.findIndex(l => l.id === labelData.id);
            window.logger.log('Found label at index:', index);
            window.logger.log('Current labels array:', window.labels);
            
            if (index >= 0) {
                // å…ˆéš±è—åˆªé™¤æŒ‰éˆ•ï¼Œé¿å…åœ¨é‡æ–°æ¸²æŸ“æ™‚å‡ºç¾å•é¡Œ
                hideAllDeleteButtons();
                
                // åˆªé™¤æ¨™ç±¤æ•¸æ“š
                window.labels.splice(index, 1);
                window.logger.log('Label removed from array. New length:', window.labels.length);
                window.logger.log('Updated labels array:', window.labels);
                
                // ä¿å­˜åˆ°æœ¬åœ°å­˜å„²
                if (typeof window.saveLabelsToStorage === 'function') {
                    window.saveLabelsToStorage();
                }
                window.logger.log('Labels saved to localStorage');
                
                // é‡æ–°æ¸²æŸ“æ¨™ç±¤
                if (typeof window.redrawLabels === 'function') {
                    window.redrawLabels();
                }
                window.logger.log('Labels redrawn');
                
                // æ›´æ–°æ‰€æœ‰ç¼ºé™·/æ¨™ç±¤è©³ç´°è¡¨æ ¼å®¹å™¨
                if (typeof updateDefectSummaryTable === 'function') {
                    if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
                    window.logger.log('Defect summary table updated after label deletion');
                }
                if (typeof updateCategoryTablesFromInspectionRecords === 'function') {
                    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}
                    window.logger.log('Category tables updated after label deletion');
                }
                
                // æ›´æ–°ç…§ç‰‡ç‹€æ…‹
                if (typeof updatePhotoStatusFromLabels === 'function') {
                    updatePhotoStatusFromLabels();
                }
                
                // é¡¯ç¤ºæˆåŠŸæ¶ˆæ¯
                if (typeof showNotification === 'function') {
                    showNotification('Label deleted successfully!', 'success');
                }
            } else {
                window.logger.error('Label not found in array');
                window.logger.error('Labels array:', labels);
                window.logger.error('Looking for label ID:', labelData.id);
            }
        });
        
        // æ·»åŠ mousedownäº‹ä»¶ï¼Œç¢ºä¿æŒ‰éˆ•å¯ä»¥æ¥æ”¶é»æ“Š
        deleteBtn.addEventListener('mousedown', function(e) {
            window.logger.log('Delete button mousedown event');
            e.stopPropagation();
        });
        
        // å°‡åˆªé™¤æŒ‰éˆ•æ·»åŠ åˆ°æ¨™ç±¤å…ƒç´ ä¸Š
        labelElement.appendChild(deleteBtn);
        window.logger.log('Delete button appended to label element');
        window.logger.log('Label element children count:', labelElement.children.length);
        
        // é©—è­‰åˆªé™¤æŒ‰éˆ•å‰µå»ºæˆåŠŸ
        window.logger.log('Delete button created successfully');
        
        // æ·»åŠ é»æ“Šå¤–éƒ¨éš±è—åŠŸèƒ½
        setTimeout(() => {
            document.addEventListener('click', hideAllDeleteButtons, { once: true });
        }, 100);
    }
    
    // éš±è—æ‰€æœ‰åˆªé™¤æŒ‰éˆ•å‡½æ•¸
    function hideAllDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.label-delete-btn');
            window.logger.log('hideAllDeleteButtons called. Found delete buttons:', deleteButtons.length);
        deleteButtons.forEach(btn => {
            window.logger.log('Removing delete button:', btn);
            btn.remove();
        });
    }
    
    // æ·»åŠ å…¨å±€é»æ“Šäº‹ä»¶ç›£è½å™¨ï¼Œé»æ“ŠPDFå€åŸŸæ™‚éš±è—åˆªé™¤æŒ‰éˆ•
    document.addEventListener('click', function(e) {
        window.logger.log('Global click event:', e.target);
        window.logger.log('Is label?', e.target.closest('.floor-plan-label'));
        window.logger.log('Is delete button?', e.target.closest('.label-delete-btn'));
        window.logger.log('Is defect mark?', e.target.closest('.defect-mark-dot, .defect-mark-textbox'));
        window.logger.log('Is defect delete button?', e.target.closest('.defect-mark-delete-btn'));
        
        // å¦‚æœé»æ“Šçš„ä¸æ˜¯æ¨™ç±¤æˆ–åˆªé™¤æŒ‰éˆ•ï¼Œå‰‡éš±è—æ‰€æœ‰æ¨™ç±¤åˆªé™¤æŒ‰éˆ•
        if (!e.target.closest('.floor-plan-label') && !e.target.closest('.label-delete-btn')) {
            window.logger.log('Hiding label delete buttons due to external click');
            hideAllDeleteButtons();
        }
        
        // å¦‚æœé»æ“Šçš„ä¸æ˜¯ç¼ºé™·æ¨™è¨˜æˆ–ç¼ºé™·åˆªé™¤æŒ‰éˆ•ï¼Œå‰‡éš±è—æ‰€æœ‰ç¼ºé™·æ¨™è¨˜åˆªé™¤æŒ‰éˆ•
        if (!e.target.closest('.defect-mark-dot, .defect-mark-textbox') && !e.target.closest('.defect-mark-delete-btn')) {
            window.logger.log('Hiding defect mark delete buttons due to external click');
            hideAllDefectMarkDeleteButtons();
        }
    });
    
    // æ·»åŠ éµç›¤äº‹ä»¶ç›£è½å™¨ï¼ŒæŒ‰ESCéµæ™‚éš±è—åˆªé™¤æŒ‰éˆ•
    document.addEventListener('keydown', function(e) {
        // Don't interfere with copy/paste operations
        if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'v' || e.key === 'C' || e.key === 'V')) {
            return; // Allow normal copy/paste to work
        }
        
        if (e.key === 'Escape') {
            hideAllDeleteButtons();
            hideAllDefectMarkDeleteButtons();
        }
    });

    // åŒæ­¥æ¨™ç±¤å±¤å°ºå¯¸å‡½æ•¸ - æ–°ç³»çµ±ä¸å†éœ€è¦ï¼Œå› ç‚ºæ¨™ç±¤å±¤å°ºå¯¸åœ¨PDFæ¸²æŸ“æ™‚å·²è¨­ç½®

    // ç¼ºé™·æ¨™è¨˜äº‹ä»¶è™•ç†å‡½æ•¸
    function setupDefectMarkEvents(dotElement, textboxElement, defectMarkData) {
        let isDotDragging = false;
        let isTextboxDragging = false;
        let dotDragStartTimer = null;
        let textboxDragStartTimer = null;
        let dotDragStartData = null;
        let textboxDragStartData = null;
        
        // é›™æ“Šç·¨è¼¯ç¼ºé™·æ¨™è¨˜ - å·²ç§»é™¤ç·¨è¼¯åŠŸèƒ½
        
        // å³éµé¡¯ç¤ºåˆªé™¤æŒ‰éˆ•
        dotElement.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            e.stopPropagation();
            showDefectMarkDeleteButton(defectMarkData.id, e.clientX, e.clientY);
        });
        
        textboxElement.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            e.stopPropagation();
            showDefectMarkDeleteButton(defectMarkData.id, e.clientX, e.clientY);
        });
        
        // åœ“é»æ‹–æ‹½åŠŸèƒ½ - ç§»å‹•æ•´å€‹ç¼ºé™·æ¨™è¨˜
        dotElement.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // è¨˜éŒ„é–‹å§‹çš„é¼ æ¨™ä½ç½®å’Œç¼ºé™·æ¨™è¨˜çš„ç•«å¸ƒåº§æ¨™
            const startMouseX = e.clientX;
            const startMouseY = e.clientY;
            const startCanvasX = defectMarkData.canvasPosition ? defectMarkData.canvasPosition.x : 0;
            const startCanvasY = defectMarkData.canvasPosition ? defectMarkData.canvasPosition.y : 0;
            
            // æ·»åŠ æ‹–æ‹½æº–å‚™ç‹€æ…‹çš„è¦–è¦ºåé¥‹
            dotElement.classList.add('drag-preparing');
            
            // é¡¯ç¤ºæº–å‚™æ‹–æ‹½æç¤º
            showNotification('Hold for 0.3 seconds to start dragging defect mark', 'info');
            
            // è¨­ç½®0.3ç§’å»¶é²ä¾†é–‹å§‹æ‹–æ‹½
            dotDragStartTimer = setTimeout(function() {
                // ç§»é™¤æº–å‚™ç‹€æ…‹ï¼Œé–‹å§‹æ‹–æ‹½
                dotElement.classList.remove('drag-preparing');
                isDotDragging = true;
                dotElement.classList.add('dragging');
                
                // é¡¯ç¤ºæ‹–æ‹½é–‹å§‹æç¤º
                showNotification('Defect mark drag started - you can now move it', 'success');
                
                // æ·»åŠ å…¨åŸŸäº‹ä»¶ç›£è½å™¨
                const onMouseMove = function(e) {
                    if (!isDotDragging) return;
                    
                    // è¨ˆç®—é¼ æ¨™ç§»å‹•çš„è·é›¢ï¼ˆå±å¹•åƒç´ ï¼‰
                    const deltaX = e.clientX - startMouseX;
                    const deltaY = e.clientY - startMouseY;
                    
                    // å°‡åƒç´ ç§»å‹•è·é›¢è½‰æ›ç‚ºç•«å¸ƒåº§æ¨™è·é›¢
                    const canvasDeltaX = deltaX / (window.currentScale || 1);
                    const canvasDeltaY = deltaY / (window.currentScale || 1);
                    
                    // æ›´æ–°ç¼ºé™·æ¨™è¨˜çš„ç•«å¸ƒåº§æ¨™
                    if (!defectMarkData.canvasPosition) {
                        defectMarkData.canvasPosition = { x: 0, y: 0 };
                    }
                    defectMarkData.canvasPosition.x = startCanvasX + canvasDeltaX;
                    defectMarkData.canvasPosition.y = startCanvasY + canvasDeltaY;
                    
                    // ç«‹å³æ›´æ–°ç¼ºé™·æ¨™è¨˜çš„è¦–è¦ºä½ç½®
                    updateDefectMarkPosition(dotElement, textboxElement, 
                        document.querySelector(`.defect-mark-connection[data-defect-mark-id="${defectMarkData.id}"]`), 
                        defectMarkData);
                };
                
                const onMouseUp = function() {
                    isDotDragging = false;
                    dotElement.classList.remove('dragging');
                    saveDefectMarksToStorage();
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }, 300); // 0.3ç§’å»¶é²
            
            // ä¿å­˜æ‹–æ‹½é–‹å§‹æ•¸æ“šï¼Œç”¨æ–¼å–æ¶ˆæ‹–æ‹½
            dotDragStartData = {
                startMouseX: startMouseX,
                startMouseY: startMouseY,
                startCanvasX: startCanvasX,
                startCanvasY: startCanvasY
            };
        });
        
        // æ–‡å­—æ¡†æ‹–æ‹½åŠŸèƒ½ - å–®ç¨ç§»å‹•æ–‡å­—æ¡†
        textboxElement.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // è¨˜éŒ„é–‹å§‹çš„é¼ æ¨™ä½ç½®å’Œæ–‡å­—æ¡†çš„ç•¶å‰ä½ç½®
            const startMouseX = e.clientX;
            const startMouseY = e.clientY;
            // æ³¨æ„ï¼štextboxOffsetX/Y ç¾åœ¨ä»£è¡¨æ–‡å­—æ¡†ä¸­å¿ƒé»ç›¸å°æ–¼åœ“é»ä¸­å¿ƒé»çš„ç•«å¸ƒåº§æ¨™åç§»
            // ä¿®æ­£é è¨­åç§»å€¼ï¼Œé¿å…90åº¦ç§»å‹•æ™‚çš„è·³èºå•é¡Œ
            const startTextboxOffsetX = defectMarkData.textboxOffsetX !== undefined ? defectMarkData.textboxOffsetX : 80;
            const startTextboxOffsetY = defectMarkData.textboxOffsetY !== undefined ? defectMarkData.textboxOffsetY : 40;
            
            // æ·»åŠ æ‹–æ‹½æº–å‚™ç‹€æ…‹çš„è¦–è¦ºåé¥‹
            textboxElement.classList.add('drag-preparing');
            
            // é¡¯ç¤ºæº–å‚™æ‹–æ‹½æç¤º
            showNotification('Hold for 0.3 seconds to start dragging textbox', 'info');
            
            // è¨­ç½®0.3ç§’å»¶é²ä¾†é–‹å§‹æ‹–æ‹½
            textboxDragStartTimer = setTimeout(function() {
                // ç§»é™¤æº–å‚™ç‹€æ…‹ï¼Œé–‹å§‹æ‹–æ‹½
                textboxElement.classList.remove('drag-preparing');
                isTextboxDragging = true;
                textboxElement.classList.add('dragging');
                
                // é¡¯ç¤ºæ‹–æ‹½é–‹å§‹æç¤º
                showNotification('Textbox drag started - you can now move it', 'success');
                
                // æ·»åŠ å…¨åŸŸäº‹ä»¶ç›£è½å™¨
                const onMouseMove = function(e) {
                    if (!isTextboxDragging) return;
                    
                    // è¨ˆç®—é¼ æ¨™ç§»å‹•çš„è·é›¢ï¼ˆå±å¹•åƒç´ ï¼‰
                    const deltaX = e.clientX - startMouseX;
                    const deltaY = e.clientY - startMouseY;
                    
                    // å°‡å±å¹•åƒç´ çš„ç§»å‹•è½‰æ›ç‚ºç•«å¸ƒåº§æ¨™çš„åç§»
                    // é€™æ¨£å¯ä»¥ç¢ºä¿æ–‡å­—æ¡†åœ¨ç¸®æ”¾æ™‚ä¿æŒæ­£ç¢ºçš„ç›¸å°ä½ç½®
                    const canvasDeltaX = deltaX / (window.currentScale || 1);
                    const canvasDeltaY = deltaY / (window.currentScale || 1);
                    
                    // æ›´æ–°æ–‡å­—æ¡†çš„ç•«å¸ƒåº§æ¨™åç§»é‡
                    defectMarkData.textboxOffsetX = startTextboxOffsetX + canvasDeltaX;
                    defectMarkData.textboxOffsetY = startTextboxOffsetY + canvasDeltaY;
                    
                    // ç«‹å³æ›´æ–°ç¼ºé™·æ¨™è¨˜çš„è¦–è¦ºä½ç½®
                    updateDefectMarkPosition(dotElement, textboxElement, 
                        document.querySelector(`.defect-mark-connection[data-defect-mark-id="${defectMarkData.id}"]`), 
                        defectMarkData);
                };
                
                const onMouseUp = function() {
                    isTextboxDragging = false;
                    textboxElement.classList.remove('dragging');
                    saveDefectMarksToStorage();
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }, 300); // 0.3ç§’å»¶é²
            
            // ä¿å­˜æ‹–æ‹½é–‹å§‹æ•¸æ“šï¼Œç”¨æ–¼å–æ¶ˆæ‹–æ‹½
            textboxDragStartData = {
                startMouseX: startMouseX,
                startMouseY: startMouseY,
                startTextboxOffsetX: startTextboxOffsetX,
                startTextboxOffsetY: startTextboxOffsetY
            };
        });
        
        // åœ“é»é¼ æ¨™æŠ¬èµ·æ™‚å–æ¶ˆæ‹–æ‹½é–‹å§‹è¨ˆæ™‚å™¨
        dotElement.addEventListener('mouseup', function(e) {
            if (dotDragStartTimer) {
                clearTimeout(dotDragStartTimer);
                dotDragStartTimer = null;
            }
            if (dotDragStartData) {
                dotDragStartData = null;
            }
            // ç§»é™¤æ‹–æ‹½æº–å‚™ç‹€æ…‹
            dotElement.classList.remove('drag-preparing');
        });
        
        // åœ“é»é¼ æ¨™é›¢é–‹æ™‚å–æ¶ˆæ‹–æ‹½é–‹å§‹è¨ˆæ™‚å™¨
        dotElement.addEventListener('mouseleave', function(e) {
            if (dotDragStartTimer) {
                clearTimeout(dotDragStartTimer);
                dotDragStartTimer = null;
            }
            if (dotDragStartData) {
                dotDragStartData = null;
            }
            // ç§»é™¤æ‹–æ‹½æº–å‚™ç‹€æ…‹
            dotElement.classList.remove('drag-preparing');
        });
        
        // æ–‡å­—æ¡†é¼ æ¨™æŠ¬èµ·æ™‚å–æ¶ˆæ‹–æ‹½é–‹å§‹è¨ˆæ™‚å™¨
        textboxElement.addEventListener('mouseup', function(e) {
            if (textboxDragStartTimer) {
                clearTimeout(textboxDragStartTimer);
                textboxDragStartTimer = null;
            }
            if (textboxDragStartData) {
                textboxDragStartData = null;
            }
            // ç§»é™¤æ‹–æ‹½æº–å‚™ç‹€æ…‹
            textboxElement.classList.remove('drag-preparing');
        });
        
        // æ–‡å­—æ¡†é¼ æ¨™é›¢é–‹æ™‚å–æ¶ˆæ‹–æ‹½é–‹å§‹è¨ˆæ™‚å™¨
        textboxElement.addEventListener('mouseleave', function(e) {
            if (textboxDragStartTimer) {
                clearTimeout(textboxDragStartTimer);
                textboxDragStartTimer = null;
            }
            if (textboxDragStartData) {
                textboxDragStartData = null;
            }
            // ç§»é™¤æ‹–æ‹½æº–å‚™ç‹€æ…‹
            textboxElement.classList.remove('drag-preparing');
        });
    }
    
    // é¡¯ç¤ºç¼ºé™·æ¨™è¨˜åˆªé™¤æŒ‰éˆ•
    function showDefectMarkDeleteButton(defectMarkId, clientX, clientY) {
        // éš±è—æ‰€æœ‰ç¾æœ‰çš„åˆªé™¤æŒ‰éˆ•
        hideAllDefectMarkDeleteButtons();
        
        // å‰µå»ºåˆªé™¤æŒ‰éˆ•
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'defect-mark-delete-btn';
        deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
        deleteBtn.title = `Delete Defect Mark: ${defectMarkId}`;
        deleteBtn.style.position = 'fixed';
        deleteBtn.style.left = clientX + 'px';
        deleteBtn.style.top = (clientY - 40) + 'px'; // é¡¯ç¤ºåœ¨ç´…è‰²åœ“é»ä¸Šæ–¹
        deleteBtn.style.zIndex = '10000';
        
        // æ·»åŠ é»æ“Šäº‹ä»¶
        deleteBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            deleteDefectMark(defectMarkId);
            hideAllDefectMarkDeleteButtons();
        });
        
        // æ·»åŠ åˆ°é é¢
        document.body.appendChild(deleteBtn);
        
        window.logger.log('Defect mark delete button shown for:', defectMarkId);
    }
    
    // éš±è—æ‰€æœ‰ç¼ºé™·æ¨™è¨˜åˆªé™¤æŒ‰éˆ•
    function hideAllDefectMarkDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.defect-mark-delete-btn');
            window.logger.log('hideAllDefectMarkDeleteButtons called. Found delete buttons:', deleteButtons.length);
        deleteButtons.forEach(btn => {
            window.logger.log('Removing defect mark delete button:', btn);
            btn.remove();
        });
    }
    
    // åˆªé™¤ç¼ºé™·æ¨™è¨˜
    function deleteDefectMark(defectMarkId) {
        const index = window.defectMarks.findIndex(d => d.id === defectMarkId);
        if (index >= 0) {
            const defectMark = window.defectMarks[index];
            const defectNo = defectMark.defectNo;
            
            // å¾ç¼ºé™·æ¨™è¨˜æ•¸çµ„ä¸­åˆªé™¤
            window.defectMarks.splice(index, 1);
            saveDefectMarksToStorage();
                                if (typeof window.redrawDefectMarks === 'function') {
                                    window.redrawDefectMarks();
                                }
            
            // åŒæ™‚å¾ defectEntries ä¸­åˆªé™¤å°æ‡‰çš„è¨˜éŒ„
            if (defectNo) {
                const defectEntryIndex = window.defectEntries.findIndex(entry => String(entry.defectNo) === String(defectNo));
                if (defectEntryIndex >= 0) {
                    window.defectEntries.splice(defectEntryIndex, 1);
                    window.logger.log('Deleted corresponding defect entry from defectEntries:', defectNo);
                }
                
                // ä¹Ÿå¾ submittedDefectEntries ä¸­åˆªé™¤
                const submittedDefectEntryIndex = window.submittedDefectEntries.findIndex(entry => String(entry.defectNo) === String(defectNo));
                if (submittedDefectEntryIndex >= 0) {
                    window.submittedDefectEntries.splice(submittedDefectEntryIndex, 1);
                    window.logger.log('Deleted corresponding defect entry from submittedDefectEntries:', defectNo);
                }
            }
            
            // åŒæ™‚æ›´æ–°æ¨™ç±¤ä½ç½®ä»¥ç¢ºä¿åŒæ­¥
if (typeof window.updateAllLabelPositions === 'function') {
        window.updateAllLabelPositions();
    }
            
            // æ›´æ–°æ‰€æœ‰ç¼ºé™·/æ¨™ç±¤è©³ç´°è¡¨æ ¼å®¹å™¨
            if (typeof updateDefectSummaryTable === 'function') {
                if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
                window.logger.log('Defect summary table updated after defect mark deletion');
            }
            if (typeof updateCategoryTablesFromInspectionRecords === 'function') {
                if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}
                window.logger.log('Category tables updated after defect mark deletion');
            }
            
            showNotification('Defect mark deleted successfully!', 'success');
        }
    }

    // Load labels + view from localStorage at startup
    await loadLabelsFromStorage();
    await loadDefectMarksFromStorage();
    loadViewStateFromLocalStorage();
    
    // ç¾åœ¨èª¿ç”¨ä¹‹å‰è·³éçš„å‡½æ•¸
    if (typeof window.redrawLabels === 'function') {
        window.redrawLabels();
    }
    if (typeof window.redrawDefectMarks === 'function') {
        window.redrawDefectMarks();
    }
    
    // èª¿ç”¨å…¨å±€å‡½æ•¸
    if (typeof window.initLabelSizeAdjustment === 'function') {
        window.initLabelSizeAdjustment();
    } else {
        window.logger.log('initLabelSizeAdjustment function not available yet');
    }
    
    if (typeof window.initDefectMarkSizeAdjustment === 'function') {
        window.initDefectMarkSizeAdjustment();
    } else {
        window.logger.log('initDefectMarkSizeAdjustment function not available yet');
    }
    
    // Load label size scale from localStorage
    loadLabelSizeFromLocalStorage();
    
    // Load defect mark size scale from localStorage
    loadDefectMarkSizeFromLocalStorage();
    
    // Note: checkLabelsDataAndShowContent() is called when floor plan overlay is opened,
    // not during page load, since the reminder message is inside the overlay
    
    // Setup initial button event listeners if page is already loaded
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setupOpenPreviousFloorPlanButton();
        if (typeof window.initDefectMarkSizeAdjustment === 'function') {
            window.initDefectMarkSizeAdjustment();
        }
    }

    // File input change event
    if (floorPlanFileInput) {
        floorPlanFileInput.addEventListener('change', async function(e) {
            window.logger.log('PDF file input change event triggered!');
            window.logger.log('Available files:', e.target.files);
            const file = e.target.files[0];
            window.logger.log('Selected file:', file);
            if (file && file.type === 'application/pdf') {
                try {
                    // Show loading
                    uploadFloorPlanBtn.textContent = 'Loading...';
                    uploadFloorPlanBtn.disabled = true;
                    
                    // Load PDF using the centralized function
                    const arrayBuffer = await file.arrayBuffer();
                    await loadPDFFromArrayBuffer(arrayBuffer, file.name);
                    
                    // Reset button text
                    uploadFloorPlanBtn.textContent = 'Choose File';
                    uploadFloorPlanBtn.disabled = false;
                    
                    // PDF rendering is handled in loadPDFFromArrayBuffer
                    // Show viewer
                    floorPlanUploadArea.style.display = 'none';
                    floorPlanViewer.style.display = 'flex';
                    
                    // PDF loading is now complete via loadPDFFromArrayBuffer
                    window.logger.log('PDF loaded successfully via loadPDFFromArrayBuffer');
                    
                } catch (error) {
                    window.logger.error('Error loading PDF:', error);
                    alert('Error loading PDF file. Please try again.');
                    uploadFloorPlanBtn.textContent = 'Choose File';
                    uploadFloorPlanBtn.disabled = false;
                }
            } else {
                alert('Please select a valid PDF file.');
            }
        });
    }
    
    // Function to check labels data and show appropriate content
    async function checkLabelsDataAndShowContent() {
        window.logger.log('checkLabelsDataAndShowContent called');
        
        // ç¢ºä¿ skipDefectMarksLoad æ¨™èªŒç‚º falseï¼Œå…è¨±ç¼ºé™·æ¨™è¨˜è¼‰å…¥
        window.skipDefectMarksLoad = false;
        window.logger.log('Reset skipDefectMarksLoad flag to allow defect marks loading');
        
        // Debug: Check all localStorage keys related to floor plan
        window.logger.log('All storage keys:', Object.keys(localStorage));
        window.logger.log('pne_floorplan_labels:', localStorage.getItem('pne_floorplan_labels'));
        window.logger.log('pne_floorplan_defect_marks:', localStorage.getItem('pne_floorplan_defect_marks'));
        window.logger.log('pne_floorplan_filename:', localStorage.getItem('pne_floorplan_filename'));
        window.logger.log('pne_floorplan_data:', localStorage.getItem('pne_floorplan_data'));
        
        // Load labels and defect marks from localStorage first
        // åªæœ‰åœ¨ window.labels ç‚ºç©ºæ™‚æ‰å¾å­˜å„²è¼‰å…¥ï¼Œé¿å…è¦†è“‹å·²è¼‰å…¥çš„æ¨™ç±¤
        if (!window.labels || window.labels.length === 0) {
        await loadLabelsFromStorage();
            window.logger.log('Loaded labels from storage in checkLabelsDataAndShowContent');
        } else {
            window.logger.log('Skipping labels load - already have labels:', window.labels.length);
        }
        
        await loadDefectMarksFromStorage();
        
        window.logger.log('Labels loaded from localStorage:', window.labels);
        window.logger.log('Labels length:', window.labels ? window.labels.length : 'labels is null/undefined');
        
        const labelsDataReminder = document.getElementById('labelsDataReminder');
        const uploadPlaceholder = document.getElementById('uploadPlaceholder');
        const previousFileName = document.getElementById('previousFileName');
        
        window.logger.log('labelsDataReminder element:', labelsDataReminder);
        window.logger.log('uploadPlaceholder element:', uploadPlaceholder);
        
        // Check both labels and defect marks for reminder
        const hasLabels = window.labels && window.labels.length > 0;
        const hasDefectMarks = defectMarks && defectMarks.length > 0;
        window.logger.log('Has labels:', hasLabels, 'Has defect marks:', hasDefectMarks);
        
        if (hasLabels || hasDefectMarks) {
            window.logger.log('Showing reminder message - labels found:', window.labels.length, 'defect marks found:', defectMarks.length);
            // Show reminder if there are labels
            if (labelsDataReminder) labelsDataReminder.style.display = 'block';
            if (uploadPlaceholder) uploadPlaceholder.style.display = 'none';
            
            // Try to get previous file name and data from storage
            const previousFile = localStorage.getItem('pne_floorplan_filename');
            const floorPlanDataStr = localStorage.getItem('pne_floorplan_data');
            
            if (previousFile && previousFileName) {
                previousFileName.textContent = previousFile;
            }
            
            // Display additional file details if available
            const fileDetails = document.getElementById('fileDetails');
            if (fileDetails && floorPlanDataStr) {
                try {
                    const floorPlanData = JSON.parse(floorPlanDataStr);
                    const uploadDate = new Date(floorPlanData.uploadDate).toLocaleDateString();
                    const fileSizeKB = Math.round(floorPlanData.fileSize / 1024);
                    
                    // Get defect marks count - use saved count if available, otherwise get current count
                    let defectMarksCount = floorPlanData.defectMarksCount || 0;
                    if (defectMarksCount === 0) {
                        // Fallback to current count if saved count is not available
                        const currentDefectMarks = localStorage.getItem('pne_floorplan_defect_marks');
                        try {
                            if (currentDefectMarks) {
                                const parsedDefectMarks = JSON.parse(currentDefectMarks);
                                defectMarksCount = Array.isArray(parsedDefectMarks) ? parsedDefectMarks.length : 0;
                            }
                        } catch (e) {
                            window.logger.error('Error parsing defect marks for display:', e);
                        }
                    }
                    
                    fileDetails.innerHTML = `
                        <div>ğŸ“… Uploaded: ${uploadDate}</div>
                        <div>ğŸ“ Dimensions: ${Math.round(floorPlanData.dimensions.width)} Ã— ${Math.round(floorPlanData.dimensions.height)} px</div>
                        <div>ğŸ“„ Pages: ${floorPlanData.pageCount}</div>
                        <div>ğŸ·ï¸ Labels: ${floorPlanData.labelsCount}</div>
                        <div>ğŸ”´ Defect Marks: ${defectMarksCount}</div>
                        <div>ğŸ’¾ Size: ${fileSizeKB} KB</div>
                    `;
                } catch (e) {
                    window.logger.error('Error parsing floor plan data:', e);
                    fileDetails.innerHTML = '<div>âš ï¸ File details unavailable</div>';
                }
            }
            
            // Render labels and defect marks on the canvas if floor plan is already loaded
            const floorPlanCanvas = document.getElementById('floorPlanCanvas');
            if (floorPlanCanvas && floorPlanCanvas.width > 0) {
                // Use setTimeout to ensure the canvas is fully rendered before drawing labels
                setTimeout(() => {
                    if (typeof window.redrawLabels === 'function') {
                        window.redrawLabels();
                    }
                    if (typeof window.redrawDefectMarks === 'function') {
                        window.redrawDefectMarks();
                    }
                    window.logger.log('Rendered existing labels and defect marks on canvas');
                }, 100);
            } else {
                // Canvas not ready yet, but we have labels/defect marks data
                // This means we need to render them when PDF is loaded
                window.logger.log('Canvas not ready yet, will render labels/defect marks when PDF loads');
            }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰å¾…æ¸²æŸ“çš„æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜ï¼ˆä¾†è‡ªé é¢é‡æ–°è¼‰å…¥ï¼‰
            if (window.pendingLabelsRedraw || window.pendingDefectMarksRedraw) {
                window.logger.log('Found pending redraw flags - labels:', window.pendingLabelsRedraw, 'defect marks:', window.pendingDefectMarksRedraw);
                
                // æ¸…é™¤å¾…æ¸²æŸ“æ¨™èªŒ
                if (window.pendingLabelsRedraw) {
                    window.pendingLabelsRedraw = false;
                }
                if (window.pendingDefectMarksRedraw) {
                    window.pendingDefectMarksRedraw = false;
                }
            }
        } else {
            window.logger.log('No labels found, showing normal upload area');
            // Show normal upload area if no labels
            if (labelsDataReminder) labelsDataReminder.style.display = 'none';
            if (uploadPlaceholder) uploadPlaceholder.style.display = 'block';
        }
        
        // Setup the button event listener after content is shown
        setupOpenPreviousFloorPlanButton();
        
        // é‡æ–°è¨­ç½®é›™æ“Šäº‹ä»¶ç›£è½å™¨ï¼Œç¢ºä¿ç¼ºé™·æ¨™è¨˜å‰µå»ºåŠŸèƒ½æ­£å¸¸
        if (typeof setupDoubleClickHandler === 'function') {
            setupDoubleClickHandler();
            window.logger.log('Double-click handler re-initialized for defect mark creation');
        }
    }

    // Add event listener for "Open Previous Floor Plan" button
    function setupOpenPreviousFloorPlanButton() {
        const openPreviousFloorPlanBtn = document.getElementById('openPreviousFloorPlanBtn');
        if (openPreviousFloorPlanBtn) {
            // Remove existing event listeners to avoid duplicates
            openPreviousFloorPlanBtn.replaceWith(openPreviousFloorPlanBtn.cloneNode(true));
            
            // Get the new button reference
            const newOpenPreviousFloorPlanBtn = document.getElementById('openPreviousFloorPlanBtn');
            if (newOpenPreviousFloorPlanBtn) {
                newOpenPreviousFloorPlanBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation(); // Prevent global click handler interference
                    // Trigger file input click to open file dialog
                    if (floorPlanFileInput) {
                            floorPlanFileInput.click();
                    }
                });
            }
        }
    }

    // Handle upload floor plan action from PNE dropdown
    const uploadFloorPlanMenuItem = document.querySelector('.pne-dropdown-item[data-action="uploadfloorplan"]');
    if (uploadFloorPlanMenuItem) {
        uploadFloorPlanMenuItem.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent global click handler interference
            
            // é—œé–‰ä¸‹æ‹‰é¸å–®
            const pneDropdown = document.querySelector('.pne-dropdown');
            if (pneDropdown) {
                pneDropdown.style.display = 'none';
            }
            showFloorPlan();
            checkLabelsDataAndShowContent();
            
            // åˆå§‹åŒ–æ»‘å¡ŠåŠŸèƒ½
            setTimeout(() => {
                if (typeof window.initLabelSizeAdjustment === 'function') {
                    window.initLabelSizeAdjustment();
                }
                if (typeof window.initDefectMarkSizeAdjustment === 'function') {
                    window.initDefectMarkSizeAdjustment();
                }
            }, 100);
        });
    }


    // Clicking thumbnail opens overlay
    const floorplanThumb = document.getElementById('floorplanThumb');
    if (floorplanThumb) {
        floorplanThumb.addEventListener('click', function(e) {
            e.stopPropagation();
            showFloorPlan();
            checkLabelsDataAndShowContent();
            
            // åˆå§‹åŒ–æ»‘å¡ŠåŠŸèƒ½
            setTimeout(() => {
                if (typeof window.initLabelSizeAdjustment === 'function') {
                    window.initLabelSizeAdjustment();
                }
                if (typeof window.initDefectMarkSizeAdjustment === 'function') {
                    window.initDefectMarkSizeAdjustment();
                }
            }, 100);
        });
    }

    // Quick Label Switch functionality
    const quickLabelSwitch = document.getElementById('quickLabelSwitch');
    let quickLabelMode = false;
    let mouseTrackingActive = false;
    
    // Mouse tracking function for quick label instruction
    function updateQuickLabelInstructionPosition(event) {
        if (!mouseTrackingActive) return;
        
        const quickLabelInstruction = document.getElementById('quickLabelInstruction');
        if (quickLabelInstruction && quickLabelInstruction.style.display !== 'none') {
            const offset = 30; // 30px offset from mouse pointer
            const x = event.clientX + offset;
            const y = event.clientY + offset;
            
            quickLabelInstruction.style.left = x + 'px';
            quickLabelInstruction.style.top = y + 'px';
        }
    }
    
    if (quickLabelSwitch) {
        quickLabelSwitch.addEventListener('change', function() {
            quickLabelMode = this.checked;
            window.logger.log('Quick Label mode:', quickLabelMode ? 'ON' : 'OFF');
            
            const floorPlanViewer = document.getElementById('floorPlanViewer');
            const quickLabelInstruction = document.getElementById('quickLabelInstruction');
            
            if (quickLabelMode) {
                showNotification('Quick Label mode enabled - Double click on floor plan to create labels', 'info');
                // è¨­å®šæ»‘é¼ æŒ‡é‡ç‚ºåå­—å½¢
                if (floorPlanViewer) {
                    floorPlanViewer.style.cursor = 'crosshair';
                }
                // é¡¯ç¤ºæŒçºŒæé†’è¨Šæ¯ä¸¦å•Ÿç”¨æ»‘é¼ è¿½è¹¤
                if (quickLabelInstruction) {
                    quickLabelInstruction.style.display = 'block';
                    mouseTrackingActive = true;
                }
            } else {
                showNotification(getText('quickLabelModeDisabled'), 'info');
                // æ¢å¾©é è¨­æ»‘é¼ æŒ‡é‡
                if (floorPlanViewer) {
                    floorPlanViewer.style.cursor = 'grab';
                }
                // éš±è—æé†’è¨Šæ¯ä¸¦åœç”¨æ»‘é¼ è¿½è¹¤
                if (quickLabelInstruction) {
                    quickLabelInstruction.style.display = 'none';
                    mouseTrackingActive = false;
                }
            }
        });
    }
    
    // Add global mouse move listener for quick label instruction tracking
    document.addEventListener('mousemove', updateQuickLabelInstructionPosition);
    
    // Function to setup double-click handler
    function setupDoubleClickHandler() {
        const floorPlanViewer = document.getElementById('floorPlanViewer');
        window.logger.log('Setting up double-click handler on floor plan viewer:', floorPlanViewer);
        if (floorPlanViewer) {
            // Remove any existing listener first
            floorPlanViewer.removeEventListener('dblclick', handleFloorPlanDoubleClick);
            floorPlanViewer.addEventListener('dblclick', handleFloorPlanDoubleClick);
            window.logger.log('Double-click event listener added successfully to floorPlanViewer');
        } else {
            window.logger.error('Floor plan viewer element not found');
        }
    }
    
    // Double-click handler function
    function handleFloorPlanDoubleClick(e) {
        window.logger.log('Double-click event triggered on floor plan content');
            
            // Prevent default double-click behavior
            e.preventDefault();
            e.stopPropagation();
            
            // Get the click position relative to the floor plan viewer
            const floorPlanViewer = document.getElementById('floorPlanViewer');
        if (!floorPlanViewer) {
            window.logger.error('Floor plan viewer not found in double-click handler');
            return;
        }
            
            // Use the same position calculation as the existing label system
            const rect = floorPlanViewer.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            // Convert to canvas coordinates (same as existing system)
            const canvasX = (clickX - (window.translateX || 0)) / (window.currentScale || 1);
            const canvasY = (clickY - (window.translateY || 0)) / (window.currentScale || 1);
            
        // Check if we have pending defect data from defect window
        window.logger.log('Double-click detected, checking for pending defect data:', window.pendingDefectData);
        if (window.pendingDefectData) {
            window.logger.log('Creating defect mark from pending data at:', clickX, clickY);
            createDefectMarkFromPendingData(clickX, clickY, canvasX, canvasY);
            return;
        } else {
            window.logger.log('No pending defect data found, skipping defect mark creation');
        }
        
        // Otherwise, handle quick label creation if in quick label mode
        if (!quickLabelMode) {
            window.logger.log('Quick label mode is disabled, no action taken');
            return;
        }
        
        window.logger.log('Quick label double-click detected at:', e.clientX, e.clientY);
        window.logger.log('Quick label click position relative to viewer:', clickX, clickY);
            window.logger.log('Quick label canvas coordinates:', canvasX, canvasY);
            window.logger.log('Current scale:', window.currentScale, 'Translate:', window.translateX, window.translateY);
            
            // Create quick label with precise positioning
            createQuickLabel(clickX, clickY, canvasX, canvasY);
    }
    
    // Setup double-click handler initially
    setupDoubleClickHandler();
    
    // Function to enter defect mark placement mode
    function enterDefectMarkPlacementMode() {
        window.logger.log('Entering defect mark placement mode...');
        window.logger.log('Current pendingDefectData:', window.pendingDefectData);
        
        // è¨­ç½®å…¨å±€ç¼ºé™·æ¨™è¨˜å‰µå»ºæ¨¡å¼æ¨™èªŒ
        window.isDefectMarkCreationMode = true;
        
        const floorPlanViewer = document.getElementById('floorPlanViewer');
        if (!floorPlanViewer) {
            window.logger.error('Floor plan viewer not found');
            return;
        }
        
        window.logger.log('Floor plan viewer found:', floorPlanViewer);
        
        // Add the creating-defect-mark class for visual feedback
        floorPlanViewer.classList.add('creating-defect-mark');
        window.logger.log('Added creating-defect-mark class');
        window.logger.log('Floor plan viewer classes:', floorPlanViewer.className);
        window.logger.log('Floor plan viewer computed styles:', window.getComputedStyle(floorPlanViewer).cursor);
        
        // è¨­å®šæ»‘é¼ æŒ‡é‡ç‚ºåå­—å½¢
        floorPlanViewer.style.cursor = 'crosshair';
        
        // é¡¯ç¤ºç¼ºé™·æ¨™è¨˜æé†’è¨Šæ¯
        const defectMarkInstruction = document.getElementById('defectMarkInstruction');
        window.logger.log('Looking for defect mark instruction element:', defectMarkInstruction);
        if (defectMarkInstruction) {
            defectMarkInstruction.style.display = 'block';
            window.logger.log('Defect mark instruction displayed successfully');
        } else {
            window.logger.error('Defect mark instruction element not found!');
        }
        
        // Add ESC key listener for cancellation (remove any existing first)
        document.removeEventListener('keydown', handleDefectMarkPlacementEsc);
        document.addEventListener('keydown', handleDefectMarkPlacementEsc);
        window.logger.log('Added ESC key listener');
        
        // Show notification
        if (typeof showNotification === 'function') {
            showNotification('Double-click on the floor plan to place the defect mark (Press ESC to cancel)', 'info');
        }
        
        window.logger.log('Defect mark placement mode activated');
    }
    
    // Function to exit defect mark placement mode
    function exitDefectMarkPlacementMode() {
        window.logger.log('Exiting defect mark placement mode...');
        
        // æ¸…é™¤å…¨å±€ç¼ºé™·æ¨™è¨˜å‰µå»ºæ¨¡å¼æ¨™èªŒ
        window.isDefectMarkCreationMode = false;
        
        const floorPlanViewer = document.getElementById('floorPlanViewer');
        if (floorPlanViewer) {
            floorPlanViewer.classList.remove('creating-defect-mark');
            // æ¢å¾©æ»‘é¼ æŒ‡é‡ç‚ºæŠ“å–æ¨£å¼
            floorPlanViewer.style.cursor = 'grab';
        }
        
        // éš±è—ç¼ºé™·æ¨™è¨˜æé†’è¨Šæ¯
        const defectMarkInstruction = document.getElementById('defectMarkInstruction');
        window.logger.log('Hiding defect mark instruction element:', defectMarkInstruction);
        if (defectMarkInstruction) {
            defectMarkInstruction.style.display = 'none';
            window.logger.log('Defect mark instruction hidden successfully');
        } else {
            window.logger.error('Defect mark instruction element not found when trying to hide!');
        }
        
        // Clear pending data
        window.pendingDefectData = null;
        
        // Enable close button and clear waiting state (in case user cancelled)
        window.isWaitingForDefectMarkPlacement = false;
        const closeBtn = document.getElementById('closeFloorPlanBtn');
        if (closeBtn) {
            closeBtn.disabled = false;
            closeBtn.style.opacity = '1';
            closeBtn.style.cursor = 'pointer';
            closeBtn.title = 'Close';
            window.logger.log('Close button enabled - defect mark placement cancelled');
        }
        
        // Remove ESC key listener
        document.removeEventListener('keydown', handleDefectMarkPlacementEsc);
        
        window.logger.log('Defect mark placement mode deactivated');
    }
    
    // ESC key handler for defect mark placement mode
    function handleDefectMarkPlacementEsc(e) {
        if (e.key === 'Escape') {
            exitDefectMarkPlacementMode();
            if (typeof showNotification === 'function') {
                showNotification('Defect mark placement cancelled', 'info');
            }
        }
    }
    
    // Function to create defect mark from pending data at double-click position
    function createDefectMarkFromPendingData(clickX, clickY, canvasX, canvasY) {
        window.logger.log('Creating defect mark from pending data at click position:', clickX, clickY);
        window.logger.log('Creating defect mark from pending data at canvas position:', canvasX, canvasY);
        window.logger.log('Pending defect data:', window.pendingDefectData);
        
        if (!window.pendingDefectData) {
            window.logger.error('No pending defect data available');
            return;
        }
        
        // Create defect mark data using the pending data from defect window
        const defectMarkData = {
            id: Date.now() + Math.random(),
            defectNo: window.pendingDefectData.defectNo,
            recordDate: window.pendingDefectData.inspectionDate,
            photoNo: window.pendingDefectData.photoNumbers,
            categories: window.pendingDefectData.categories,
            defectType: window.pendingDefectData.defectType,
            x: clickX, // Screen coordinates for display
            y: clickY, // Screen coordinates for display
            canvasPosition: {
                x: canvasX, // Canvas coordinates for precise positioning
                y: canvasY  // Canvas coordinates for precise positioning
            }
        };
        
        // Add to defect marks array
        if (!window.defectMarks) {
            window.defectMarks = [];
        }
        window.defectMarks.push(defectMarkData);
        
        // Save to local storage
        if (typeof saveDefectMarksToStorage === 'function') {
            saveDefectMarksToStorage();
        }
        
        // Re-render defect marks
        if (typeof window.redrawDefectMarks === 'function') {
            window.redrawDefectMarks();
        }
        
        // Also update label positions to ensure they stay synchronized
        if (typeof window.updateAllLabelPositions === 'function') {
            window.updateAllLabelPositions();
        }
        
        // Exit placement mode and clear pending data
        exitDefectMarkPlacementMode();
        
        // Disable crosshair cursor and resume normal cursor
        disableCrosshairCursor();
        
        // Enable close button and clear waiting state
        window.isWaitingForDefectMarkPlacement = false;
        const closeBtn = document.getElementById('closeFloorPlanBtn');
        if (closeBtn) {
            closeBtn.disabled = false;
            closeBtn.style.opacity = '1';
            closeBtn.style.cursor = 'pointer';
            closeBtn.title = 'Close';
            window.logger.log('Close button enabled - defect mark placed successfully');
        }
        
        // Show success notification
        if (typeof showNotification === 'function') {
            showNotification('Defect mark created successfully!', 'success');
        }
        
        window.logger.log('Defect mark created and added to defectMarks array');
    }
    
    // Function to create quick label with precise positioning
    function createQuickLabel(clickX, clickY, canvasX, canvasY) {
        window.logger.log('Creating quick label at click position:', clickX, clickY);
        window.logger.log('Creating quick label at canvas position:', canvasX, canvasY);
        
        // Get next label number
        const nextNumber = getNextLabelNumber();
        
        // Create label data with proper structure (same as existing system)
        const labelData = {
            id: Date.now() + Math.random(),
            inspectionNo: nextNumber.toString(),
            x: clickX, // Screen coordinates
            y: clickY, // Screen coordinates
            baseFontSize: window.labelSizeScale || 24,
            canvasPosition: {
                x: canvasX, // Canvas coordinates for precise positioning
                y: canvasY  // Canvas coordinates for precise positioning
            },
            // Add default properties to match existing label structure
            assignedToRecord: null,
            assignedAt: null,
            inspectionDate: null
        };
        
        // Add to labels array - use window.labels
        if (!window.labels) {
            window.labels = [];
        }
        window.labels.push(labelData);
        window.logger.log('Added label to window.labels array, new count:', window.labels.length);
        
        // Create visual label element
        createQuickLabelElement(labelData);
        
        // Trigger label redraw to ensure proper rendering
        if (typeof window.redrawLabels === 'function') {
            window.redrawLabels();
            window.logger.log('Triggered redrawLabels after quick label creation');
        }
        
        // Save to localStorage
        if (typeof saveLabelsToLocalStorage === 'function') {
            if (typeof window.saveLabelsToStorage === 'function') {
            window.saveLabelsToStorage();
        }
            window.logger.log('Saved quick label to localStorage');
        } else if (typeof window.saveLabelsToStorage === 'function') {
            window.saveLabelsToStorage();
            window.logger.log('Saved quick label to localStorage via window function');
        }
        
        showNotification(`Quick label "${nextNumber}" created`, 'success');
        window.logger.log('Quick label created:', labelData);
    }
    
    // Function to get next label number - Modified to prevent auto-renumbering
    function getNextLabelNumber() {
        // Use the same labels variable as the existing system
        const labelsArray = typeof labels !== 'undefined' ? labels : window.labels;
        
        if (typeof labelsArray === 'undefined' || !Array.isArray(labelsArray)) {
            window.logger.log('No existing labels found, starting with number 1');
            return 1;
        }
        
        // Find the highest number in existing labels
        let maxNumber = 0;
        labelsArray.forEach(label => {
            const number = parseInt(label.inspectionNo);
            if (!isNaN(number) && number > maxNumber) {
                maxNumber = number;
            }
        });
        
        const nextNumber = maxNumber + 1;
        window.logger.log('Next label number:', nextNumber, 'from', labelsArray.length, 'existing labels');
        return nextNumber;
    }
    
    // Function to get next available label number (for manual assignment)
    function getNextAvailableLabelNumber() {
        const labelsArray = typeof labels !== 'undefined' ? labels : window.labels;
        
        if (typeof labelsArray === 'undefined' || !Array.isArray(labelsArray)) {
            return 1;
        }
        
        // Find the highest number in existing labels
        let maxNumber = 0;
        labelsArray.forEach(label => {
            const number = parseInt(label.inspectionNo);
            if (!isNaN(number) && number > maxNumber) {
                maxNumber = number;
            }
        });
        
        return maxNumber + 1;
    }
    
    // Function to create quick label - use existing label system
    function createQuickLabelElement(labelData) {
        window.logger.log('Creating quick label element for:', labelData);
        
        // Use the existing createLabelElement function if available
        if (typeof createLabelElement === 'function') {
            const labelElement = createLabelElement(labelData);
            window.logger.log('Created label element using existing function:', labelElement);
            return labelElement;
        }
        
        // Fallback: create basic label element
        const labelLayer = document.getElementById('labelLayer');
        if (!labelLayer) {
            window.logger.error('Label layer not found');
            return null;
        }
        
        const labelElement = document.createElement('div');
        labelElement.className = 'floor-plan-label';
        labelElement.dataset.labelId = labelData.id;
        labelElement.style.position = 'absolute';
        labelElement.style.left = labelData.x + 'px';
        labelElement.style.top = labelData.y + 'px';
        labelElement.style.fontSize = labelData.baseFontSize + 'px';
        labelElement.style.padding = '8px 12px';
        labelElement.style.backgroundColor = '#007EFF';
        labelElement.style.color = 'white';
        labelElement.style.borderRadius = '6px';
        labelElement.style.cursor = 'pointer';
        labelElement.style.zIndex = '1000';
        labelElement.style.pointerEvents = 'auto';
        labelElement.style.transform = 'none';
        labelElement.textContent = labelData.inspectionNo;
        
        // Add click handler for editing
        labelElement.addEventListener('click', function(e) {
            e.stopPropagation();
            // You can add edit functionality here if needed
        });
        
        labelLayer.appendChild(labelElement);
        
        // Update position using the existing position update function
        if (typeof updateSingleLabelPosition === 'function') {
            updateSingleLabelPosition(labelElement, labelData);
            window.logger.log('Updated quick label position using updateSingleLabelPosition');
        }
        
        window.logger.log('Created fallback label element:', labelElement);
        return labelElement;
    }

    // Add Label button
    if (addLabelBtn) {
        addLabelBtn.addEventListener('click', function() {
            // é€²å…¥æ¨™ç±¤å‰µå»ºæ¨¡å¼
            enterLabelCreationMode();
        });
    }
    
    // Add Defect button
    const addDefectBtn = document.getElementById('addDefectBtn');
    if (addDefectBtn) {
        addDefectBtn.addEventListener('click', function() {
            // ç¼ºé™·æ¨™è¨˜å‰µå»ºæ¨¡å¼å·²ç§»é™¤ï¼Œç¾åœ¨ä½¿ç”¨é›™æ“Šå‰µå»º
            showNotification('Please use the defect window to create defects, then double-click on the floor plan to place marks', 'info');
        });
    }
    
    // Zoom to 100% button
    const zoomTo100Btn = document.getElementById('zoomTo100Btn');
    if (zoomTo100Btn) {
        zoomTo100Btn.addEventListener('click', function() {
            // ç¸®æ”¾è‡³100%ä¸¦å±…ä¸­
            zoomTo100AndCenter();
        });
    }
    
    // Close buttons for detail popups
    const closeLabelsDetailBtn = document.getElementById('closeLabelsDetailBtn');
    if (closeLabelsDetailBtn) {
        closeLabelsDetailBtn.addEventListener('click', function() {
            window.logger.log('Closing labels detail popup - saving changes...');
            
            // ä¿å­˜æ¨™ç±¤æ›´æ”¹
            if (typeof saveLabelsChanges === 'function') {
                saveLabelsChanges();
            }
            
            // æ›´æ–°ç›¸é—œè¡¨æ ¼
            if (typeof updateTablesOnLabelChange === 'function') {
                updateTablesOnLabelChange();
            }
            
            // é—œé–‰å½ˆå‡ºè¡¨æ ¼
            const popup = document.getElementById('labelsDetailPopup');
            if (popup) {
                popup.style.display = 'none';
            }
            
            window.logger.log('Labels detail popup closed and changes saved');
        });
    }
    
    const closeDefectsDetailBtn = document.getElementById('closeDefectsDetailBtn');
    if (closeDefectsDetailBtn) {
        closeDefectsDetailBtn.addEventListener('click', function() {
            window.logger.log('Closing defects detail popup - saving changes...');
            
            // ä¿å­˜ç¼ºé™·æ›´æ”¹
            if (typeof saveDefectsChanges === 'function') {
                saveDefectsChanges();
            }
            
            // æ›´æ–°ç›¸é—œè¡¨æ ¼
            if (typeof updateTablesOnDefectChange === 'function') {
                updateTablesOnDefectChange();
            }
            
            // é—œé–‰å½ˆå‡ºè¡¨æ ¼
            const popup = document.getElementById('defectsDetailPopup');
            if (popup) {
                popup.style.display = 'none';
            }
            
            window.logger.log('Defects detail popup closed and changes saved');
        });
    }
    
    // Save buttons removed - changes are saved automatically
    
    // Close popups when clicking outside
    document.addEventListener('click', function(e) {
        const labelsPopup = document.getElementById('labelsDetailPopup');
        const defectsPopup = document.getElementById('defectsDetailPopup');
        
        if (labelsPopup && labelsPopup.style.display === 'flex') {
            if (e.target === labelsPopup) {
                window.logger.log('Closing labels detail popup by clicking outside - saving changes...');
                
                // ä¿å­˜æ¨™ç±¤æ›´æ”¹
                if (typeof saveLabelsChanges === 'function') {
                    saveLabelsChanges();
                }
                
                // æ›´æ–°ç›¸é—œè¡¨æ ¼
                if (typeof updateTablesOnLabelChange === 'function') {
                    updateTablesOnLabelChange();
                }
                
                labelsPopup.style.display = 'none';
                window.logger.log('Labels detail popup closed by outside click and changes saved');
            }
        }
        
        if (defectsPopup && defectsPopup.style.display === 'flex') {
            if (e.target === defectsPopup) {
                window.logger.log('Closing defects detail popup by clicking outside - saving changes...');
                
                // ä¿å­˜ç¼ºé™·æ›´æ”¹
                if (typeof saveDefectsChanges === 'function') {
                    saveDefectsChanges();
                }
                
                // æ›´æ–°ç›¸é—œè¡¨æ ¼
                if (typeof updateTablesOnDefectChange === 'function') {
                    updateTablesOnDefectChange();
                }
                
                defectsPopup.style.display = 'none';
                window.logger.log('Defects detail popup closed by outside click and changes saved');
            }
        }
    });
    
    // ESCéµé—œé–‰è©³ç´°è¡¨æ ¼å½ˆå‡ºçª—å£
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            const labelsPopup = document.getElementById('labelsDetailPopup');
            const defectsPopup = document.getElementById('defectsDetailPopup');
            
            if (labelsPopup && labelsPopup.style.display === 'flex') {
                window.logger.log('Closing labels detail popup by ESC key - saving changes...');
                
                // ä¿å­˜æ¨™ç±¤æ›´æ”¹
                if (typeof saveLabelsChanges === 'function') {
                    saveLabelsChanges();
                }
                
                // æ›´æ–°ç›¸é—œè¡¨æ ¼
                if (typeof updateTablesOnLabelChange === 'function') {
                    updateTablesOnLabelChange();
                }
                
                labelsPopup.style.display = 'none';
                window.logger.log('Labels detail popup closed by ESC key and changes saved');
                e.preventDefault(); // é˜²æ­¢å…¶ä»–ESCéµè™•ç†
            }
            
            if (defectsPopup && defectsPopup.style.display === 'flex') {
                window.logger.log('Closing defects detail popup by ESC key - saving changes...');
                
                // ä¿å­˜ç¼ºé™·æ›´æ”¹
                if (typeof saveDefectsChanges === 'function') {
                    saveDefectsChanges();
                }
                
                // æ›´æ–°ç›¸é—œè¡¨æ ¼
                if (typeof updateTablesOnDefectChange === 'function') {
                    updateTablesOnDefectChange();
                }
                
                defectsPopup.style.display = 'none';
                window.logger.log('Defects detail popup closed by ESC key and changes saved');
                e.preventDefault(); // é˜²æ­¢å…¶ä»–ESCéµè™•ç†
            }
        }
    });
    
    // æ¨™ç±¤å‰µå»ºæ¨¡å¼ç‹€æ…‹
    let isLabelCreationMode = false;
    let pendingLabelData = null;
    
    // ç¼ºé™·æ¨™è¨˜å‰µå»ºæ¨¡å¼ç‹€æ…‹
    let isDefectMarkCreationMode = false;
    let pendingDefectMarkData = null;
    
    
    // é€²å…¥æ¨™ç±¤å‰µå»ºæ¨¡å¼
    function enterLabelCreationMode() {
        if (!floorPlanCanvas) {
            showNotification('Please upload a floor plan first', 'warning');
            return;
        }
        
        // æ‰“é–‹æ¨™ç±¤å‰µå»ºæ¨¡æ…‹æ¡†
        openLabelModal();
        
        // è¨­ç½®å‰µå»ºæŒ‰éˆ•çš„ç‰¹æ®Šè¡Œç‚º
        const createBtn = document.getElementById('labelCreateBtn');
        if (createBtn) {
            createBtn.textContent = 'Create & Place';
            createBtn.onclick = function() {
                // é©—è­‰å¿…å¡«å­—æ®µ - åªéœ€è¦ inspection no.
                const inspectionNo = inputInspectionNo.value.trim();
                
                if (!inspectionNo) {
                    alert('Please fill in Inspection No. before creating the label.');
                    return;
                }
                
                // æª¢æŸ¥é‡è¤‡ä¸¦æ›´æ–°è¦–è¦ºç‹€æ…‹
                const isDuplicate = updateDuplicateStatus(inputInspectionNo, inspectionNo);
                if (isDuplicate) {
                    alert('This Inspection No. already exists in the labels detail table. Please use a different number.');
                    inputInspectionNo.focus();
                    return;
                }
                
                // æº–å‚™æ¨™ç±¤æ•¸æ“š - åªéœ€è¦ inspection no.
                pendingLabelData = {
                    inspectionNo: inspectionNo,
                    baseFontSize: labelSizeScale // è¨­ç½®ç•¶å‰é¸æ“‡çš„æ¨™ç±¤å¤§å°
                };
                
                // é—œé–‰æ¨¡æ…‹æ¡†
                closeLabelModal();
                
                // é€²å…¥æ”¾ç½®æ¨¡å¼
                enterLabelPlacementMode();
            };
        }
    }
    
    // é€²å…¥ç¼ºé™·æ¨™è¨˜å‰µå»ºæ¨¡å¼ - å·²ç§»é™¤ï¼Œç¾åœ¨ä½¿ç”¨é›™æ“Šå‰µå»º
    
    // é€²å…¥æ¨™ç±¤æ”¾ç½®æ¨¡å¼
    function enterLabelPlacementMode() {
        if (!pendingLabelData) return;
        
        isLabelCreationMode = true;
        
        // æ”¹è®Šé¼ æ¨™æŒ‡é‡æ¨£å¼
        if (floorPlanViewer) {
            floorPlanViewer.classList.add('creating-label');
        }
        
        // é¡¯ç¤ºæç¤ºä¿¡æ¯
        showNotification('Click on the floor plan to place the label', 'info');
        
        // æ·»åŠ é»æ“Šäº‹ä»¶ç›£è½å™¨
        floorPlanViewer.addEventListener('click', handleLabelPlacement, { once: true });
        
        // æ·»åŠ ESCéµå–æ¶ˆåŠŸèƒ½
        const escHandler = function(e) {
            if (e.key === 'Escape') {
                cancelLabelPlacement();
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
    }
    
    // é€²å…¥ç¼ºé™·æ¨™è¨˜æ”¾ç½®æ¨¡å¼ - å·²ç§»é™¤ï¼Œä½¿ç”¨æ–°çš„é›™æ“Šå‰µå»ºæ–¹å¼
    
    // è™•ç†æ¨™ç±¤æ”¾ç½®
    function handleLabelPlacement(e) {
        if (!isLabelCreationMode || !pendingLabelData) return;
        
        e.preventDefault();
        e.stopPropagation();
        
        // ç²å–é»æ“Šä½ç½®
        const rect = floorPlanViewer.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        
        // è½‰æ›ç‚ºç•«å¸ƒåº§æ¨™
        const canvasX = (clickX - (window.translateX || 0)) / (window.currentScale || 1);
        const canvasY = (clickY - (window.translateY || 0)) / (window.currentScale || 1);
        
        // å‰µå»ºæ¨™ç±¤æ•¸æ“š
        const labelData = {
            id: Date.now(),
            ...pendingLabelData,
            canvasPosition: { x: canvasX, y: canvasY },
            x: clickX,
            y: clickY,
            baseFontSize: labelSizeScale // è¨­ç½®ç•¶å‰é¸æ“‡çš„æ¨™ç±¤å¤§å°
        };
        
        // æ·»åŠ åˆ°æ¨™ç±¤æ•¸çµ„
        labels.push(labelData);
        
        // ä¿å­˜åˆ°æœ¬åœ°å­˜å„²
        if (typeof window.saveLabelsToStorage === 'function') {
            window.saveLabelsToStorage();
        }
        
        // é‡æ–°æ¸²æŸ“æ¨™ç±¤
        if (typeof window.redrawLabels === 'function') {
            window.redrawLabels();
        }
        
        // é€€å‡ºå‰µå»ºæ¨¡å¼
        exitLabelCreationMode();
        
        // é¡¯ç¤ºæˆåŠŸæ¶ˆæ¯
        showNotification('Label created successfully!', 'success');
    }
    
    // è™•ç†ç¼ºé™·æ¨™è¨˜æ”¾ç½®
    function handleDefectMarkPlacement(e) {
        if (!isDefectMarkCreationMode || !pendingDefectMarkData) return;
        
        e.preventDefault();
        e.stopPropagation();
        
        // ç²å–é»æ“Šä½ç½®
        const rect = floorPlanViewer.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        
        // è½‰æ›ç‚ºç•«å¸ƒåº§æ¨™
        const canvasX = (clickX - (window.translateX || 0)) / (window.currentScale || 1);
        const canvasY = (clickY - (window.translateY || 0)) / (window.currentScale || 1);
        
        // å‰µå»ºç¼ºé™·æ¨™è¨˜æ•¸æ“š
        const defectMarkData = {
            id: Date.now(),
            ...pendingDefectMarkData,
            canvasPosition: { x: canvasX, y: canvasY },
            x: clickX,
            y: clickY,
            textboxOffsetX: 80, // åˆå§‹æ–‡å­—æ¡†ä¸­å¿ƒé»Xåç§»é‡ï¼ˆç›¸å°æ–¼åœ“é»ä¸­å¿ƒçš„ç•«å¸ƒåº§æ¨™ï¼‰
            textboxOffsetY: 40  // åˆå§‹æ–‡å­—æ¡†ä¸­å¿ƒé»Yåç§»é‡ï¼ˆç›¸å°æ–¼åœ“é»ä¸­å¿ƒçš„ç•«å¸ƒåº§æ¨™ï¼‰
        };
        
        // æ·»åŠ åˆ°ç¼ºé™·æ¨™è¨˜æ•¸çµ„
        window.defectMarks.push(defectMarkData);
        
        // ä¿å­˜åˆ°æœ¬åœ°å­˜å„²
        saveDefectMarksToStorage();
        
        // é‡æ–°æ¸²æŸ“ç¼ºé™·æ¨™è¨˜
                                if (typeof window.redrawDefectMarks === 'function') {
                                    window.redrawDefectMarks();
                                }
        
        // åŒæ™‚æ›´æ–°æ¨™ç±¤ä½ç½®ä»¥ç¢ºä¿åŒæ­¥
if (typeof window.updateAllLabelPositions === 'function') {
        window.updateAllLabelPositions();
    }
        
        // é€€å‡ºå‰µå»ºæ¨¡å¼
        exitDefectMarkCreationMode();
        
        // é¡¯ç¤ºæˆåŠŸæ¶ˆæ¯
        showNotification('Defect mark created successfully!', 'success');
    }
    
    // å–æ¶ˆæ¨™ç±¤æ”¾ç½®
    function cancelLabelPlacement() {
        exitLabelCreationMode();
        showNotification('Label creation cancelled', 'info');
    }
    
    // å–æ¶ˆç¼ºé™·æ¨™è¨˜æ”¾ç½®
    function cancelDefectMarkPlacement() {
        exitDefectMarkCreationMode();
        showNotification('Defect mark creation cancelled', 'info');
    }
    
    // é€€å‡ºæ¨™ç±¤å‰µå»ºæ¨¡å¼
    function exitLabelCreationMode() {
        isLabelCreationMode = false;
        pendingLabelData = null;
        
        // æ¢å¾©é¼ æ¨™æŒ‡é‡æ¨£å¼
        if (floorPlanViewer) {
            floorPlanViewer.classList.remove('creating-label');
        }
        
        // ç§»é™¤äº‹ä»¶ç›£è½å™¨
        floorPlanViewer.removeEventListener('click', handleLabelPlacement);
        
        // é‡ç½®å‰µå»ºæŒ‰éˆ•
        const createBtn = document.getElementById('labelCreateBtn');
        if (createBtn) {
            createBtn.textContent = 'Create';
            createBtn.onclick = null;
        }
    }
    
    // é€€å‡ºç¼ºé™·æ¨™è¨˜å‰µå»ºæ¨¡å¼
    function exitDefectMarkCreationMode() {
        isDefectMarkCreationMode = false;
        pendingDefectMarkData = null;
        
        // æ¢å¾©é¼ æ¨™æŒ‡é‡æ¨£å¼
        if (floorPlanViewer) {
            floorPlanViewer.classList.remove('creating-label');
        }
        
        // ç§»é™¤äº‹ä»¶ç›£è½å™¨
        floorPlanViewer.removeEventListener('click', handleDefectMarkPlacement);
        
        // é‡ç½®å‰µå»ºæŒ‰éˆ•
        const createBtn = document.getElementById('defectMarkCreateBtn');
        if (createBtn) {
            createBtn.textContent = 'Create';
            createBtn.onclick = null;
        }
    }
    
    
    // æ›´æ–°æ‰€æœ‰æ¨™ç±¤çš„å¤§å°
    function updateAllLabelSizes() {
        if (!labelLayer) return;
        
        const labelElements = labelLayer.querySelectorAll('.floor-plan-label');
        // ä½¿ç”¨ window.labels è€Œä¸æ˜¯å±€éƒ¨è®Šé‡ labels
        const labelsArray = window.labels || [];
        
        labelElements.forEach(labelElement => {
            const labelId = labelElement.dataset.labelId;
            const labelData = labelsArray.find(l => l.id == labelId);
            
            if (labelData) {
                // æ›´æ–°æ¨™ç±¤æ•¸æ“šä¸­çš„å­—é«”å¤§å°
                labelData.baseFontSize = labelSizeScale;
                // é‡æ–°è¨ˆç®—ç¸®æ”¾å¾Œçš„å­—é«”å¤§å°
                const scaledFontSize = labelSizeScale * (window.currentScale || 1);
                labelElement.style.fontSize = scaledFontSize + 'px';
                
                // é‡æ–°è¨ˆç®—æ¨™ç±¤ä½ç½®ï¼Œç¢ºä¿ä¸­å¿ƒé»ä¿æŒä¸è®Š
                updateSingleLabelPosition(labelElement, labelData);
            }
        });
        
        // ä¿å­˜æ›´æ–°å¾Œçš„æ¨™ç±¤æ•¸æ“š
        if (typeof window.saveLabelsToStorage === 'function') {
            window.saveLabelsToStorage();
        }
    }
    
    // ä¿å­˜æ¨™ç±¤å¤§å°åˆ°æœ¬åœ°å­˜å„²
    function saveLabelSizeToLocalStorage() {
        try {
            localStorage.setItem('pne_label_size_scale', JSON.stringify(labelSizeScale));
        } catch(error) {
            window.logger.error('Error saving label size scale to storage:', error);
        }
    }
    
    // å¾æœ¬åœ°å­˜å„²è¼‰å…¥æ¨™ç±¤å¤§å°
    function loadLabelSizeFromLocalStorage() {
        try {
            const savedScale = localStorage.getItem('pne_label_size_scale');
            if (savedScale) {
                const scale = parseInt(savedScale);
                if (scale >= 5 && scale <= 60) {
                    window.labelSizeScale = scale;
                    window.logger.log('Loaded label size from localStorage:', scale + 'px');
                }
            } else {
                window.logger.log('No saved label size found, using default:', window.labelSizeScale + 'px');
            }
            // ç„¡è«–æ˜¯å¦æœ‰ä¿å­˜çš„å€¼ï¼Œéƒ½å˜—è©¦æ›´æ–°UI
            updateLabelSizeUI();
        } catch(error) {
            window.logger.error('Error loading label size scale from localStorage:', error);
            // å³ä½¿å‡ºéŒ¯ä¹Ÿè¦æ›´æ–°UI
            updateLabelSizeUI();
        }
    }
    
    // æ›´æ–°æ¨™ç±¤å¤§å°UI
    function updateLabelSizeUI() {
        const slider = document.getElementById('labelSizeSlider');
        const valueDisplay = document.getElementById('labelSizeValue');
        if (slider && valueDisplay) {
            slider.value = window.labelSizeScale;
            valueDisplay.textContent = window.labelSizeScale + 'px';
            window.logger.log('Label size UI updated:', window.labelSizeScale + 'px');
        } else {
            window.logger.log('Label size UI elements not found:', { slider: !!slider, valueDisplay: !!valueDisplay });
        }
    }
    
    // æ›´æ–°æ‰€æœ‰ç¼ºé™·æ¨™è¨˜çš„å¤§å°
    function updateAllDefectMarkSizes() {
        if (!labelLayer) return;
        
        const dotElements = labelLayer.querySelectorAll('.defect-mark-dot');
        const textboxElements = labelLayer.querySelectorAll('.defect-mark-textbox');
        
        // å‰µå»ºä¸€å€‹ Map ä¾†é—œè¯åœ“é»å’Œæ–‡å­—æ¡†
        const defectMarkMap = new Map();
        
        dotElements.forEach(dotElement => {
            const defectMarkId = dotElement.dataset.defectMarkId;
            if (defectMarkId) {
                defectMarkMap.set(defectMarkId, { dot: dotElement });
            }
        });
        
        textboxElements.forEach(textboxElement => {
            const defectMarkId = textboxElement.dataset.defectMarkId;
            if (defectMarkId && defectMarkMap.has(defectMarkId)) {
                defectMarkMap.get(defectMarkId).textbox = textboxElement;
            }
        });
        
        // æ›´æ–°æ¯å€‹ç¼ºé™·æ¨™è¨˜çš„å¤§å°å’Œä½ç½®
        defectMarkMap.forEach((elements, defectMarkId) => {
            if (elements.dot && elements.textbox) {
                const defectMarkData = window.defectMarks.find(d => d.id == defectMarkId);
                if (defectMarkData) {
                    // æ‰¾åˆ°é€£æ¥ç·šå…ƒç´ 
                    const connectionElement = labelLayer.querySelector(`.defect-mark-connection[data-defect-mark-id="${defectMarkId}"]`);
                    
                    // é‡æ–°è¨ˆç®—ä½ç½®å’Œå¤§å°ï¼ˆé€™æœƒç¢ºä¿æ–‡å­—æ¡†ä»¥ä¸­å¿ƒé»ç‚ºåŸºæº–ï¼Œä¸¦æ‡‰ç”¨ç¸®æ”¾ï¼‰
                    updateDefectMarkPosition(elements.dot, elements.textbox, connectionElement, defectMarkData);
                }
            }
        });
        
        window.logger.log('All defect mark sizes updated to:', window.defectMarkSizeScale + 'px');
    }
    
    // æ›´æ–°ç¼ºé™·æ¨™è¨˜å¤§å°UI
    function updateDefectMarkSizeUI() {
        const slider = document.getElementById('defectSizeSlider');
        const valueDisplay = document.getElementById('defectSizeValue');
        if (slider && valueDisplay) {
            slider.value = window.defectMarkSizeScale;
            valueDisplay.textContent = window.defectMarkSizeScale + 'px';
            window.logger.log('Defect mark size UI updated:', window.defectMarkSizeScale + 'px');
        } else {
            window.logger.log('Defect mark size UI elements not found:', { slider: !!slider, valueDisplay: !!valueDisplay });
        }
    }
    
    // Floor Plan Menu Button and Dropdown
    const floorPlanMenuBtn = document.getElementById('floorPlanMenuBtn');
    const floorPlanDropdown = document.getElementById('floorPlanDropdown');
    
    if (floorPlanMenuBtn && floorPlanDropdown) {
        // Toggle dropdown when menu button is clicked
        floorPlanMenuBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            floorPlanDropdown.style.display = floorPlanDropdown.style.display === 'none' ? 'block' : 'none';
        });
        
        // Handle dropdown item clicks
        floorPlanDropdown.addEventListener('click', function(e) {
            window.logger.log('Floor plan dropdown clicked, target:', e.target);
            const target = e.target.closest('.floor-plan-dropdown-item');
            window.logger.log('Closest floor-plan-dropdown-item:', target);
            if (target) {
                const action = target.getAttribute('data-action');
                window.logger.log('Action:', action);
                if (action === 'new-floor-plan') {
                    // Check if there are existing labels or defect marks
                    if (window.labels.length > 0 || defectMarks.length > 0) {
                        const message = `You have ${window.labels.length} labels and ${defectMarks.length} defect marks. All labels and defect marks will be cleared after uploading a new floor plan. Do you want to continue?`;
                        if (confirm(message)) {
                            // Trigger file input click
                            const floorPlanFileInput = document.getElementById('floorPlanFileInput');
                            if (floorPlanFileInput) {
                                floorPlanFileInput.click();
                            }
                        }
                    } else {
                        // No existing data, directly trigger file input
                        const floorPlanFileInput = document.getElementById('floorPlanFileInput');
                        if (floorPlanFileInput) {
                            floorPlanFileInput.click();
                        }
                    }
                } else if (action === 'show-details') {
                    // Toggle show details dropdown
                    window.logger.log('Show Details button clicked');
                    const showDetailsDropdown = document.getElementById('showDetailsDropdown');
                    const clearDataDropdown = document.getElementById('clearDataDropdown');
                    
                    if (showDetailsDropdown) {
                        const isVisible = showDetailsDropdown.style.display === 'block';
                        
                        // Close clear data dropdown if it's open
                        if (clearDataDropdown && clearDataDropdown.style.display === 'block') {
                            clearDataDropdown.style.display = 'none';
                            window.logger.log('Clear data dropdown closed due to show details click');
                        }
                        
                        showDetailsDropdown.style.display = isVisible ? 'none' : 'block';
                        window.logger.log('Show details dropdown toggled:', !isVisible ? 'shown' : 'hidden');
                    }
                    // Don't close the main dropdown when toggling show details dropdown
                    e.stopPropagation();
                } else if (action === 'clear-data') {
                    // Toggle clear data dropdown
                    window.logger.log('Clear Data button clicked');
                    const clearDataDropdown = document.getElementById('clearDataDropdown');
                    const showDetailsDropdown = document.getElementById('showDetailsDropdown');
                    
                    if (clearDataDropdown) {
                        const isVisible = clearDataDropdown.style.display === 'block';
                        
                        // Close show details dropdown if it's open
                        if (showDetailsDropdown && showDetailsDropdown.style.display === 'block') {
                            showDetailsDropdown.style.display = 'none';
                            window.logger.log('Show details dropdown closed due to clear data click');
                        }
                        
                        clearDataDropdown.style.display = isVisible ? 'none' : 'block';
                        window.logger.log('Clear data dropdown toggled:', !isVisible ? 'shown' : 'hidden');
                        
                        // Debug positioning
                        if (!isVisible) {
                            const rect = clearDataDropdown.getBoundingClientRect();
                            window.logger.log('Clear data dropdown position:', {
                                top: rect.top,
                                left: rect.left,
                                width: rect.width,
                                height: rect.height,
                                display: clearDataDropdown.style.display
                            });
                        }
                    }
                    // Don't close the main dropdown when toggling clear data dropdown
                    e.stopPropagation();
                    return;
                } else if (action === 'clear-all-labels') {
                    // ä½¿ç”¨æ–°çš„ç¶œåˆæ¸…é™¤å‡½æ•¸ï¼ŒæŒ‰ç…§æŒ‡å®šé †åºåŸ·è¡Œ
                    clearAllLabelsDetailTableRecords();
                } else if (action === 'clear-all-defect-marks') {
                    if (window.defectMarks.length > 0) {
                        if (confirm('Are you sure you want to clear all defect marks? This action cannot be undone.')) {
                            window.defectMarks = [];
                            saveDefectMarksToStorage();
                            if (typeof window.redrawDefectMarks === 'function') {
                                window.redrawDefectMarks();
                            }
                            // åŒæ™‚æ›´æ–°æ¨™ç±¤ä½ç½®ä»¥ç¢ºä¿åŒæ­¥
if (typeof window.updateAllLabelPositions === 'function') {
        window.updateAllLabelPositions();
    }
                            showNotification('All defect marks cleared successfully!', 'success');
                        }
                    } else {
                        showNotification('No defect marks to clear.', 'info');
                    }
                } else if (action === 'clear-all-data') {
                    if (window.labels.length > 0 || window.defectMarks.length > 0) {
                        if (confirm('Are you sure you want to clear ALL data (labels and defect marks)? This action cannot be undone.')) {
                            window.labels = [];
                            window.defectMarks = [];
                            if (typeof window.saveLabelsToStorage === 'function') {
                    window.saveLabelsToStorage();
                }
                            saveDefectMarksToStorage();
                            if (typeof window.redrawLabels === 'function') {
                                window.redrawLabels();
                            }
                            if (typeof window.redrawDefectMarks === 'function') {
                                window.redrawDefectMarks();
                            }
                            
                            // æ›´æ–°æ‰€æœ‰ç¼ºé™·/æ¨™ç±¤è©³ç´°è¡¨æ ¼å®¹å™¨
                            if (typeof updateDefectSummaryTable === 'function') {
                                if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
                                window.logger.log('Defect summary table updated after clearing all data');
                            }
                            if (typeof updateCategoryTablesFromInspectionRecords === 'function') {
                                if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}
                                window.logger.log('Category tables updated after clearing all data');
                            }
                            
                            showNotification('All data cleared successfully!', 'success');
                        }
                    } else {
                        showNotification('No data to clear.', 'info');
                    }
                } else if (action === 'export-to-pdf') {
                    window.logger.log('Export to PDF action triggered');
                    exportFloorPlanAsPDF();
                }
                // Close dropdown after action (except for clear-data and show-details which handle their own closing)
                if (action !== 'clear-data' && action !== 'show-details') {
                    floorPlanDropdown.style.display = 'none';
                }
            }
        });
        
        // Handle clear data dropdown item clicks
        const clearDataDropdown = document.getElementById('clearDataDropdown');
        if (clearDataDropdown) {
            clearDataDropdown.addEventListener('click', function(e) {
                window.logger.log('Clear data dropdown clicked');
                const target = e.target.closest('.clear-data-dropdown-item');
                if (target) {
                    const action = target.getAttribute('data-action');
                    window.logger.log('Clear data action:', action);
                    if (action === 'clear-all-labels') {
                        if (window.labels.length > 0) {
                            if (confirm('Are you sure you want to clear all labels? This action cannot be undone.')) {
                                window.labels = [];
                                if (typeof window.saveLabelsToStorage === 'function') {
                    window.saveLabelsToStorage();
                }
                                if (typeof window.redrawLabels === 'function') {
                                window.redrawLabels();
                            }
                                showNotification('All labels cleared successfully!', 'success');
                            }
                        } else {
                            showNotification('No labels to clear.', 'info');
                        }
                    } else if (action === 'clear-all-defect-marks') {
                        if (defectMarks.length > 0) {
                            if (confirm('Are you sure you want to clear all defect marks? This action cannot be undone.')) {
                                defectMarks = [];
                                saveDefectMarksToStorage();
                                if (typeof window.redrawDefectMarks === 'function') {
                                window.redrawDefectMarks();
                            }
                                // åŒæ™‚æ›´æ–°æ¨™ç±¤ä½ç½®ä»¥ç¢ºä¿åŒæ­¥
if (typeof window.updateAllLabelPositions === 'function') {
        window.updateAllLabelPositions();
    }
                                showNotification('All defect marks cleared successfully!', 'success');
                            }
                        } else {
                            showNotification('No defect marks to clear.', 'info');
                        }
                    } else if (action === 'clear-all-data') {
                        if (window.labels.length > 0 || defectMarks.length > 0) {
                            if (confirm('Are you sure you want to clear ALL data (labels and defect marks)? This action cannot be undone.')) {
                                window.labels = [];
                                window.defectMarks = [];
                                if (typeof window.saveLabelsToStorage === 'function') {
                    window.saveLabelsToStorage();
                }
                                saveDefectMarksToStorage();
                                if (typeof window.redrawLabels === 'function') {
                                window.redrawLabels();
                            }
                                if (typeof window.redrawDefectMarks === 'function') {
                                window.redrawDefectMarks();
                            }
                                
                                // æ›´æ–°æ‰€æœ‰ç¼ºé™·/æ¨™ç±¤è©³ç´°è¡¨æ ¼å®¹å™¨
                                if (typeof updateDefectSummaryTable === 'function') {
                                    if (typeof window.updateDefectSummaryTable === 'function') {
    window.updateDefectSummaryTable();
}
                                    window.logger.log('Defect summary table updated after clearing all data');
                                }
                                if (typeof updateCategoryTablesFromInspectionRecords === 'function') {
                                    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
    window.updateCategoryTablesFromInspectionRecords();
}
                                    window.logger.log('Category tables updated after clearing all data');
                                }
                                
                                showNotification('All data cleared successfully!', 'success');
                            }
                        } else {
                            showNotification('No data to clear.', 'info');
                        }
                    }
                    // Close both dropdowns after action
                    clearDataDropdown.style.display = 'none';
                    floorPlanDropdown.style.display = 'none';
                }
            });
        }
        
        // Handle show details dropdown item clicks
        const showDetailsDropdown = document.getElementById('showDetailsDropdown');
        if (showDetailsDropdown) {
            showDetailsDropdown.addEventListener('click', function(e) {
                window.logger.log('Show details dropdown clicked');
                const target = e.target.closest('.show-details-dropdown-item');
                if (target) {
                    const action = target.getAttribute('data-action');
                    window.logger.log('Show details action:', action);
                    
                    // ç¢ºä¿æ¨“å±¤å¹³é¢åœ–è¦†è“‹å±¤å·²ç¶“é–‹å•Ÿ
                    const floorPlanOverlay = document.getElementById('floorPlanOverlay');
                    if (floorPlanOverlay && floorPlanOverlay.style.display === 'none') {
                        floorPlanOverlay.style.display = 'flex';
                        checkLabelsDataAndShowContent();
                        
                        // åˆå§‹åŒ–æ»‘å¡ŠåŠŸèƒ½
                        setTimeout(() => {
                            if (typeof window.initLabelSizeAdjustment === 'function') {
                                window.initLabelSizeAdjustment();
                            }
                            if (typeof window.initDefectMarkSizeAdjustment === 'function') {
                                window.initDefectMarkSizeAdjustment();
                            }
                        }, 100);
                    }
                    
                    // ç„¶å¾Œé–‹å•Ÿå°æ‡‰çš„è©³ç´°è³‡è¨Šå½ˆçª—
                    setTimeout(() => {
                        if (action === 'all-labels-detail') {
                            showLabelsDetailPopup();
                        } else if (action === 'all-defects-detail') {
                            showDefectsDetailPopup();
                        }
                    }, 200); // ç¨å¾®å»¶é²ä»¥ç¢ºä¿æ¨“å±¤å¹³é¢åœ–å®Œå…¨è¼‰å…¥
                    
                    // Close both dropdowns after action
                    showDetailsDropdown.style.display = 'none';
                    floorPlanDropdown.style.display = 'none';
                }
            });
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!floorPlanMenuBtn.contains(e.target) && !floorPlanDropdown.contains(e.target)) {
                floorPlanDropdown.style.display = 'none';
                if (clearDataDropdown) {
                    clearDataDropdown.style.display = 'none';
                }
                if (showDetailsDropdown) {
                    showDetailsDropdown.style.display = 'none';
                }
            }
        });
    }
    
    // Add event listener for new detail buttons in table headers
    document.addEventListener('click', function(e) {
        const target = e.target.closest('[data-action="all-labels-detail"], [data-action="all-defects-detail"]');
        if (target) {
            const action = target.getAttribute('data-action');
            window.logger.log('Table header detail button clicked:', action);
            
            // å…ˆé–‹å•Ÿæ¨“å±¤å¹³é¢åœ–è¦†è“‹å±¤
            const floorPlanOverlay = document.getElementById('floorPlanOverlay');
            if (floorPlanOverlay) {
                floorPlanOverlay.style.display = 'flex';
                checkLabelsDataAndShowContent();
                
                // åˆå§‹åŒ–æ»‘å¡ŠåŠŸèƒ½
                setTimeout(() => {
                    if (typeof window.initLabelSizeAdjustment === 'function') {
                        window.initLabelSizeAdjustment();
                    }
                    if (typeof window.initDefectMarkSizeAdjustment === 'function') {
                        window.initDefectMarkSizeAdjustment();
                    }
                }, 100);
                
                // ç„¶å¾Œé–‹å•Ÿå°æ‡‰çš„è©³ç´°è³‡è¨Šå½ˆçª—
                setTimeout(() => {
                    if (action === 'all-labels-detail') {
                        showLabelsDetailPopup();
                    } else if (action === 'all-defects-detail') {
                        showDefectsDetailPopup();
                    }
                }, 200); // ç¨å¾®å»¶é²ä»¥ç¢ºä¿æ¨“å±¤å¹³é¢åœ–å®Œå…¨è¼‰å…¥
            }
        }
    });
    
    if (labelCancelBtn) {
        labelCancelBtn.addEventListener('click', function() {
            closeLabelModal();
        });
    }
    
    // Calculate next inspection number function
    function calculateNextInspectionNumber() {
        if (!window.labels || window.labels.length === 0) {
            return 1;
        }
        
        // Get all inspection numbers from existing labels
        const inspectionNumbers = window.labels
            .map(label => {
                const num = parseInt(label.inspectionNo);
                return isNaN(num) ? 0 : num;
            })
            .filter(num => num > 0);
        
        if (inspectionNumbers.length === 0) {
            return 1;
        }
        
        // Find the maximum number and add 1
        const maxNumber = Math.max(...inspectionNumbers);
        return maxNumber + 1;
    }
    
    // Auto number switch functionality removed
    
    // ç¼ºé™·æ¨™è¨˜å–æ¶ˆæŒ‰éˆ•äº‹ä»¶ç›£è½å™¨ - å·²ç§»é™¤æ¨¡æ…‹æ¡†
    
    // ç¼ºé™·æ¨™è¨˜å‰µå»ºæŒ‰éˆ•äº‹ä»¶ç›£è½å™¨ - å·²ç§»é™¤æ¨¡æ…‹æ¡†
    if (labelCreateBtn) {
        labelCreateBtn.addEventListener('click', function() {
            // æª¢æŸ¥æ˜¯å¦åœ¨å‰µå»ºæ¨¡å¼ä¸‹ï¼ˆæŒ‰éˆ•æ–‡å­—ç‚º "Create & Place"ï¼‰
            if (this.textContent === 'Create & Place') {
                // é€™å€‹æƒ…æ³ç”± enterLabelCreationMode ä¸­çš„ onclick è™•ç†
                return;
            }
            
            // é©—è­‰å¿…å¡«å­—æ®µ - åªæœ‰æª¢æŸ¥ç·¨è™Ÿæ˜¯å¿…å¡«çš„
            const inspectionNo = inputInspectionNo.value.trim();
            const floor = inputFloor.value.trim();
            const areaName = inputAreaName.value.trim();
            const roomNo = inputRoomNo.value.trim();
            
            if (!inspectionNo) {
                alert('Please fill in Inspection No. before saving.');
                return;
            }
            
            if (editingLabelId) {
                // ç·¨è¼¯ç¾æœ‰æ¨™ç±¤ - æª¢æŸ¥æ˜¯å¦å·²åˆ†é…
                const labelIndex = window.labels.findIndex(label => label.id === editingLabelId);
                if (labelIndex !== -1) {
                    const currentLabel = window.labels[labelIndex];
                    
                    // å¦‚æœæ¨™ç±¤å·²ç¶“è¢«æäº¤ï¼ˆäº®è—è‰²ï¼‰ï¼Œä¸å…è¨±ä¿å­˜
                    if (currentLabel.submitted) {
                        alert('This label is already submitted and cannot be modified.');
                        return;
                    }
                    
                    // ç·¨è¼¯æœªåˆ†é…çš„æ¨™ç±¤
                    const inspectionDate = inputInspectionDate.value;
                    
                    // æ›´æ–°æ¨™ç±¤æ•¸æ“š
                    window.labels[labelIndex].inspectionNo = inspectionNo;
                    window.labels[labelIndex].floor = floor;
                    window.labels[labelIndex].areaName = areaName;
                    window.labels[labelIndex].roomNo = roomNo;
                    window.labels[labelIndex].inspectionDate = inspectionDate;
                    
                    // ä¿å­˜ä¸¦é‡æ–°æ¸²æŸ“
                    if (typeof window.saveLabelsToStorage === 'function') {
                    window.saveLabelsToStorage();
                }
                    closeLabelModal();
                    // ä¸èª¿ç”¨ redrawLabelsï¼Œé¿å…æ¨™ç±¤è®Šè—è‰²ï¼ˆåªæœ‰æäº¤æ•¸æ“šå¾Œæ‰æ‡‰è©²è®Šè—ï¼‰
                    // if (typeof window.redrawLabels === 'function') {
                    //     window.redrawLabels();
                    // }
                    
                    // åŒæ­¥åˆ° defects detail-table-containerï¼ˆæª¢æŸ¥ç¼ºé™·è¨˜éŒ„çš„è®ŠåŒ–ï¼‰
                    syncLabelsToDefectsDetailTable();
                    
                    // é¡¯ç¤ºæˆåŠŸæ¶ˆæ¯
                    if (typeof showNotification === 'function') {
                        showNotification('Label updated successfully!', 'success');
                    }
                }
            } else {
                // å‰µå»ºæ–°æ¨™ç±¤ï¼ˆç›´æ¥å‰µå»ºåœ¨ä¸­å¿ƒä½ç½®ï¼‰
                const data = {
                    id: Date.now(),
                    inspectionNo: inspectionNo,
                    floor: floor || '', // å¯é¸å­—æ®µï¼Œå¦‚æœç‚ºç©ºå‰‡è¨­ç‚ºç©ºå­—ä¸²
                    areaName: areaName || '', // å¯é¸å­—æ®µï¼Œå¦‚æœç‚ºç©ºå‰‡è¨­ç‚ºç©ºå­—ä¸²
                    roomNo: roomNo || '', // å¯é¸å­—æ®µï¼Œå¦‚æœç‚ºç©ºå‰‡è¨­ç‚ºç©ºå­—ä¸²
                    inspectionDate: '', // æ–°æ¨™ç±¤ä¸éœ€è¦æª¢æŸ¥æ—¥æœŸ
                    baseFontSize: labelSizeScale // è¨­ç½®ç•¶å‰é¸æ“‡çš„æ¨™ç±¤å¤§å°
                };
                // æ–°çš„æ¨™ç±¤å®šä½ç³»çµ±ï¼šä½¿ç”¨ç•«å¸ƒåº§æ¨™ç³»çµ±ï¼ˆPlan.htmlæ–¹æ³•ï¼‰
                    if (floorPlanCanvas) {
                        // å–å¾—PDF canvasçš„å¯¦éš›ä½ç½®å’Œå°ºå¯¸
                        const canvasRect = floorPlanCanvas.getBoundingClientRect();
                        
                        // è¨ˆç®—PDF canvasåœ¨è¦–çª—ä¸­çš„å¯¦éš›ä¸­å¿ƒé»
                        const canvasCenterX = canvasRect.left + canvasRect.width / 2;
                        const canvasCenterY = canvasRect.top + canvasRect.height / 2;
                        
                        // è½‰æ›ç‚ºç•«å¸ƒåº§æ¨™ï¼ˆç›¸å°æ–¼PDFå…§å®¹çš„åŸå§‹ä½ç½®ï¼‰
                    // é€™è£¡æˆ‘å€‘éœ€è¦è¨ˆç®—ç›¸å°æ–¼PDFå…§å®¹çš„åº§æ¨™
                        const canvasX = (canvasCenterX - (window.translateX || 0)) / (window.currentScale || 1);
                        const canvasY = (canvasCenterY - (window.translateY || 0)) / (window.currentScale || 1);
                        
                        // è¨­ç½®ç•«å¸ƒåº§æ¨™
                        data.canvasPosition = { x: canvasX, y: canvasY };
                        
                        // ä¿ç•™èˆŠåº§æ¨™ç³»çµ±ä½œç‚ºå¾Œå‚™
                        data.x = canvasCenterX;
                        data.y = canvasCenterY;
                    } else {
                        // å¾Œå‚™æ–¹æ¡ˆï¼šä½¿ç”¨è¦–å£ä¸­å¿ƒ
                        const rect = floorPlanViewer.getBoundingClientRect();
                        data.x = rect.width / 2;
                        data.y = rect.height / 2;
                        data.canvasPosition = { x: data.x, y: data.y };
                    }
                labels.push(data);
                if (typeof window.saveLabelsToStorage === 'function') {
                    window.saveLabelsToStorage();
                }
                closeLabelModal();
                                if (typeof window.redrawLabels === 'function') {
                                    window.redrawLabels();
                                }
                
                // é¡¯ç¤ºæˆåŠŸæ¶ˆæ¯
                if (typeof showNotification === 'function') {
                    showNotification('Label created successfully!', 'success');
                }
            }
        });
    }

    // ç‚º"Assign to New Record"æŒ‰éˆ•æ·»åŠ äº‹ä»¶ç›£è½å™¨
    const assignToNewRecordBtn = document.getElementById('assignToNewRecordBtn');
    if (assignToNewRecordBtn) {
        assignToNewRecordBtn.addEventListener('click', function() {
            if (!editingLabelId) {
                showNotification('No label is being edited', 'error');
                return;
            }
            
            // ç²å–ç•¶å‰ç·¨è¼¯çš„æ¨™ç±¤æ•¸æ“š
            const currentLabel = window.labels.find(label => label.id === editingLabelId);
            if (!currentLabel) {
                showNotification('Label data not found', 'error');
                return;
            }
            
            // æª¢æŸ¥æ¨™ç±¤æ˜¯å¦å·²ç¶“è¢«æäº¤ï¼ˆäº®è—è‰²ç‹€æ…‹ï¼‰
            if (currentLabel.submitted) {
                showNotification('This label is already submitted and cannot be reassigned', 'error');
                return;
            }
            
            // æª¢æŸ¥æª¢æŸ¥æ—¥æœŸæ˜¯å¦å·²å¡«å¯«
            const inspectionDate = inputInspectionDate ? inputInspectionDate.value.trim() : '';
            if (!inspectionDate) {
                showNotification('Please enter inspection date before saving and assigning to new record', 'warning');
                return;
            }
            
            // å‰µå»ºåŒ…å«ç•¶å‰ modal ä¸­æœ€æ–°æ•¸æ“šçš„ label å°è±¡
            const updatedLabelData = {
                ...currentLabel, // ä¿ç•™åŸæœ‰æ•¸æ“š
                inspectionNo: inputInspectionNo.value.trim(),
                floor: inputFloor.value.trim(),
                areaName: inputAreaName.value.trim(),
                roomNo: inputRoomNo.value.trim(),
                inspectionDate: inspectionDate
            };
            
            window.logger.log('Updated label data for assignment:', updatedLabelData);
            
            // ç›´æ¥åŸ·è¡Œåˆ†é…çµ¦æ–°è¨˜éŒ„çš„é‚è¼¯ï¼Œä½¿ç”¨æ›´æ–°å¾Œçš„æ•¸æ“š
            // ä¸éœ€è¦å…ˆä¿å­˜ï¼Œå› ç‚º assignLabelToNewRecord æœƒè™•ç†ä¿å­˜
            assignLabelToNewRecord(updatedLabelData);
        });
    }

    // é—œé–‰floor-plan-contentçš„å‡½æ•¸
    function closeFloorPlanContent() {
        try {
            // Check if user is waiting to place defect mark
            if (window.isWaitingForDefectMarkPlacement) {
                window.logger.log('Cannot close floor plan content - user must place defect mark first');
                showNotification('Please place the defect mark before closing the floor plan', 'warning');
                return;
            }
            
            const floorPlanOverlay = document.getElementById('floorPlanOverlay');
            if (floorPlanOverlay) {
                floorPlanOverlay.style.zIndex = '-3';
                floorPlanOverlay.style.display = 'flex'; // Keep it in DOM but hidden behind earth tone background
                window.logger.log('Floor plan content closed');
                
                // Reset Quick Label Switch when closing floor plan
                const quickLabelSwitch = document.getElementById('quickLabelSwitch');
                if (quickLabelSwitch) {
                    quickLabelSwitch.checked = false;
                    window.logger.log('Quick Label Switch reset to OFF when closing floor plan content');
                }
                
                // Reset Quick Label mode states
                const floorPlanViewer = document.getElementById('floorPlanViewer');
                const quickLabelInstruction = document.getElementById('quickLabelInstruction');
                if (floorPlanViewer) {
                    floorPlanViewer.style.cursor = 'grab';
                }
                if (quickLabelInstruction) {
                    quickLabelInstruction.style.display = 'none';
                }
                // Reset mouse tracking
                mouseTrackingActive = false;
                
                // Skip photo re-rendering when closing floor plan content to preserve inspection number status
                // Photos will maintain their current status without being overwritten
                console.log('ğŸ” Closing floor plan content - preserving photo status without re-rendering');
            }
        } catch (error) {
            window.logger.error('Error closing floor plan content:', error);
        }
    }


    // å°‡æ¨™ç±¤æ•¸æ“šåˆ†é…åˆ°header-fieldsçš„å‡½æ•¸
    function assignDataToHeaderFields(labelData) {
        try {
            // è¨­ç½®æ¨™è¨˜ï¼šæ¨™é¡Œæ¬„ä½ä¾†è‡ªæ¨™ç±¤åˆ†é…
            isHeaderFromLabelAssignment = true;
            
            // ç²å–header-fieldsä¸­çš„è¼¸å…¥æ¡†
            const locationIdInput = document.getElementById('locationId');
            const inspectionDateInput = document.getElementById('inspectionDate');
            const floorHeaderInput = document.getElementById('floorHeader');
            const areaNameHeaderInput = document.getElementById('areaNameHeader');
            const roomNoInput = document.getElementById('roomNo');
            
            // å¡«å……æ•¸æ“šåˆ°å°æ‡‰çš„header-fields
            if (locationIdInput && labelData.inspectionNo) {
                locationIdInput.value = labelData.inspectionNo;
            }
            
            // æª¢æŸ¥æ—¥æœŸéœ€è¦ç‰¹æ®Šè™•ç†ï¼Œç¢ºä¿å¾ç•¶å‰è¼¸å…¥æ¡†ç²å–æœ€æ–°å€¼
            const currentInspectionDate = inputInspectionDate ? inputInspectionDate.value.trim() : '';
            window.logger.log('assignDataToHeaderFields - Current inspection date from input:', currentInspectionDate);
            window.logger.log('assignDataToHeaderFields - Label data inspection date:', labelData.inspectionDate);
            
            if (inspectionDateInput && currentInspectionDate) {
                inspectionDateInput.value = currentInspectionDate;
                window.logger.log('Inspection date set to header field from input:', currentInspectionDate);
            } else if (inspectionDateInput && labelData.inspectionDate) {
                inspectionDateInput.value = labelData.inspectionDate;
                window.logger.log('Inspection date set to header field from label data:', labelData.inspectionDate);
            } else {
                window.logger.log('No inspection date available to set');
            }
            
            if (floorHeaderInput && labelData.floor) {
                floorHeaderInput.value = labelData.floor;
            }
            
            if (areaNameHeaderInput && labelData.areaName) {
                areaNameHeaderInput.value = labelData.areaName;
            }
            
            if (roomNoInput && labelData.roomNo) {
                roomNoInput.value = labelData.roomNo;
            }
            
            // è‡ªå‹•å‹¾é¸æ‰€æœ‰header-fieldçš„è¤‡é¸æ¡†
            const checkboxes = [
                'locationIdCheck',
                'inspectionDateCheck', 
                'floorHeaderCheck',
                'areaNameHeaderCheck',
                'roomNoCheck'
            ];
            
            checkboxes.forEach(checkboxId => {
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            
            // è§¸ç™¼è¤‡é¸æ¡†changeäº‹ä»¶ä»¥æ›´æ–°SubmitæŒ‰éˆ•ç‹€æ…‹
            checkboxes.forEach(checkboxId => {
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.dispatchEvent(new Event('change'));
                }
            });
            
            window.logger.log('Header fields updated with label data:', {
                inspectionNo: labelData.inspectionNo,
                inspectionDate: labelData.inspectionDate,
                floor: labelData.floor,
                areaName: labelData.areaName,
                roomNo: labelData.roomNo
            });
            
        } catch (error) {
            window.logger.error('Error assigning data to header fields:', error);
        }
    }

    // åˆ†é…æ¨™ç±¤çµ¦æ–°è¨˜éŒ„çš„å‡½æ•¸
    function assignLabelToNewRecord(labelData) {
        try {
            // ç²å–ç•¶å‰æª¢æŸ¥æ—¥æœŸå€¼
            const currentInspectionDate = inputInspectionDate ? inputInspectionDate.value.trim() : '';
            window.logger.log('Current inspection date from input:', currentInspectionDate);
            window.logger.log('Original label data inspection date:', labelData.inspectionDate);
            
            // å‰µå»ºæ–°çš„è¨˜éŒ„æ•¸æ“š
            const newRecord = {
                id: Date.now(),
                inspectionNo: labelData.inspectionNo,
                floor: labelData.floor,
                areaName: labelData.areaName,
                roomNo: labelData.roomNo,
                inspectionDate: currentInspectionDate,
                labelId: labelData.id,
                assignedAt: new Date().toISOString(),
                status: 'assigned'
            };
            
            window.logger.log('New record created:', newRecord);
            
            // é€™è£¡å¯ä»¥æ·»åŠ å°‡è¨˜éŒ„ä¿å­˜åˆ°æ•¸æ“šåº«æˆ–æœ¬åœ°å­˜å„²çš„é‚è¼¯
            // ç›®å‰å…ˆä¿å­˜åˆ°localStorageä½œç‚ºç¤ºä¾‹
            const existingRecords = JSON.parse(localStorage.getItem('pne_assigned_records') || '[]');
            existingRecords.push(newRecord);
            localStorage.setItem('pne_assigned_records', JSON.stringify(existingRecords));
            
            // ä¸æ›´æ–°æ¨™ç±¤ç‹€æ…‹ï¼Œä¿æŒæ¨™ç±¤åŸæ¨£ï¼ˆä¸è¨­ç½®åˆ†é…ç‹€æ…‹ï¼Œä¸æ›´æ–°æª¢æŸ¥æ—¥æœŸï¼‰
            // labelData.assignedToRecord = newRecord.id; // ç§»é™¤é€™è¡Œï¼Œä¸è®“æ¨™ç±¤è®Šè—è‰²
            // labelData.assignedAt = newRecord.assignedAt; // ç§»é™¤é€™è¡Œï¼Œä¸æ›´æ–°åˆ†é…æ™‚é–“
            // labelData.inspectionDate = currentInspectionDate; // ç§»é™¤é€™è¡Œï¼Œä¸æ›´æ–°æª¢æŸ¥æ—¥æœŸ
            // ä¸è¨­ç½® assigned ç‹€æ…‹ï¼Œæ¨™ç±¤ä¿æŒåŸè‰²å’ŒåŸè¨­ç½®
            
            // ç§»é™¤assignedToRecordçš„è¨­ç½®ï¼Œæ¨™ç±¤ä¸å†è®Šè—è‰²
            // æ¨™ç±¤åªæœƒåœ¨submittedç‹€æ…‹æ™‚è®Šç‚ºäº®è—è‰²
            
            // ä¸æ›´æ–° window.labels æ•¸çµ„ä¸­çš„æ¨™ç±¤ï¼Œä¿æŒæ¨™ç±¤åŸæ¨£
            // const labelIndex = window.labels.findIndex(label => label.id === labelData.id);
            // if (labelIndex >= 0) {
            //     window.labels[labelIndex] = labelData;
            // }
            
            window.logger.log('Record created without updating label data:', newRecord);
            
            // ä¸ä¿å­˜æ¨™ç±¤æ•¸æ“šåˆ°localStorageï¼Œä¿æŒæ¨™ç±¤åŸæ¨£
            // saveLabelsToLocalStorage();
            
            // å°‡æ¨™ç±¤æ•¸æ“šåˆ†é…åˆ°header-fieldsä¸­ï¼ˆé€™æ˜¯å¿…è¦çš„åŠŸèƒ½ï¼‰
            assignDataToHeaderFields(labelData);
            
            // é¡¯ç¤ºæˆåŠŸæ¶ˆæ¯
            showNotification(`Label "${labelData.inspectionNo}" successfully saved and assigned to new record!`, 'success');
            
            // é—œé–‰æ¨¡æ…‹æ¡†
            closeLabelModal();
            
            // ä¸é‡æ–°æ¸²æŸ“æ¨™ç±¤ï¼Œä¿æŒæ¨™ç±¤åŸæ¨£
            // if (typeof window.redrawLabels === 'function') {
            //     window.redrawLabels();
            // }
            
            // é—œé–‰floor-plan-content
            closeFloorPlanContent();
            
            // é©—è­‰æ•¸æ“šæ˜¯å¦æ­£ç¢ºä¿å­˜
            window.logger.log('Final verification - Label data after assignment:', {
                id: labelData.id,
                inspectionNo: labelData.inspectionNo,
                inspectionDate: labelData.inspectionDate,
                floor: labelData.floor,
                areaName: labelData.areaName,
                roomNo: labelData.roomNo,
                assignedToRecord: null, // ç§»é™¤assignedToRecordçš„è¨­ç½®
                assignedAt: null // ç§»é™¤assignedAtçš„è¨­ç½®
            });
            
            window.logger.log('Label assigned to new record:', {
                labelData: labelData,
                newRecord: newRecord,
                headerFieldsUpdated: true
            });
            
        } catch (error) {
            window.logger.error('Error assigning label to new record:', error);
            showNotification('Error saving and assigning label to new record', 'error');
        }
    }

    // èˆŠçš„æ¨™ç±¤äº‹ä»¶è™•ç†ä»£ç¢¼å·²ç§»é™¤ï¼Œæ–°ç³»çµ±ä½¿ç”¨DOMå…ƒç´ 
    
    // Export floor plan as PDF blob (for ZIP export)
    async function exportFloorPlanAsPDFBlob() {
        try {
            // æª¢æŸ¥æ˜¯å¦æœ‰PDFæ–‡ä»¶å¼•ç”¨
            const floorPlanData = JSON.parse(localStorage.getItem('pne_floorplan_data') || '{}');
            if (!floorPlanData.fileReference) {
                throw new Error('No PDF file reference found');
            }

            // æª¢æŸ¥æ˜¯å¦æœ‰æ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜
            if ((!labels || labels.length === 0) && (!defectMarks || defectMarks.length === 0)) {
                throw new Error('No labels or defect marks to export');
            }

            // ç²å–åŸå§‹PDFæ–‡ä»¶ï¼ˆéœ€è¦ç”¨æˆ¶é‡æ–°é¸æ“‡ï¼‰
            return new Promise((resolve, reject) => {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'application/pdf';
                fileInput.style.display = 'none';
                document.body.appendChild(fileInput);

                // å…ˆæ·»åŠ äº‹ä»¶ç›£è½å™¨ï¼Œå†è§¸ç™¼é»æ“Š
                fileInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        document.body.removeChild(fileInput);
                        reject(new Error('No file selected'));
                        return;
                    }

                    try {
                        // è®€å–PDFæ–‡ä»¶
                        const arrayBuffer = await file.arrayBuffer();
                        
                        // ä½¿ç”¨pdf-libåŠ è¼‰PDF
                        const { PDFDocument, rgb } = PDFLib;
                        const pdfDoc = await PDFDocument.load(arrayBuffer);
                        const newPdfDoc = await PDFDocument.create();

                        // ç²å–é é¢
                        const pages = pdfDoc.getPages();
                        const [firstPage] = await newPdfDoc.copyPages(pdfDoc, [0]);
                        newPdfDoc.addPage(firstPage);

                        // ç²å–é é¢å°ºå¯¸
                        const { width, height } = firstPage.getSize();
                        
                        // ç²å–Canvaså°ºå¯¸ç”¨æ–¼åæ¨™è½‰æ›
                        // ä½¿ç”¨ CSS å°ºå¯¸è€Œä¸æ˜¯å¯¦éš› canvas å°ºå¯¸ï¼Œå› ç‚ºæ¨™ç±¤ä½ç½®æ˜¯åŸºæ–¼ CSS å°ºå¯¸è¨ˆç®—çš„
                        const canvasWidth = parseFloat(floorPlanCanvas.style.width) || floorPlanCanvas.width;
                        const canvasHeight = parseFloat(floorPlanCanvas.style.height) || floorPlanCanvas.height;

                        // åˆå§‹åŒ–æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜æ•¸çµ„ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
                        if (!window.labels) {
                            window.labels = [];
                        }
                        if (!window.defectMarks) {
                            window.defectMarks = [];
                        }
                        
                        window.logger.log('PDF Export - Labels count:', window.labels.length);
                        window.logger.log('PDF Export - Defect marks count:', window.defectMarks.length);

                        // ç¹ªè£½æ¨™ç±¤åˆ°PDF
                        if (window.labels.length > 0) {
                            window.labels.forEach(label => {
                                // æª¢æŸ¥æ˜¯å¦æœ‰canvasPositionï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨èˆŠåº§æ¨™ç³»çµ±
                                if (!label.canvasPosition && (label.x !== undefined || label.y !== undefined)) {
                                    label.canvasPosition = { x: label.x || 0, y: label.y || 0 };
                                }
                                
                                if (label.canvasPosition) {
                                    window.logger.log('Drawing label:', label.id, 'Canvas position:', label.canvasPosition);
                                    drawLabelOnPDF(firstPage, label, canvasWidth, canvasHeight, width, height);
                                } else {
                                    window.logger.warn('Label missing canvasPosition:', label);
                                }
                            });
                        }

                        // ç¹ªè£½ç¼ºé™·æ¨™è¨˜åˆ°PDF
                        if (window.defectMarks.length > 0) {
                            window.defectMarks.forEach(defectMark => {
                                // æª¢æŸ¥æ˜¯å¦æœ‰canvasPositionï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨èˆŠåº§æ¨™ç³»çµ±
                                if (!defectMark.canvasPosition && (defectMark.x !== undefined || defectMark.y !== undefined)) {
                                    defectMark.canvasPosition = { x: defectMark.x || 0, y: defectMark.y || 0 };
                                }
                                
                                if (defectMark.canvasPosition) {
                                    window.logger.log('Drawing defect mark:', defectMark.id, 'Canvas position:', defectMark.canvasPosition);
                                    drawDefectMarkOnPDF(firstPage, defectMark, canvasWidth, canvasHeight, width, height);
                                } else {
                                    window.logger.warn('Defect mark missing canvasPosition:', defectMark);
                                }
                            });
                        }

                        // ç”ŸæˆPDF blob
                        const pdfBytes = await newPdfDoc.save();
                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        
                        resolve(blob);
                        
                    } catch (error) {
                        window.logger.error('Error generating PDF:', error);
                        reject(error);
                    } finally {
                        document.body.removeChild(fileInput);
                    }
                });

                // åœ¨äº‹ä»¶ç›£è½å™¨æ·»åŠ å®Œæˆå¾Œè§¸ç™¼é»æ“Š
                fileInput.click();
            });

        } catch (error) {
            window.logger.error('Error in exportFloorPlanAsPDFBlob:', error);
            throw error;
        }
    }

    // Export floor plan as PNG blob (for ZIP export) - ä¿ç•™ç”¨æ–¼å‘å¾Œå…¼å®¹
    function exportFloorPlanAsPNG() {
        return new Promise((resolve, reject) => {
            if (!floorPlanCanvas) {
                reject(new Error('No floor plan canvas found'));
                return;
            }
            
            if (labels.length === 0 && defectMarks.length === 0) {
                reject(new Error('No labels or defect marks to export'));
                return;
            }
            
            // First, temporarily hide any modals or overlays that shouldn't be in the export
            const labelModal = document.getElementById('labelModalOverlay');
            const labelModalDisplay = labelModal ? labelModal.style.display : 'none';
            
            if (labelModal) labelModal.style.display = 'none';
            
            // Create a temporary canvas for export at 100% scale
            const exportCanvas = document.createElement('canvas');
            const ctx = exportCanvas.getContext('2d');
            
            // Get the original PDF canvas dimensions
            const originalWidth = floorPlanCanvas.width;
            const originalHeight = floorPlanCanvas.height;
            
            // Set export canvas to original PDF size (100% scale)
            exportCanvas.width = originalWidth;
            exportCanvas.height = originalHeight;
            
            // Draw the PDF content at 100% scale
            ctx.drawImage(floorPlanCanvas, 0, 0, originalWidth, originalHeight);
            
            // Get current view state
            const currentViewScale = window.currentScale || 1;
            const currentTranslateX = window.translateX || 0;
            const currentTranslateY = window.translateY || 0;
            
            // Draw elements in correct layering order: connections first, then dots/textboxes, then labels
            const scaleX = originalWidth / (floorPlanCanvas.style.width ? parseFloat(floorPlanCanvas.style.width) : originalWidth);
            const scaleY = originalHeight / (floorPlanCanvas.style.height ? parseFloat(floorPlanCanvas.style.height) : originalHeight);
            
            // Draw defect mark connections first
            window.defectMarks.forEach(defectMark => {
                if (defectMark.canvasPosition && defectMark.connectionPosition) {
                    ctx.strokeStyle = '#dc3545';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(
                        defectMark.canvasPosition.x * scaleX,
                        defectMark.canvasPosition.y * scaleY
                    );
                    ctx.lineTo(
                        defectMark.connectionPosition.x * scaleX,
                        defectMark.connectionPosition.y * scaleY
                    );
                    ctx.stroke();
                }
            });
            
            // Draw defect mark dots and textboxes
            window.defectMarks.forEach(defectMark => {
                if (defectMark.canvasPosition) {
                    const x = defectMark.canvasPosition.x * scaleX;
                    const y = defectMark.canvasPosition.y * scaleY;
                    
                    // Draw dot
                    ctx.fillStyle = '#dc3545';
                    ctx.beginPath();
                    ctx.arc(x, y, (defectMarkSizeScale || 24) * scaleX / 2, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw textbox if it has content
                    if (defectMark.connectionPosition && defectMark.photoNumbers) {
                        const textX = defectMark.connectionPosition.x * scaleX;
                        const textY = defectMark.connectionPosition.y * scaleY;
                        
                        ctx.fillStyle = 'white';
                        ctx.strokeStyle = '#dc3545';
                        ctx.lineWidth = 1;
                        const textWidth = ctx.measureText(`Photo no.: ${defectMark.photoNumbers}`).width + 16;
                        const textHeight = 20;
                        
                        const borderRadius = 4 * scaleX; // 4px border radius scaled
                        
                        // Draw rounded rectangle background using path
                        ctx.beginPath();
                        ctx.moveTo(textX - textWidth/2 + borderRadius, textY - textHeight/2);
                        ctx.lineTo(textX + textWidth/2 - borderRadius, textY - textHeight/2);
                        ctx.quadraticCurveTo(textX + textWidth/2, textY - textHeight/2, textX + textWidth/2, textY - textHeight/2 + borderRadius);
                        ctx.lineTo(textX + textWidth/2, textY + textHeight/2 - borderRadius);
                        ctx.quadraticCurveTo(textX + textWidth/2, textY + textHeight/2, textX + textWidth/2 - borderRadius, textY + textHeight/2);
                        ctx.lineTo(textX - textWidth/2 + borderRadius, textY + textHeight/2);
                        ctx.quadraticCurveTo(textX - textWidth/2, textY + textHeight/2, textX - textWidth/2, textY + textHeight/2 - borderRadius);
                        ctx.lineTo(textX - textWidth/2, textY - textHeight/2 + borderRadius);
                        ctx.quadraticCurveTo(textX - textWidth/2, textY - textHeight/2, textX - textWidth/2 + borderRadius, textY - textHeight/2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Draw rounded rectangle border
                        ctx.beginPath();
                        ctx.moveTo(textX - textWidth/2 + borderRadius, textY - textHeight/2);
                        ctx.lineTo(textX + textWidth/2 - borderRadius, textY - textHeight/2);
                        ctx.quadraticCurveTo(textX + textWidth/2, textY - textHeight/2, textX + textWidth/2, textY - textHeight/2 + borderRadius);
                        ctx.lineTo(textX + textWidth/2, textY + textHeight/2 - borderRadius);
                        ctx.quadraticCurveTo(textX + textWidth/2, textY + textHeight/2, textX + textWidth/2 - borderRadius, textY + textHeight/2);
                        ctx.lineTo(textX - textWidth/2 + borderRadius, textY + textHeight/2);
                        ctx.quadraticCurveTo(textX - textWidth/2, textY + textHeight/2, textX - textWidth/2, textY + textHeight/2 - borderRadius);
                        ctx.lineTo(textX - textWidth/2, textY - textHeight/2 + borderRadius);
                        ctx.quadraticCurveTo(textX - textWidth/2, textY - textHeight/2, textX - textWidth/2 + borderRadius, textY - textHeight/2);
                        ctx.closePath();
                        ctx.stroke();
                        
                        ctx.fillStyle = '#dc3545';
                        ctx.font = 'bold 11px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(`Photo no.: ${defectMark.photoNumbers}`, textX, textY);
                    }
                }
            });
            
            // Draw labels
            labels.forEach(label => {
                if (label.canvasPosition) {
                    const x = label.canvasPosition.x * scaleX;
                    const y = label.canvasPosition.y * scaleY;
                    
                    // Try to get the actual DOM element for styling
                    const labelElement = document.querySelector(`[data-label-id="${label.id}"]`);
                    if (labelElement) {
                        const computedStyle = window.getComputedStyle(labelElement);
                        const labelFontSize = parseFloat(computedStyle.fontSize) * scaleX;
                        ctx.fillStyle = computedStyle.color;
                        ctx.font = `${computedStyle.fontWeight} ${labelFontSize}px ${computedStyle.fontFamily}`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(label.inspectionNo, x, y);
                    } else {
                        // Fallback if element not found
                        ctx.fillStyle = '#FFBE00';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(label.inspectionNo, x, y);
                    }
                }
            });
            
            // Convert canvas to blob
            exportCanvas.toBlob(function(blob) {
                // Restore modal displays
                if (labelModal) labelModal.style.display = labelModalDisplay;
                
                if (blob) {
                    resolve(blob);
                } else {
                    reject(new Error('Failed to create PNG blob'));
                }
            }, 'image/png');
        });
    }

    // PDFå°å‡ºè¨ºæ–·åŠŸèƒ½
    function diagnosePDFExport() {
        const diagnosis = {
            pdfLibLoaded: typeof PDFLib !== 'undefined',
            floorPlanData: JSON.parse(localStorage.getItem('pne_floorplan_data') || '{}'),
            labelsCount: window.labels ? window.labels.length : 0,
            defectMarksCount: window.defectMarks ? window.defectMarks.length : 0,
            hasBase64Data: !!localStorage.getItem('pne_floorplan_base64'),
            floorPlanCanvas: !!document.getElementById('floorPlanCanvas')
        };
        
        window.logger.log('PDF Export Diagnosis:', diagnosis);
        return diagnosis;
    }
    
    // å…¨åŸŸè¨ºæ–·å‡½æ•¸ï¼Œæ–¹ä¾¿èª¿è©¦
    window.diagnosePDFExport = diagnosePDFExport;

    // Export floor plan as PDF function (for direct download)
    async function exportFloorPlanAsPDF() {
        window.logger.log('exportFloorPlanAsPDF function called');
        
        // å…ˆé€²è¡Œè¨ºæ–·
        const diagnosis = diagnosePDFExport();
        
        try {
            // æª¢æŸ¥æ˜¯å¦æœ‰PDFæ–‡ä»¶å¼•ç”¨
            const floorPlanData = JSON.parse(localStorage.getItem('pne_floorplan_data') || '{}');
            window.logger.log('Floor plan data:', floorPlanData);
            
            // æª¢æŸ¥æ˜¯å¦æœ‰ PDF æ–‡ä»¶å¼•ç”¨æˆ–è€…æœ‰ base64 æ•¸æ“š
            if (!floorPlanData.fileReference && !floorPlanData.hasBase64Data && !floorPlanData.pdfBase64) {
                window.logger.log('No PDF file reference or base64 data found');
                showNotification('è«‹å…ˆä¸Šå‚³PDFæ–‡ä»¶ã€‚è¨ºæ–·ä¿¡æ¯ï¼šPDFLib=' + diagnosis.pdfLibLoaded + ', æ¨™ç±¤=' + diagnosis.labelsCount + ', ç¼ºé™·=' + diagnosis.defectMarksCount, 'error');
                return;
            }

            // åˆå§‹åŒ–æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜æ•¸çµ„ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!window.labels) {
                window.labels = [];
            }
            if (!window.defectMarks) {
                window.defectMarks = [];
            }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰æ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜
            if (window.labels.length === 0 && window.defectMarks.length === 0) {
                showNotification('æ²’æœ‰æ¨™ç±¤æˆ–ç¼ºé™·æ¨™è¨˜éœ€è¦å°å‡º', 'warning');
                return;
            }
            
            window.logger.log('PDF Export - Labels count:', window.labels.length);
            window.logger.log('PDF Export - Defect marks count:', window.defectMarks.length);

            showNotification('æ­£åœ¨æº–å‚™PDFå°å‡º...', 'info');

            // æª¢æŸ¥æ˜¯å¦æœ‰å­˜å„²çš„PDF base64æ•¸æ“š
            const pdfBase64 = localStorage.getItem('pne_floorplan_base64') || floorPlanData.pdfBase64;
            const hasBase64Data = floorPlanData.hasBase64Data || pdfBase64;
            window.logger.log('PDF base64 data found:', pdfBase64 ? 'Yes' : 'No');
            window.logger.log('Has base64 data flag:', hasBase64Data);
            
            if (hasBase64Data && pdfBase64) {
                // å¦‚æœæœ‰ base64 æ•¸æ“šï¼Œç›´æ¥ä½¿ç”¨
                try {
                    // å°‡base64è½‰æ›ç‚ºArrayBuffer
                    const binaryString = atob(pdfBase64);
                    const arrayBuffer = new ArrayBuffer(binaryString.length);
                    const uint8Array = new Uint8Array(arrayBuffer);
                    for (let i = 0; i < binaryString.length; i++) {
                        uint8Array[i] = binaryString.charCodeAt(i);
                    }
                    
                    // æª¢æŸ¥pdf-libæ˜¯å¦å¯ç”¨
                    if (typeof PDFLib === 'undefined') {
                        window.logger.error('PDFLib library not loaded');
                        showNotification('PDFè™•ç†åº«æœªè¼‰å…¥ï¼Œè«‹é‡æ–°æ•´ç†é é¢å¾Œé‡è©¦', 'error');
                        return;
                    }
                    window.logger.log('PDFLib available:', typeof PDFLib);
                    
                    // ä½¿ç”¨pdf-libåŠ è¼‰PDF
                    const { PDFDocument, rgb } = PDFLib;
                    const pdfDoc = await PDFDocument.load(arrayBuffer);
                    const newPdfDoc = await PDFDocument.create();

                    // ç²å–é é¢
                    const pages = pdfDoc.getPages();
                    const [firstPage] = await newPdfDoc.copyPages(pdfDoc, [0]);
                    newPdfDoc.addPage(firstPage);

                    // ç²å–é é¢å°ºå¯¸
                    const { width, height } = firstPage.getSize();
                    
                    // ç²å–Canvaså°ºå¯¸ç”¨æ–¼åæ¨™è½‰æ›
                    // ä½¿ç”¨ CSS å°ºå¯¸ï¼Œå› ç‚º canvasPosition æ˜¯åŸºæ–¼ CSS å°ºå¯¸è¨ˆç®—çš„
                    const canvasWidth = parseFloat(floorPlanCanvas.style.width) || floorPlanCanvas.width / (window.outputScale || 1);
                    const canvasHeight = parseFloat(floorPlanCanvas.style.height) || floorPlanCanvas.height / (window.outputScale || 1);

                    window.logger.log('PDF page size:', width, height);
                    window.logger.log('Canvas size:', canvasWidth, canvasHeight);
                    window.logger.log('Current scale:', window.currentScale, 'Translate:', window.translateX, window.translateY);

                    // åˆå§‹åŒ–æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜æ•¸çµ„ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
                    if (!window.labels) {
                        window.labels = [];
                    }
                    if (!window.defectMarks) {
                        window.defectMarks = [];
                    }
                    
                    window.logger.log('PDF Export - Labels count:', window.labels.length);
                    window.logger.log('PDF Export - Defect marks count:', window.defectMarks.length);

                    // ç¹ªè£½æ¨™ç±¤åˆ°PDF
                    if (window.labels.length > 0) {
                        window.logger.log('Drawing labels:', window.labels.length);
                        for (const label of window.labels) {
                            // æª¢æŸ¥æ˜¯å¦æœ‰canvasPositionï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨èˆŠåº§æ¨™ç³»çµ±
                            if (!label.canvasPosition && (label.x !== undefined || label.y !== undefined)) {
                                label.canvasPosition = { x: label.x || 0, y: label.y || 0 };
                            }
                            
                            if (label.canvasPosition) {
                                window.logger.log('Drawing label:', label.id, 'Canvas position:', label.canvasPosition);
                                await drawLabelOnPDF(firstPage, label, canvasWidth, canvasHeight, width, height);
                            } else {
                                window.logger.warn('Label missing canvasPosition:', label);
                            }
                        }
                    }

                    // ç¹ªè£½ç¼ºé™·æ¨™è¨˜åˆ°PDF
                    if (window.defectMarks.length > 0) {
                        window.logger.log('Drawing defect marks:', window.defectMarks.length);
                        window.defectMarks.forEach(defectMark => {
                            // æª¢æŸ¥æ˜¯å¦æœ‰canvasPositionï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨èˆŠåº§æ¨™ç³»çµ±
                            if (!defectMark.canvasPosition && (defectMark.x !== undefined || defectMark.y !== undefined)) {
                                defectMark.canvasPosition = { x: defectMark.x || 0, y: defectMark.y || 0 };
                            }
                            
                            if (defectMark.canvasPosition) {
                                window.logger.log('Drawing defect mark:', defectMark.id, 'Canvas position:', defectMark.canvasPosition);
                                drawDefectMarkOnPDF(firstPage, defectMark, canvasWidth, canvasHeight, width, height);
                            } else {
                                window.logger.warn('Defect mark missing canvasPosition:', defectMark);
                            }
                        });
                    }

                    // ç”Ÿæˆä¸¦ä¸‹è¼‰PDF
                    window.logger.log('Generating PDF bytes...');
                    const pdfBytes = await newPdfDoc.save();
                    window.logger.log('PDF bytes generated, size:', pdfBytes.length);
                    
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    window.logger.log('PDF blob created, size:', blob.size);
                    
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `annotated-${floorPlanData.filename || 'floorplan'}.pdf`;
                    window.logger.log('Download link created:', link.download);
                    
                    // æ·»åŠ åˆ°DOMä¸¦è§¸ç™¼ä¸‹è¼‰
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    window.logger.log('PDF download triggered successfully');
                    showNotification('å¸¶æ¨™è¨»çš„PDFæ–‡ä»¶å·²ç”Ÿæˆä¸¦ä¸‹è¼‰', 'success');
                    
                } catch (error) {
                    window.logger.error('Error generating PDF from base64:', error);
                    showNotification('ç”ŸæˆPDFæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message + 'ã€‚è«‹æª¢æŸ¥æ§åˆ¶å°ç²å–è©³ç´°ä¿¡æ¯ã€‚', 'error');
                    
                    // æä¾›è¨ºæ–·ä¿¡æ¯
                    const diagnosis = diagnosePDFExport();
                    console.group('PDF Export Error Diagnosis');
                    window.logger.log('Error:', error);
                    window.logger.log('Diagnosis:', diagnosis);
                    window.logger.log('Floor Plan Data:', floorPlanData);
                    console.groupEnd();
                }
            } else {
                // å¦‚æœæ²’æœ‰ base64 æ•¸æ“šï¼Œéœ€è¦ç”¨æˆ¶é‡æ–°é¸æ“‡PDFæ–‡ä»¶
                showNotification('PDFæ–‡ä»¶å…§å®¹æœªæ‰¾åˆ°ï¼Œè«‹é‡æ–°ä¸Šå‚³PDFæ–‡ä»¶ä»¥é€²è¡ŒåŒ¯å‡º', 'warning');
                window.logger.log('No base64 data available, requesting user to re-upload PDF');
                return new Promise((resolve, reject) => {
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'application/pdf';
                    fileInput.style.display = 'none';
                    document.body.appendChild(fileInput);

                    // å…ˆæ·»åŠ äº‹ä»¶ç›£è½å™¨ï¼Œå†è§¸ç™¼é»æ“Š
                    fileInput.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (!file) {
                            document.body.removeChild(fileInput);
                            showNotification('æœªé¸æ“‡PDFæ–‡ä»¶', 'warning');
                            return;
                        }

                        try {
                            // è®€å–PDFæ–‡ä»¶
                            const arrayBuffer = await file.arrayBuffer();
                            
                            // æª¢æŸ¥pdf-libæ˜¯å¦å¯ç”¨
                            if (typeof PDFLib === 'undefined') {
                                window.logger.error('PDFLib library not loaded');
                                showNotification('PDFè™•ç†åº«æœªè¼‰å…¥ï¼Œè«‹é‡æ–°æ•´ç†é é¢å¾Œé‡è©¦', 'error');
                                document.body.removeChild(fileInput);
                                return;
                            }
                            window.logger.log('PDFLib available:', typeof PDFLib);
                            
                            // ä½¿ç”¨pdf-libåŠ è¼‰PDF
                            const { PDFDocument, rgb } = PDFLib;
                            const pdfDoc = await PDFDocument.load(arrayBuffer);
                            const newPdfDoc = await PDFDocument.create();

                            // ç²å–é é¢
                            const pages = pdfDoc.getPages();
                            const [firstPage] = await newPdfDoc.copyPages(pdfDoc, [0]);
                            newPdfDoc.addPage(firstPage);

                            // ç²å–é é¢å°ºå¯¸
                            const { width, height } = firstPage.getSize();
                            
                            // ç²å–Canvaså°ºå¯¸ç”¨æ–¼åæ¨™è½‰æ›
                            // ä½¿ç”¨ CSS å°ºå¯¸è€Œä¸æ˜¯å¯¦éš› canvas å°ºå¯¸ï¼Œå› ç‚ºæ¨™ç±¤ä½ç½®æ˜¯åŸºæ–¼ CSS å°ºå¯¸è¨ˆç®—çš„
                            const canvasWidth = parseFloat(floorPlanCanvas.style.width) || floorPlanCanvas.width;
                            const canvasHeight = parseFloat(floorPlanCanvas.style.height) || floorPlanCanvas.height;

                            window.logger.log('PDF page size:', width, height);
                            window.logger.log('Canvas size:', canvasWidth, canvasHeight);

                            // åˆå§‹åŒ–æ¨™ç±¤å’Œç¼ºé™·æ¨™è¨˜æ•¸çµ„ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
                            if (!window.labels) {
                                window.labels = [];
                            }
                            if (!window.defectMarks) {
                                window.defectMarks = [];
                            }
                            
                            window.logger.log('PDF Export - Labels count:', window.labels.length);
                            window.logger.log('PDF Export - Defect marks count:', window.defectMarks.length);

                            // ç¹ªè£½æ¨™ç±¤åˆ°PDF
                            if (window.labels.length > 0) {
                                window.logger.log('Drawing labels:', window.labels.length);
                                window.labels.forEach(label => {
                                    // æª¢æŸ¥æ˜¯å¦æœ‰canvasPositionï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨èˆŠåº§æ¨™ç³»çµ±
                                    if (!label.canvasPosition && (label.x !== undefined || label.y !== undefined)) {
                                        label.canvasPosition = { x: label.x || 0, y: label.y || 0 };
                                    }
                                    
                                    if (label.canvasPosition) {
                                        window.logger.log('Drawing label:', label.id, 'Canvas position:', label.canvasPosition);
                                        drawLabelOnPDF(firstPage, label, canvasWidth, canvasHeight, width, height);
                                    } else {
                                        window.logger.warn('Label missing canvasPosition:', label);
                                    }
                                });
                            }

                            // ç¹ªè£½ç¼ºé™·æ¨™è¨˜åˆ°PDF
                            if (window.defectMarks.length > 0) {
                                window.logger.log('Drawing defect marks:', window.defectMarks.length);
                                window.defectMarks.forEach(defectMark => {
                                    // æª¢æŸ¥æ˜¯å¦æœ‰canvasPositionï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨èˆŠåº§æ¨™ç³»çµ±
                                    if (!defectMark.canvasPosition && (defectMark.x !== undefined || defectMark.y !== undefined)) {
                                        defectMark.canvasPosition = { x: defectMark.x || 0, y: defectMark.y || 0 };
                                    }
                                    
                                    if (defectMark.canvasPosition) {
                                        window.logger.log('Drawing defect mark:', defectMark.id, 'Canvas position:', defectMark.canvasPosition);
                                        drawDefectMarkOnPDF(firstPage, defectMark, canvasWidth, canvasHeight, width, height);
                                    } else {
                                        window.logger.warn('Defect mark missing canvasPosition:', defectMark);
                                    }
                                });
                            }

                            // ç”Ÿæˆä¸¦ä¸‹è¼‰PDF
                            window.logger.log('Generating PDF bytes...');
                            const pdfBytes = await newPdfDoc.save();
                            window.logger.log('PDF bytes generated, size:', pdfBytes.length);
                            
                            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                            window.logger.log('PDF blob created, size:', blob.size);
                            
                            const link = document.createElement('a');
                            link.href = URL.createObjectURL(blob);
                            link.download = `annotated-${floorPlanData.filename || 'floorplan'}.pdf`;
                            window.logger.log('Download link created:', link.download);
                            
                            // æ·»åŠ åˆ°DOMä¸¦è§¸ç™¼ä¸‹è¼‰
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            
                            window.logger.log('PDF download triggered successfully');
                            showNotification('å¸¶æ¨™è¨»çš„PDFæ–‡ä»¶å·²ç”Ÿæˆä¸¦ä¸‹è¼‰', 'success');
                            resolve();
                            
                        } catch (error) {
                            window.logger.error('Error generating PDF:', error);
                            showNotification('ç”ŸæˆPDFæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
                            reject(error);
                        } finally {
                            document.body.removeChild(fileInput);
                        }
                    });

                    // åœ¨äº‹ä»¶ç›£è½å™¨æ·»åŠ å®Œæˆå¾Œè§¸ç™¼é»æ“Š
                    fileInput.click();
                });
            }

        } catch (error) {
            window.logger.error('Error in exportFloorPlanAsPDF:', error);
            showNotification('å°å‡ºPDFæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
        }
    }

    // Export floor plan as image function (for direct download) - ä¿ç•™ç”¨æ–¼å‘å¾Œå…¼å®¹
    function exportFloorPlanAsImage() {
        if (!floorPlanCanvas) {
            showNotification('Please upload a floor plan first', 'warning');
            return;
        }
        
        if (labels.length === 0 && defectMarks.length === 0) {
            showNotification('No labels or defect marks to export', 'warning');
            return;
        }
        
        showNotification('Preparing export...', 'info');
        
        // Instead of trying to recreate the visual state, let's capture what the user actually sees
        // We'll use html2canvas to capture the entire floor plan viewer with all elements
        
        // First, temporarily hide any modals or overlays that shouldn't be in the export
        const labelModal = document.getElementById('labelModalOverlay');
        const labelModalDisplay = labelModal ? labelModal.style.display : 'none';
        
        if (labelModal) labelModal.style.display = 'none';
        
        // Instead of html2canvas, let's create a comprehensive export that captures the entire floor plan
        // Create a temporary canvas for export at 100% scale
        const exportCanvas = document.createElement('canvas');
        const ctx = exportCanvas.getContext('2d');
        
        // Get the original PDF canvas dimensions
        const originalWidth = floorPlanCanvas.width;
        const originalHeight = floorPlanCanvas.height;
        
        // Set export canvas to original PDF size (100% scale)
        exportCanvas.width = originalWidth;
        exportCanvas.height = originalHeight;
        
        // Draw the PDF content at 100% scale
        ctx.drawImage(floorPlanCanvas, 0, 0, originalWidth, originalHeight);
        
        // Try a different approach: get the actual DOM element positions and convert them
        // Get current view state
        const currentViewScale = window.currentScale || 1;
        const currentTranslateX = window.translateX || 0;
        const currentTranslateY = window.translateY || 0;
        
        window.logger.log('Export debug info:', {
            currentScale: currentViewScale,
            translateX: currentTranslateX,
            translateY: currentTranslateY,
            originalWidth,
            originalHeight,
            labelsCount: labels.length,
            defectMarksCount: defectMarks.length
        });
        
        // Draw elements in correct layering order: connections first, then dots/textboxes, then labels
        
        // Calculate scale factors once for the entire export
        const canvasRect = floorPlanCanvas.getBoundingClientRect();
        const scaleX = originalWidth / canvasRect.width;
        const scaleY = originalHeight / canvasRect.height;
        
        window.logger.log('Export scaling factors:', { scaleX, scaleY, canvasRect: { width: canvasRect.width, height: canvasRect.height } });
        
        // First, collect all positions for proper layering
        const elementsToDraw = [];
        
        // Collect defect mark positions
        window.defectMarks.forEach(defect => {
            const defectElement = document.querySelector(`[data-defect-mark-id="${defect.id}"]`);
            if (defectElement) {
                const rect = defectElement.getBoundingClientRect();
                
                const relativeX = rect.left + rect.width / 2 - canvasRect.left;
                const relativeY = rect.top + rect.height / 2 - canvasRect.top;
                
                const x = relativeX * scaleX;
                const y = relativeY * scaleY;
                
                // Find textbox element
                const textboxElement = document.querySelector(`.defect-mark-textbox[data-defect-mark-id="${defect.id}"]`);
                if (textboxElement) {
                    const textboxRect = textboxElement.getBoundingClientRect();
                    const textboxRelativeX = textboxRect.left + textboxRect.width / 2 - canvasRect.left;
                    const textboxRelativeY = textboxRect.top + textboxRect.height / 2 - canvasRect.top;
                    const textboxX = textboxRelativeX * scaleX;
                    const textboxY = textboxRelativeY * scaleY;
                    
                    elementsToDraw.push({
                        type: 'connection',
                        x1: x, y1: y, x2: textboxX, y2: textboxY,
                        defect: defect
                    });
                }
                
                elementsToDraw.push({
                    type: 'dot',
                    x: x, y: y,
                    defect: defect
                });
                
                if (textboxElement) {
                    const textboxRect = textboxElement.getBoundingClientRect();
                    const textboxRelativeX = textboxRect.left + textboxRect.width / 2 - canvasRect.left;
                    const textboxRelativeY = textboxRect.top + textboxRect.height / 2 - canvasRect.top;
                    const textboxX = textboxRelativeX * scaleX;
                    const textboxY = textboxRelativeY * scaleY;
                    
                    elementsToDraw.push({
                        type: 'textbox',
                        x: textboxX, y: textboxY,
                        defect: defect
                    });
                }
            }
        });
        
        // Collect label positions
        labels.forEach(label => {
            const labelElement = document.querySelector(`[data-label-id="${label.id}"]`);
            if (labelElement) {
                const rect = labelElement.getBoundingClientRect();
                
                const relativeX = rect.left + rect.width / 2 - canvasRect.left;
                const relativeY = rect.top + rect.height / 2 - canvasRect.top;
                
                const x = relativeX * scaleX;
                const y = relativeY * scaleY;
                
                elementsToDraw.push({
                    type: 'label',
                    x: x, y: y,
                    label: label
                });
            }
        });
        
        // Now draw in correct order: connections first (z-index 999), then dots/textboxes (z-index 1001), then labels (z-index 1000)
        
        // 1. Draw connection lines first (behind everything)
        elementsToDraw.forEach(element => {
            if (element.type === 'connection') {
                ctx.strokeStyle = '#dc3545';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(element.x1, element.y1);
                ctx.lineTo(element.x2, element.y2);
                ctx.stroke();
            }
        });
        
        // 2. Draw defect mark dots
        elementsToDraw.forEach(element => {
            if (element.type === 'dot') {
                // Get the actual DOM element to read computed styles and dimensions
                const defectElement = document.querySelector(`[data-defect-mark-id="${element.defect.id}"]`);
                if (defectElement) {
                    const computedStyle = window.getComputedStyle(defectElement);
                    const rect = defectElement.getBoundingClientRect();
                    
                    window.logger.log('Defect dot computed styles:', {
                        width: computedStyle.width,
                        height: computedStyle.height,
                        fontSize: computedStyle.fontSize,
                        fontWeight: computedStyle.fontWeight,
                        fontFamily: computedStyle.fontFamily,
                        actualSize: { width: rect.width, height: rect.height }
                    });
                    
                    // Use actual computed dimensions and scale them to export canvas resolution
                    const dotSize = (rect.width / 2) * scaleX; // Convert width to radius and scale to PDF resolution
                    
                    // Draw red dot with scaled size
                    ctx.fillStyle = '#dc3545';
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, dotSize, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw defect number with scaled font properties
                    const fontSize = parseFloat(computedStyle.fontSize) * scaleX;
                    ctx.fillStyle = 'white';
                    ctx.font = `${computedStyle.fontWeight} ${fontSize}px ${computedStyle.fontFamily}`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(element.defect.defectNo || '', element.x, element.y);
                } else {
                    // Fallback
                    ctx.fillStyle = '#dc3545';
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, 12, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(element.defect.defectNo || '', element.x, element.y);
                }
            }
        });
        
        // 3. Draw defect mark textboxes
        elementsToDraw.forEach(element => {
            if (element.type === 'textbox') {
                // Get the actual textbox DOM element to read computed styles and dimensions
                const textboxElement = document.querySelector(`.defect-mark-textbox[data-defect-mark-id="${element.defect.id}"]`);
                if (textboxElement) {
                    const computedStyle = window.getComputedStyle(textboxElement);
                    const rect = textboxElement.getBoundingClientRect();
                    
                    window.logger.log('Textbox computed styles:', {
                        width: computedStyle.width,
                        height: computedStyle.height,
                        fontSize: computedStyle.fontSize,
                        fontWeight: computedStyle.fontWeight,
                        fontFamily: computedStyle.fontFamily,
                        padding: computedStyle.padding,
                        border: computedStyle.border,
                        actualSize: { width: rect.width, height: rect.height }
                    });
                    
                    // Use actual computed dimensions and scale them to export canvas resolution
                    const textboxWidth = rect.width * scaleX;
                    const textboxHeight = rect.height * scaleY;
                    
                    // Draw textbox background (white)
                    ctx.fillStyle = 'white';
                    ctx.fillRect(element.x - textboxWidth/2, element.y - textboxHeight/2, textboxWidth, textboxHeight);
                    
                    // Draw textbox border (#dc3545, 1px)
                    ctx.strokeStyle = '#dc3545';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(element.x - textboxWidth/2, element.y - textboxHeight/2, textboxWidth, textboxHeight);
                    
                    // Draw textbox text with scaled font properties
                    const textboxFontSize = parseFloat(computedStyle.fontSize) * scaleX;
                    ctx.fillStyle = '#dc3545';
                    ctx.font = `${computedStyle.fontWeight} ${textboxFontSize}px ${computedStyle.fontFamily}`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Photo no.: ' + (element.defect.photoNo || ''), element.x, element.y);
                } else {
                    // Fallback
                    const textboxWidth = 120;
                    const textboxHeight = 30;
                    
                    ctx.fillStyle = 'white';
                    ctx.fillRect(element.x - textboxWidth/2, element.y - textboxHeight/2, textboxWidth, textboxHeight);
                    
                    ctx.strokeStyle = '#dc3545';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(element.x - textboxWidth/2, element.y - textboxHeight/2, textboxWidth, textboxHeight);
                    
                    ctx.fillStyle = '#dc3545';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Photo no.: ' + (element.defect.photoNo || ''), element.x, element.y);
                }
            }
        });
        
        // 4. Draw labels last (on top)
        elementsToDraw.forEach(element => {
            if (element.type === 'label') {
                // Get the actual computed styles from the DOM element to match exactly
                const labelElement = document.querySelector(`[data-label-id="${element.label.id}"]`);
                if (labelElement) {
                    const computedStyle = window.getComputedStyle(labelElement);
                    const rect = labelElement.getBoundingClientRect();
                    
                    window.logger.log('Label computed styles:', {
                        color: computedStyle.color,
                        fontSize: computedStyle.fontSize,
                        fontWeight: computedStyle.fontWeight,
                        fontFamily: computedStyle.fontFamily,
                        padding: computedStyle.padding,
                        width: computedStyle.width,
                        height: computedStyle.height,
                        actualSize: { width: rect.width, height: rect.height }
                    });
                    
                    // Use the actual computed styles from the DOM with scaled font size
                    const labelFontSize = parseFloat(computedStyle.fontSize) * scaleX;
                    ctx.fillStyle = computedStyle.color;
                    ctx.font = `${computedStyle.fontWeight} ${labelFontSize}px ${computedStyle.fontFamily}`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(element.label.inspectionNo, element.x, element.y);
                } else {
                    // Fallback if element not found
                    ctx.fillStyle = '#FFBE00';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(element.label.inspectionNo, element.x, element.y);
                }
            }
        });
        
        // Convert canvas to blob and download
        exportCanvas.toBlob(function(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'floor_plan_with_annotations.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('Floor plan exported as PNG successfully!', 'success');
        }, 'image/png');
        
        // Restore modal displays
        if (labelModal) labelModal.style.display = labelModalDisplay;
    }
    
    // åˆå§‹åŒ–æ¨™ç±¤å¤§å°èª¿æ•´åŠŸèƒ½
    if (typeof window.initLabelSizeAdjustment === 'function') {
        window.initLabelSizeAdjustment();
    }
    
    // ç¢ºä¿åœ¨é é¢åŠ è¼‰å®Œæˆå¾Œä¹Ÿåˆå§‹åŒ–ä¸€æ¬¡
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            window.logger.log('DOM loaded, initializing label size adjustment');
            if (typeof window.initLabelSizeAdjustment === 'function') {
                window.initLabelSizeAdjustment();
            }
            if (typeof window.initDefectMarkSizeAdjustment === 'function') {
                window.initDefectMarkSizeAdjustment();
            }
            // å»¶é²ä¸€é»æ™‚é–“ç¢ºä¿DOMå®Œå…¨åŠ è¼‰
            setTimeout(updateLabelSizeUI, 100);
            setTimeout(updateDefectMarkSizeUI, 100);
        });
    } else {
        window.logger.log('DOM already loaded, initializing label size adjustment immediately');
        if (typeof window.initLabelSizeAdjustment === 'function') {
            window.initLabelSizeAdjustment();
        }
        if (typeof window.initDefectMarkSizeAdjustment === 'function') {
            window.initDefectMarkSizeAdjustment();
        }
        // å»¶é²ä¸€é»æ™‚é–“ç¢ºä¿DOMå®Œå…¨åŠ è¼‰
        setTimeout(updateLabelSizeUI, 100);
        setTimeout(updateDefectMarkSizeUI, 100);
    }
});
// åŒæ­¥å‡½æ•¸ï¼šå¾ defects detail-table åŒæ­¥åˆ° labels detail-table
function syncDefectToLabelsDetailTable(defectNo) {
    window.logger.log('Syncing defect to labels detail table:', defectNo);
    
    if (!window.labels || !defectNo) {
        window.logger.log('No labels data or defect number provided');
        return;
    }
    
    // æŸ¥æ‰¾åŒ…å«è©²ç¼ºé™·ç·¨è™Ÿçš„æ¨™ç±¤è¨˜éŒ„
    window.labels.forEach((label, labelIndex) => {
        if (label.j && label.j.includes(defectNo)) {
            // å¾ defects column ä¸­ç§»é™¤è©²ç¼ºé™·
            const defectsArray = label.j.split('\n').filter(d => d.trim());
            const updatedDefects = defectsArray.filter(d => !d.includes(defectNo));
            label.j = updatedDefects.join('\n');
            
            window.logger.log(`Updated label ${label.inspectionNo} defects column, removed defect ${defectNo}`);
            
            // ä¿å­˜æ›´æ–°å¾Œçš„æ¨™ç±¤æ•¸æ“š
            if (typeof window.saveLabelsToStorage === 'function') {
                window.saveLabelsToStorage();
            }
        }
    });
}

// åŒæ­¥å‡½æ•¸ï¼šå¾ labels detail-table åŒæ­¥åˆ° defects detail-table
function syncLabelToDefectsDetailTable(labelId) {
    window.logger.log('Syncing label to defects detail table:', labelId);
    
    if (!window.labels || !labelId) {
        window.logger.log('No labels data or label ID provided');
        return;
    }
    
    // æŸ¥æ‰¾è¢«åˆªé™¤çš„æ¨™ç±¤è¨˜éŒ„
    const deletedLabel = window.labels.find(label => String(label.id) === String(labelId));
    
    if (deletedLabel && deletedLabel.j) {
        // å¾è©²æ¨™ç±¤çš„ defects column ä¸­æå–ç¼ºé™·ç·¨è™Ÿ
        const defectsArray = deletedLabel.j.split('\n').filter(d => d.trim());
        
        defectsArray.forEach(defectText => {
            // æå–ç¼ºé™·ç·¨è™Ÿï¼ˆå‡è¨­æ ¼å¼ç‚º "1) Defect description" æˆ– "1-5_Crack"ï¼‰
            const defectNoMatch = defectText.match(/^(\d+)\)?\s*/);
            if (defectNoMatch) {
                const defectNo = defectNoMatch[1];
                
                // å¾ defects detail-table ä¸­åˆªé™¤å°æ‡‰çš„è¨˜éŒ„
                const defectIndex = window.defectEntries.findIndex(entry => 
                    String(entry.defectNo) === String(defectNo)
                );
                
                if (defectIndex >= 0) {
                    window.defectEntries.splice(defectIndex, 1);
                    window.logger.log(`Removed defect ${defectNo} from defects detail table`);
                }
                
                // å¾ submittedDefectEntries ä¸­åˆªé™¤
                const submittedIndex = window.submittedDefectEntries.findIndex(entry => 
                    String(entry.defectNo) === String(defectNo)
                );
                
                if (submittedIndex >= 0) {
                    window.submittedDefectEntries.splice(submittedIndex, 1);
                    window.logger.log(`Removed defect ${defectNo} from submitted defects`);
                }
            }
        });
        
        // ä¿å­˜æ›´æ–°å¾Œçš„ç¼ºé™·æ•¸æ“š
        if (typeof saveDataToStorage === 'function') {
            saveDataToStorage();
        }
    }
}

// åŒæ­¥å‡½æ•¸ï¼šå¾ labels detail-table åŒæ­¥åˆ° defects detail-tableï¼ˆè™•ç†åˆªé™¤å’Œæ›´æ–°æƒ…æ³ï¼‰
function syncLabelsToDefectsDetailTable() {
    window.logger.log('Syncing labels to defects detail table (delete and update case)');
    
    if (!window.labels || !window.defectEntries) {
        window.logger.log('No labels or defects data available');
        return;
    }
    
    // æ”¶é›†æ‰€æœ‰æ¨™ç±¤ä¸­çš„ç¼ºé™·ç·¨è™Ÿå’Œå°æ‡‰çš„æ¨™ç±¤ä¿¡æ¯
    const labelDefectMap = new Map();
    window.labels.forEach(label => {
        // æª¢æŸ¥æ¨™ç±¤çš„ defectNo å­—æ®µ
        if (label.defectNo) {
            const defectNo = String(label.defectNo);
            labelDefectMap.set(defectNo, {
                inspectionNo: label.inspectionNo,
                inspectionDate: label.inspectionDate,
                floor: label.floor,
                areaName: label.areaName,
                roomNo: label.roomNo
                // imminentDanger: label.imminentDanger || false // ç§»é™¤ï¼šä¸å†å¾æ¨™ç±¤æ›´æ–°imminentDanger
            });
        }
        
        // ä¹Ÿæª¢æŸ¥æ¨™ç±¤çš„ç¼ºé™·åˆ— (label.j)
        if (label.j) {
            const defectsArray = label.j.split('\n').filter(d => d.trim());
            defectsArray.forEach(defectText => {
                const defectNoMatch = defectText.match(/^(\d+)\)?\s*/);
                if (defectNoMatch) {
                    const defectNo = defectNoMatch[1];
                    // å­˜å„²æ¨™ç±¤ä¿¡æ¯ï¼Œç”¨æ–¼æ›´æ–°ç¼ºé™·è¨˜éŒ„
                    labelDefectMap.set(defectNo, {
                        inspectionNo: label.inspectionNo,
                        inspectionDate: label.inspectionDate,
                        floor: label.floor,
                        areaName: label.areaName,
                        roomNo: label.roomNo,
                        // imminentDanger: label.imminentDanger || false // ç§»é™¤ï¼šä¸å†å¾æ¨™ç±¤æ›´æ–°imminentDanger
                    });
                }
            });
        }
    });
    
    // æª¢æŸ¥ defects detail-table ä¸­çš„è¨˜éŒ„
    const defectsToRemove = [];
    const defectsToUpdate = [];
    
    window.logger.log('Label defect map:', labelDefectMap);
    window.logger.log('Current defect entries:', window.defectEntries.map(d => d.defectNo));
    
    window.defectEntries.forEach((defect, index) => {
        const defectNo = String(defect.defectNo);
        
        // ä¿®æ”¹ï¼šä¸è¦è‡ªå‹•åˆªé™¤ä¸åœ¨æ¨™ç±¤ä¸­çš„ç¼ºé™·è¨˜éŒ„
        // å› ç‚ºç”¨æˆ¶å¯èƒ½ç›´æ¥åœ¨ detail-table-container ä¸­å‰µå»ºäº†ç¼ºé™·è¨˜éŒ„
        // æˆ–è€…æ¨™ç±¤å¯èƒ½è¢«åˆªé™¤äº†ï¼Œä½†ç¼ºé™·è¨˜éŒ„ä»ç„¶æœ‰æ•ˆ
        if (labelDefectMap.has(defectNo)) {
            // ç¼ºé™·åœ¨æ¨™ç±¤ä¸­ï¼Œæª¢æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°å­—æ®µ
            const labelInfo = labelDefectMap.get(defectNo);
            const needsUpdate = 
                defect.locationId !== labelInfo.inspectionNo ||
                defect.inspectionDate !== labelInfo.inspectionDate ||
                defect.floor !== labelInfo.floor ||
                defect.areaName !== labelInfo.areaName ||
                defect.roomNo !== labelInfo.roomNo;
            
            if (needsUpdate) {
                defectsToUpdate.push({ index, defect, labelInfo });
            }
        }
        // ç§»é™¤è‡ªå‹•åˆªé™¤é‚è¼¯ï¼Œä¿ç•™æ‰€æœ‰ç¼ºé™·è¨˜éŒ„
    });
    
    // æ›´æ–°ç¼ºé™·è¨˜éŒ„çš„å­—æ®µ - åªæœ‰åœ¨æª¢æŸ¥ç·¨è™Ÿç¢ºå¯¦åŒ¹é…æ™‚æ‰æ›´æ–°
    defectsToUpdate.forEach(({ index, defect, labelInfo }) => {
        const originalDefect = { ...defect };
        
        // æª¢æŸ¥ç¼ºé™·è¨˜éŒ„çš„åŸå§‹æª¢æŸ¥ç·¨è™Ÿæ˜¯å¦èˆ‡æ¨™ç±¤çš„æª¢æŸ¥ç·¨è™ŸåŒ¹é…
        const defectInspectionNo = defect.inspectionNo || defect.locationId;
        const labelInspectionNo = labelInfo.inspectionNo;
        
        // åªæœ‰åœ¨æª¢æŸ¥ç·¨è™ŸåŒ¹é…æ™‚æ‰æ›´æ–°å­—æ®µ
        if (String(defectInspectionNo) === String(labelInspectionNo)) {
            // æ›´æ–°ç¼ºé™·è¨˜éŒ„çš„å­—æ®µ
            defect.locationId = labelInfo.inspectionNo;
            defect.inspectionDate = labelInfo.inspectionDate;
            defect.floor = labelInfo.floor;
            defect.areaName = labelInfo.areaName;
            defect.roomNo = labelInfo.roomNo;
            
            window.logger.log(`Updated defect ${defect.defectNo} fields (inspectionNo match):`, {
                inspectionNo: defect.locationId,
                inspectionDate: defect.inspectionDate,
                floor: defect.floor,
                areaName: defect.areaName,
                roomNo: defect.roomNo,
            });
            
            // åŒæ™‚æ›´æ–° submittedDefectEntries ä¸­çš„è¨˜éŒ„
            const submittedIndex = window.submittedDefectEntries.findIndex(entry => 
                String(entry.defectNo) === String(defect.defectNo)
            );
            
            if (submittedIndex >= 0) {
                window.submittedDefectEntries[submittedIndex] = { ...defect };
                window.logger.log(`Updated defect ${defect.defectNo} in submitted defects`);
            }
        } else {
            window.logger.log(`Skipped updating defect ${defect.defectNo} - inspectionNo mismatch: ${defectInspectionNo} vs ${labelInspectionNo}`);
        }
    });
    
    // ç§»é™¤è‡ªå‹•åˆªé™¤é‚è¼¯ï¼Œä¿ç•™æ‰€æœ‰ç¼ºé™·è¨˜éŒ„
    // ç”¨æˆ¶å¯ä»¥æ‰‹å‹•åˆªé™¤ä¸éœ€è¦çš„ç¼ºé™·è¨˜éŒ„
        if (defectsToRemove.length > 0) {
        window.logger.log(`Found ${defectsToRemove.length} defects not in labels, but keeping them (user can manually delete if needed)`);
    }
    
    if (defectsToUpdate.length > 0) {
        // åªè™•ç†æ›´æ–°ï¼Œä¸åˆªé™¤ç¼ºé™·è¨˜éŒ„
        
        // ä¿å­˜æ›´æ–°å¾Œçš„ç¼ºé™·æ•¸æ“š
        if (typeof saveDataToStorage === 'function') {
            saveDataToStorage();
        }
        
        // 2. é‡æ–°åˆ†é…ç¼ºé™·ç·¨è™Ÿï¼ˆå¾ç¬¬ä¸€å€‹åˆ°æœ€å¾Œä¸€å€‹ï¼ŒæŒ‰é †åºç·¨è™Ÿï¼‰
        if (defectsToRemove.length > 0) {
            window.logger.log('Reassigning defect numbers...');
            window.defectEntries.forEach((defect, index) => {
                const newDefectNo = index + 1;
                const oldDefectNo = defect.defectNo;
                
                if (String(oldDefectNo) !== String(newDefectNo)) {
                    window.logger.log(`Reassigning defect ${oldDefectNo} to ${newDefectNo}`);
                    
                    // æ›´æ–°ç¼ºé™·è¨˜éŒ„çš„ç·¨è™Ÿ
                    defect.defectNo = newDefectNo;
                    
                    // åŒæ™‚æ›´æ–° submittedDefectEntries ä¸­çš„è¨˜éŒ„
                    const submittedIndex = window.submittedDefectEntries.findIndex(entry => 
                        String(entry.defectNo) === String(oldDefectNo)
                    );
                    
                    if (submittedIndex >= 0) {
                        window.submittedDefectEntries[submittedIndex].defectNo = newDefectNo;
                    }
                    
                    // æ›´æ–°æ¨“å±¤å¹³é¢åœ–ä¸­çš„ç¼ºé™·æ¨™è¨˜ç·¨è™Ÿ
                    if (window.defectMarks && window.defectMarks.length > 0) {
                        const defectMarkIndex = window.defectMarks.findIndex(mark => 
                            String(mark.defectNo) === String(oldDefectNo)
                        );
                        
                        if (defectMarkIndex >= 0) {
                            window.defectMarks[defectMarkIndex].defectNo = newDefectNo;
                            window.logger.log(`Updated defect mark ${oldDefectNo} to ${newDefectNo} in floor plan`);
                        }
                    }
                    
                    // æ³¨æ„ï¼šæ¨™ç±¤ç·¨è™Ÿä¸æ‡‰è©²è¢«è‡ªå‹•é‡æ–°ç·¨è™Ÿ
                    // æ¨™ç±¤çš„ inspectionNo æ‡‰è©²ä¿æŒç”¨æˆ¶è¨­å®šçš„å€¼
                    // åªæ›´æ–° label.j ä¸­çš„ç¼ºé™·ç·¨è™Ÿï¼Œä¸æ”¹è®Š inspectionNo
                    if (window.labels && window.labels.length > 0) {
                        window.labels.forEach(label => {
                            // æ³¨æ„ï¼šä¸æ›´æ–° label.defectNoï¼Œå› ç‚ºé€™æœƒå½±éŸ¿æ¨™ç±¤ç·¨è™Ÿ
                            // æ¨™ç±¤çš„ inspectionNo æ‡‰è©²ä¿æŒç”¨æˆ¶è¨­å®šçš„å€¼
                            
                            // åªæ›´æ–° label.j ä¸­çš„ç¼ºé™·ç·¨è™Ÿ
                            if (label.j) {
                                const defectsArray = label.j.split('\n').filter(d => d.trim());
                                const updatedDefects = defectsArray.map(defectText => {
                                    const defectNoMatch = defectText.match(/^(\d+)\)?\s*(.*)$/);
                                    if (defectNoMatch && String(defectNoMatch[1]) === String(oldDefectNo)) {
                                        return `${newDefectNo}) ${defectNoMatch[2]}`;
                                    }
                                    return defectText;
                                });
                                label.j = updatedDefects.join('\n');
                            }
                        });
                        
                        // ä¿å­˜æ¨™ç±¤æ•¸æ“š
        if (typeof window.saveLabelsToStorage === 'function') {
            window.saveLabelsToStorage();
        }
                    }
                }
            });
            
            // é‡æ–°ä¿å­˜æ•¸æ“š
            if (typeof saveDataToStorage === 'function') {
                saveDataToStorage();
            }
            
            if (typeof saveDefectMarksToStorage === 'function') {
                saveDefectMarksToStorage();
            }
        }
        
        // 3. æ›´æ–°æ¨“å±¤å¹³é¢åœ–å®¹å™¨çš„ç¼ºé™·æ¨™è¨˜å’Œæ¨™ç±¤è©³ç´°è¡¨æ ¼å®¹å™¨çš„ç¼ºé™·è¨˜éŒ„
        if (defectsToRemove.length > 0) {
            // é‡æ–°æ¸²æŸ“ç¼ºé™·æ¨™è¨˜
            if (typeof window.redrawDefectMarks === 'function') {
                window.redrawDefectMarks();
            }
            
            // ç§»é™¤æ¨™ç±¤é‡æ–°æ¸²æŸ“ - æ ¹æ“šç”¨æˆ¶è¦æ±‚ï¼Œæ›´æ–°æ¨™ç±¤è©³ç´°è¡¨æ ¼æ™‚ä¸æ”¹è®Šæ¨“å±¤å¹³é¢åœ–ä¸­çš„æ¨™ç±¤
            // if (typeof window.redrawLabels === 'function') {
            //     window.redrawLabels();
            // }
            
            // åŒæ­¥æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼
            if (typeof window.syncLabelsToInspectionRecords === 'function') {
                window.syncLabelsToInspectionRecords();
            }
        }
        
        // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼
        if (typeof window.updateDefectSummaryTable === 'function') {
            window.updateDefectSummaryTable();
        }
        
        window.logger.log(`Sync completed: ${defectsToUpdate.length} defects updated, ${defectsToRemove.length} defects removed`);
    }
}

// æ ¼å¼åŒ–ç…§ç‰‡ç·¨è™Ÿå­—ç¬¦ä¸²ï¼Œå°‡é€£çºŒçš„ç·¨è™Ÿåˆä½µç‚ºç¯„åœæ ¼å¼
function formatPhotoNumbersString(photoNumbers) {
    if (!photoNumbers || photoNumbers.length === 0) {
        return '';
    }
    
    // å°‡å­—ç¬¦ä¸²è½‰æ›ç‚ºæ•¸å­—ä¸¦æ’åº
    const numbers = photoNumbers.map(num => parseInt(num)).filter(num => !isNaN(num)).sort((a, b) => a - b);
    
    if (numbers.length === 0) {
        return '';
    }
    
    const ranges = [];
    let start = numbers[0];
    let end = numbers[0];
    
    for (let i = 1; i < numbers.length; i++) {
        if (numbers[i] === end + 1) {
            // é€£çºŒçš„æ•¸å­—ï¼Œæ“´å±•ç¯„åœ
            end = numbers[i];
        } else {
            // ä¸é€£çºŒï¼Œä¿å­˜ç•¶å‰ç¯„åœä¸¦é–‹å§‹æ–°ç¯„åœ
            if (start === end) {
                ranges.push(start.toString());
            } else {
                ranges.push(`${start}-${end}`);
            }
            start = numbers[i];
            end = numbers[i];
        }
    }
    
    // æ·»åŠ æœ€å¾Œä¸€å€‹ç¯„åœ
    if (start === end) {
        ranges.push(start.toString());
    } else {
        ranges.push(`${start}-${end}`);
    }
    
    return ranges.join(', ');
}

// æ¸…é™¤æ‰€æœ‰æ¨™ç±¤è©³ç´°è¡¨æ ¼è¨˜éŒ„çš„å‡½æ•¸ - æŒ‰ç…§æŒ‡å®šé †åºåŸ·è¡Œ
function clearAllLabelsDetailTableRecords() {
    window.logger.log('Starting comprehensive clear all labels detail table records process');
    
    if (window.labels.length === 0) {
        showNotification('No labels to clear.', 'info');
        return;
    }
    
    // ç¢ºèªåˆªé™¤
    if (!confirm('Are you sure you want to clear all labels? This action will delete all defect items first, then update all tables and floor plan, and finally delete all label records. This action cannot be undone.')) {
        return;
    }
    
    window.logger.log('Step 1: Collecting all defect numbers from labels');
    
    // Step 1: æ”¶é›†æ‰€æœ‰æ¨™ç±¤ä¸­çš„ç¼ºé™·ç·¨è™Ÿ
    const allDefectNumbers = new Set();
    window.labels.forEach(label => {
        if (label.defectNo) {
            allDefectNumbers.add(label.defectNo);
        }
    });
    
    window.logger.log('Found defect numbers to delete:', Array.from(allDefectNumbers));
    
    // Step 2: é¦–å…ˆåˆªé™¤æ‰€æœ‰ç¼ºé™·é …ç›®
    window.logger.log('Step 2: Deleting all defect items first');
    allDefectNumbers.forEach(defectNo => {
        // ä½¿ç”¨çµ±ä¸€çš„ç¼ºé™·è¨˜éŒ„åˆªé™¤å‡½æ•¸
        deleteDefectRecordComprehensive(defectNo, 'labels detail table clear all');
    });
    
    // Step 3: æ›´æ–°æ‰€æœ‰ç¼ºé™·è©³ç´°è¡¨æ ¼å®¹å™¨å’Œæ¨“å±¤å¹³é¢åœ–å…§å®¹
    window.logger.log('Step 3: Updating all defects detail-table-container and floor-plan-content');
    
    // æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼
    if (typeof window.updateDefectSummaryTable === 'function') {
        window.updateDefectSummaryTable();
        window.logger.log('Defect summary table updated');
    }
    
    // æ›´æ–°åˆ†é¡è¡¨æ ¼
    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
        window.updateCategoryTablesFromInspectionRecords();
        window.logger.log('Category tables updated');
    }
    
    // æ›´æ–°æ¨“å±¤å¹³é¢åœ–å…§å®¹
    if (typeof window.redrawDefectMarks === 'function') {
        window.redrawDefectMarks();
        window.logger.log('Floor plan defect marks redrawn');
    }
    
    if (typeof window.redrawLabels === 'function') {
        window.redrawLabels();
        window.logger.log('Floor plan labels redrawn');
    }
    
    // æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼
    if (typeof window.syncLabelsToInspectionRecords === 'function') {
        window.syncLabelsToInspectionRecords();
        window.logger.log('Inspection records table updated');
    }
    
    // æ›´æ–°ç…§ç‰‡ç‹€æ…‹
    if (typeof updatePhotoStatusFromLabels === 'function') {
        updatePhotoStatusFromLabels();
        window.logger.log('Photo status updated');
    }
    
    // Step 4: æœ€å¾Œåˆªé™¤æ‰€æœ‰æ¨™ç±¤è©³ç´°è¡¨æ ¼å®¹å™¨çš„è¨˜éŒ„
    window.logger.log('Step 4: Deleting all labels detail-table-container records');
    
    // æ¸…ç©ºæ¨™ç±¤æ•¸çµ„
    window.labels = [];
    
    // ä¿å­˜æ¨™ç±¤åˆ°æœ¬åœ°å­˜å„²
    if (typeof window.saveLabelsToStorage === 'function') {
        window.saveLabelsToStorage();
        window.logger.log('Labels saved to storage');
    }
    
    // é‡æ–°æ¸²æŸ“æ¨™ç±¤ï¼ˆæ¸…ç©ºç‹€æ…‹ï¼‰
    if (typeof window.redrawLabels === 'function') {
        window.redrawLabels();
        window.logger.log('Labels redrawn (empty state)');
    }
    
    // æœ€çµ‚æ›´æ–°æ‰€æœ‰è¡¨æ ¼
    if (typeof window.updateDefectSummaryTable === 'function') {
        window.updateDefectSummaryTable();
        window.logger.log('Final defect summary table update');
    }
    
    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
        window.updateCategoryTablesFromInspectionRecords();
        window.logger.log('Final category tables update');
    }
    
    // åŒæ­¥æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼
    if (typeof window.syncLabelsToInspectionRecords === 'function') {
        window.syncLabelsToInspectionRecords();
        window.logger.log('Final inspection records table update');
    }
    
    window.logger.log('Comprehensive clear all labels detail table records process completed');
    showNotification('All labels cleared successfully! All defect items deleted first, then all tables and floor plan updated, and finally all label records deleted.', 'success');
}

// çµ±ä¸€çš„ç¼ºé™·è¨˜éŒ„åˆªé™¤å‡½æ•¸ - è™•ç†é›™å‘åŒæ­¥åˆªé™¤
function deleteDefectRecordComprehensive(defectNo, source = 'unknown') {
    window.logger.log(`Comprehensive deletion of defect ${defectNo} from source: ${source}`);
    
    if (!defectNo) {
        window.logger.error('No defect number provided for deletion');
        return;
    }
    
    const defectNoStr = String(defectNo);
    let deletedFrom = [];
    
    // é¦–å…ˆæ‰¾åˆ°è¦åˆªé™¤çš„ç¼ºé™·è¨˜éŒ„ï¼Œç²å–å…¶ç…§ç‰‡ç·¨è™Ÿå’Œåˆ†é¡ä¿¡æ¯ï¼ˆåœ¨åˆªé™¤ä¹‹å‰ï¼‰
    let deletedDefectPhotoNumbers = [];
    let deletedDefectCategory = null;
    
    const defectEntryToDelete = window.defectEntries.find(entry => 
        String(entry.defectNo) === defectNoStr
    );
    
    if (defectEntryToDelete) {
        // æ”¹é€²ç…§ç‰‡ç·¨è™Ÿè§£æï¼Œæ”¯æŒç¯„åœæ ¼å¼ï¼ˆå¦‚ 1234-1236ï¼‰
        if (defectEntryToDelete.photoNumbers) {
            const photoNumbersStr = defectEntryToDelete.photoNumbers;
            const photoNumbers = [];
            
            // åˆ†å‰²ç…§ç‰‡ç·¨è™Ÿå­—ç¬¦ä¸²
            const parts = photoNumbersStr.split(/[,\-]/).map(num => num.trim()).filter(num => num);
            
            parts.forEach(part => {
                // æª¢æŸ¥æ˜¯å¦ç‚ºç¯„åœæ ¼å¼ï¼ˆå¦‚ 1234-1236ï¼‰
                if (part.includes('-')) {
                    const rangeParts = part.split('-');
                    if (rangeParts.length === 2) {
                        const start = parseInt(rangeParts[0].trim());
                        const end = parseInt(rangeParts[1].trim());
                        if (!isNaN(start) && !isNaN(end) && start <= end) {
                            // ç”Ÿæˆç¯„åœå…§çš„æ‰€æœ‰ç…§ç‰‡ç·¨è™Ÿ
                            for (let i = start; i <= end; i++) {
                                photoNumbers.push(i.toString());
                            }
                        }
                    }
                } else {
                    // å–®å€‹ç…§ç‰‡ç·¨è™Ÿ
                    photoNumbers.push(part);
                }
            });
            
            deletedDefectPhotoNumbers = photoNumbers;
        } else {
            deletedDefectPhotoNumbers = [];
        }
        
        deletedDefectCategory = defectEntryToDelete.category;
        window.logger.log(`Found defect ${defectNo} with photo numbers: ${deletedDefectPhotoNumbers.join(', ')} and category: ${deletedDefectCategory}`);
    }
    
    // 1. å¾ç¼ºé™·è©³ç´°è¡¨æ ¼ä¸­åˆªé™¤
    const defectIndex = window.defectEntries.findIndex(entry => 
        String(entry.defectNo) === defectNoStr
    );
    
    if (defectIndex >= 0) {
        window.defectEntries.splice(defectIndex, 1);
        deletedFrom.push('defects detail table');
        window.logger.log(`Deleted defect ${defectNo} from defects detail table`);
    }
    
    // 2. å¾æäº¤çš„ç¼ºé™·æ¢ç›®ä¸­åˆªé™¤
    const submittedIndex = window.submittedDefectEntries.findIndex(entry => 
        String(entry.defectNo) === defectNoStr
    );
    
    if (submittedIndex >= 0) {
        window.submittedDefectEntries.splice(submittedIndex, 1);
        deletedFrom.push('submitted defects');
        window.logger.log(`Deleted defect ${defectNo} from submitted defects`);
    }
    
    // 3. å¾æ¨™ç±¤è©³ç´°è¡¨æ ¼ä¸­åˆªé™¤ï¼ˆåŸºæ–¼ç¼ºé™·ç·¨è™Ÿï¼‰ä¸¦æ›´æ–°åˆ†é¡æ¬„ä½ä¸­çš„ç…§ç‰‡ç·¨è™Ÿ
    if (window.labels && window.labels.length > 0) {
        const labelsToUpdate = [];
        const labelsToDelete = [];
        
        // ä½¿ç”¨ä¹‹å‰ç²å–çš„ç¼ºé™·ä¿¡æ¯
        
        window.labels.forEach((label, labelIndex) => {
            let needsUpdate = false;
            let shouldDeleteLabel = false;
            
            // æª¢æŸ¥æ¨™ç±¤çš„ defectNo å­—æ®µ
            if (label.defectNo && String(label.defectNo) === defectNoStr) {
                // æ¨™è¨˜ç‚ºéœ€è¦åˆªé™¤æ•´å€‹æ¨™ç±¤ï¼Œä½†ä¸ç«‹å³åˆªé™¤
                shouldDeleteLabel = true;
                deletedFrom.push('labels detail table (defectNo field)');
                window.logger.log(`Marked label with defectNo ${defectNo} for deletion from labels detail table`);
            }
            
            // åªæœ‰åœ¨ä¸åˆªé™¤æ•´å€‹æ¨™ç±¤çš„æƒ…æ³ä¸‹ï¼Œæ‰æª¢æŸ¥å’Œæ›´æ–°ç¼ºé™·åˆ—
            if (!shouldDeleteLabel && label.j && label.j.includes(defectNoStr)) {
                const defectsArray = label.j.split('\n').filter(d => d.trim());
                const updatedDefects = defectsArray.filter(defectText => {
                    const defectNoMatch = defectText.match(/^(\d+)\)?\s*/);
                    return !defectNoMatch || defectNoMatch[1] !== defectNoStr;
                });
                
                if (updatedDefects.length !== defectsArray.length) {
                    label.j = updatedDefects.join('\n');
                    deletedFrom.push('labels detail table (defects column)');
                    window.logger.log(`Removed defect ${defectNo} from label ${label.inspectionNo} defects column`);
                    needsUpdate = true;
                }
            }
            
            // æ›´æ–°åˆ†é¡æ¬„ä½ä¸­çš„ç…§ç‰‡ç·¨è™Ÿï¼ˆç§»é™¤è¢«åˆªé™¤ç¼ºé™·çš„ç…§ç‰‡ç·¨è™Ÿï¼‰
            // åªæœ‰åœ¨ä¸åˆªé™¤æ•´å€‹æ¨™ç±¤çš„æƒ…æ³ä¸‹ï¼Œæ‰æ›´æ–°åˆ†é¡æ¬„ä½
            if (!shouldDeleteLabel && deletedDefectPhotoNumbers.length > 0 && deletedDefectCategory) {
                const categoryKey = deletedDefectCategory.toLowerCase();
                if (label[categoryKey] && label[categoryKey] !== 'N/A') {
                    // è§£æåˆ†é¡æ¬„ä½ä¸­çš„ç…§ç‰‡ç·¨è™Ÿï¼Œæ”¯æŒç¯„åœæ ¼å¼
                    const currentPhotoNumbersStr = label[categoryKey];
                    const currentPhotoNumbers = [];
                    
                    // åˆ†å‰²ç…§ç‰‡ç·¨è™Ÿå­—ç¬¦ä¸²
                    const parts = currentPhotoNumbersStr.split(/[,\-]/).map(num => num.trim()).filter(num => num);
                    
                    parts.forEach(part => {
                        // æª¢æŸ¥æ˜¯å¦ç‚ºç¯„åœæ ¼å¼ï¼ˆå¦‚ 1234-1236ï¼‰
                        if (part.includes('-')) {
                            const rangeParts = part.split('-');
                            if (rangeParts.length === 2) {
                                const start = parseInt(rangeParts[0].trim());
                                const end = parseInt(rangeParts[1].trim());
                                if (!isNaN(start) && !isNaN(end) && start <= end) {
                                    // ç”Ÿæˆç¯„åœå…§çš„æ‰€æœ‰ç…§ç‰‡ç·¨è™Ÿ
                                    for (let i = start; i <= end; i++) {
                                        currentPhotoNumbers.push(i.toString());
                                    }
                                }
                            }
                        } else {
                            // å–®å€‹ç…§ç‰‡ç·¨è™Ÿ
                            currentPhotoNumbers.push(part);
                        }
                    });
                    
                    // ç§»é™¤è¢«åˆªé™¤ç¼ºé™·çš„ç…§ç‰‡ç·¨è™Ÿ
                    const updatedPhotoNumbers = currentPhotoNumbers.filter(photoNum => 
                        !deletedDefectPhotoNumbers.includes(photoNum)
                    );
                    
                    if (updatedPhotoNumbers.length !== currentPhotoNumbers.length) {
                        // é‡æ–°æ ¼å¼åŒ–ç…§ç‰‡ç·¨è™Ÿå­—ç¬¦ä¸²
                        const formattedPhotoNumbers = formatPhotoNumbersString(updatedPhotoNumbers);
                        label[categoryKey] = formattedPhotoNumbers || 'N/A';
                        deletedFrom.push(`labels detail table (${categoryKey.toUpperCase()} category column)`);
                        window.logger.log(`Removed photo numbers ${deletedDefectPhotoNumbers.join(', ')} from label ${label.inspectionNo} ${categoryKey.toUpperCase()} category`);
                        needsUpdate = true;
                    }
                }
            }
            
            if (shouldDeleteLabel) {
                labelsToDelete.push(labelIndex);
            } else if (needsUpdate) {
                labelsToUpdate.push(labelIndex);
            }
        });
        
        // å…ˆåˆªé™¤éœ€è¦åˆªé™¤çš„æ¨™ç±¤ï¼ˆå¾å¾Œå¾€å‰åˆªé™¤ï¼Œé¿å…ç´¢å¼•å•é¡Œï¼‰
        labelsToDelete.sort((a, b) => b - a).forEach(index => {
            window.labels.splice(index, 1);
            window.logger.log(`Deleted label at index ${index} from labels array`);
        });
        
        // ä¿å­˜æ›´æ–°å¾Œçš„æ¨™ç±¤æ•¸æ“š
        if ((labelsToUpdate.length > 0 || labelsToDelete.length > 0) && typeof window.saveLabelsToStorage === 'function') {
            window.saveLabelsToStorage();
        }
    }
    
    // 4. å¾æ¨“å±¤å¹³é¢åœ–ä¸­åˆªé™¤ç¼ºé™·æ¨™è¨˜
    if (window.defectMarks && window.defectMarks.length > 0) {
        const defectMarkIndex = window.defectMarks.findIndex(mark => 
            String(mark.defectNo) === defectNoStr
        );
        
        if (defectMarkIndex >= 0) {
            window.defectMarks.splice(defectMarkIndex, 1);
            deletedFrom.push('floor plan content');
            window.logger.log(`Deleted defect mark ${defectNo} from floor plan`);
            
            // ä¿å­˜ç¼ºé™·æ¨™è¨˜åˆ°æœ¬åœ°å­˜å„²
            if (typeof saveDefectMarksToStorage === 'function') {
                saveDefectMarksToStorage();
            }
            
            // é‡æ–°æ¸²æŸ“ç¼ºé™·æ¨™è¨˜
            if (typeof window.redrawDefectMarks === 'function') {
                window.redrawDefectMarks();
            }
        }
    }
    
    // 5. å¾æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼ä¸­åˆªé™¤
    if (window.submittedData && window.submittedData.length > 0) {
        window.submittedData.forEach(record => {
            if (record.j && record.j !== 'N/A') {
                const defects = record.j.split('\n');
                const updatedDefects = defects.filter(defect => {
                    const defectNoMatch = defect.match(/^(\*?\s*)(\d+)\)?\s*(.+)$/);
                    return !defectNoMatch || defectNoMatch[2] !== defectNoStr;
                });
                
                if (updatedDefects.length !== defects.length) {
                    record.j = updatedDefects.length > 0 ? updatedDefects.join('\n') : 'N/A';
                    deletedFrom.push('inspection records table');
                    window.logger.log(`Removed defect ${defectNo} from inspection record ${record.locationId}`);
                }
            }
        });
    }
    
    // 6. æ›´æ–°ç¼ºé™·æ‘˜è¦è¡¨æ ¼
    if (typeof window.updateDefectSummaryTable === 'function') {
        window.updateDefectSummaryTable();
        deletedFrom.push('defect summary table');
        window.logger.log('Defect summary table updated after deletion');
    }
    
    // 7. æ›´æ–°ç¼ºé™·åˆ†é¡å…§å®¹é¡¯ç¤º
    updateCategoryDisplay('j');
    
    // 8. é‡æ–°æ’åˆ—ç¼ºé™·ç·¨è™Ÿ - ä½†ä¸åœ¨å¾ labels detail table åˆªé™¤æ™‚èª¿ç”¨
    // å› ç‚ºæ¨™ç±¤åˆªé™¤æœƒå°è‡´æª¢æŸ¥ç·¨è™Ÿé—œè¯é—œä¿‚ä¸Ÿå¤±
    if (source !== 'labels detail table') {
        renumberDefectEntries();
    } else {
        window.logger.log('Skipping renumberDefectEntries for labels detail table deletion - will be handled by caller');
    }
    
    // 9. ä¿å­˜æ‰€æœ‰æ•¸æ“šåˆ°æœ¬åœ°å­˜å„²
    saveDataToStorage();
    
    // 10. é‡æ–°æ¸²æŸ“æ¨™ç±¤ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    if (typeof window.redrawLabels === 'function') {
        window.redrawLabels();
    }
    
    // 11. åŒæ­¥æ›´æ–°æª¢æŸ¥è¨˜éŒ„è¡¨æ ¼
    if (typeof window.syncLabelsToInspectionRecords === 'function') {
        window.syncLabelsToInspectionRecords();
    }
    
    // 12. åŒæ­¥æ›´æ–°åˆ†é¡è¡¨æ ¼
    if (typeof window.updateCategoryTablesFromInspectionRecords === 'function') {
        window.updateCategoryTablesFromInspectionRecords();
    }
    
    // 13. æ›´æ–°ç…§ç‰‡ç‹€æ…‹
    if (typeof updatePhotoStatusFromLabels === 'function') {
        updatePhotoStatusFromLabels();
    }
    
    // 14. å¦‚æœä¾†æºæ˜¯ labels detail tableï¼Œä¸é‡æ–°é¡¯ç¤ºæ¨™ç±¤è©³ç´°è¡¨æ ¼ï¼ˆç”±èª¿ç”¨è€…è™•ç†ï¼‰
    // è¨»é‡‹æ‰ä»¥é¿å…é‡è¤‡é¡¯ç¤º
    // if (source === 'labels detail table' && typeof window.showLabelsDetailPopup === 'function') {
    //     window.showLabelsDetailPopup();
    // }
    
    window.logger.log(`Comprehensive deletion completed for defect ${defectNo}. Deleted from: ${deletedFrom.join(', ')}`);
    
    // å¦‚æœä¾†æºæ˜¯ labels detail tableï¼Œä¸é¡¯ç¤ºé€šçŸ¥ï¼ˆç”±èª¿ç”¨è€…è™•ç†ï¼‰
    if (source !== 'labels detail table') {
        showNotification(`ç¼ºé™·è¨˜éŒ„ ${defectNo} å·²å¾æ‰€æœ‰ç›¸é—œä½ç½®åˆªé™¤`, 'success');
    }
}

// å¾ç¼ºé™·è©³ç´°è¡¨æ ¼ä¸­æŸ¥æ‰¾å°æ‡‰æª¢æŸ¥è™Ÿç¢¼çš„ç¼ºé™·æ•¸æ“š
function getDefectsFromDefectsDetailTable(inspectionNo) {
    window.logger.log('Looking up defects for inspection:', inspectionNo);
    
    if (!window.defectEntries || !inspectionNo) {
        window.logger.log('No defect entries or inspection number provided');
        return '';
    }
    
    // æŸ¥æ‰¾å±¬æ–¼è©²æª¢æŸ¥è™Ÿç¢¼çš„ç¼ºé™·è¨˜éŒ„
    const defectsForInspection = window.defectEntries.filter(defect => 
        String(defect.locationId) === String(inspectionNo) ||
        String(defect.inspectionNo) === String(inspectionNo)
    );
    
    if (defectsForInspection.length === 0) {
        window.logger.log('No defects found for inspection:', inspectionNo);
        return '';
    }
    
    // æŒ‰ç¼ºé™·ç·¨è™Ÿæ’åº
    const sortedDefects = defectsForInspection.sort((a, b) => {
        const defectNoA = parseInt(a.defectNo) || 0;
        const defectNoB = parseInt(b.defectNo) || 0;
        return defectNoA - defectNoB;
    });
    
    // æ ¼å¼åŒ–ç¼ºé™·æ•¸æ“šç‚ºå­—ç¬¦ä¸²
    const defectsText = sortedDefects.map(defect => {
        const defectNo = defect.defectNo || '';
        const range = defect.range || '';
        const description = defect.description || defect.defectType || '';
        
        // æ ¼å¼: "ç·¨è™Ÿ) ç¯„åœ_æè¿°"
        return `${defectNo}) ${range}_${description}`;
    }).join('\n');
    
    window.logger.log(`Found ${defectsForInspection.length} defects for inspection ${inspectionNo}:`, defectsText);
    
    return defectsText;
}

// é©—è­‰ç…§ç‰‡èˆ‡æ¨™ç±¤çš„åˆ†é…é—œä¿‚æ˜¯å¦æ­£ç¢º
function validatePhotoLabelAssignment(filename, label) {
    // æª¢æŸ¥ç…§ç‰‡æ˜¯å¦çœŸçš„å±¬æ–¼é€™å€‹æ¨™ç±¤
    // åªæª¢æŸ¥ç…§ç‰‡ç·¨è™Ÿæ˜¯å¦åœ¨æ¨™ç±¤çš„ä»»ä½•åˆ†é¡æ¬„ä½ä¸­ï¼Œä¸æª¢æŸ¥ photoFilenames
    // å› ç‚º photoFilenames å¯èƒ½åŒ…å«åˆä½µçš„æ­·å²ç…§ç‰‡
    const photoNumber = filename.match(/\d+/);
    if (!photoNumber) return false;
    
    const photoNum = photoNumber[0];
    
    // æª¢æŸ¥æ‰€æœ‰åˆ†é¡æ¬„ä½
    for (const category of categories) {
        const categoryKey = category.id;
        if (label[categoryKey] && label[categoryKey] !== 'N/A') {
            const parts = label[categoryKey].split(/[,\-]/).map(num => num.trim()).filter(num => num);
            
            for (const part of parts) {
                if (part.includes('-')) {
                    // ç¯„åœæ ¼å¼
                    const rangeParts = part.split('-');
                    if (rangeParts.length === 2) {
                        const start = parseInt(rangeParts[0].trim());
                        const end = parseInt(rangeParts[1].trim());
                        if (!isNaN(start) && !isNaN(end) && start <= end) {
                            const photoNumInt = parseInt(photoNum);
                            if (photoNumInt >= start && photoNumInt <= end) {
                                return true;
                            }
                        }
                    }
                } else {
                    // å–®å€‹ç·¨è™Ÿ
                    if (part === photoNum) {
                        return true;
                    }
                }
            }
        }
    }
    
    // ä¸å†æª¢æŸ¥ photoFilenamesï¼Œå› ç‚ºå®ƒå¯èƒ½åŒ…å«åˆä½µçš„æ­·å²ç…§ç‰‡
    // åªåŸºæ–¼åˆ†é¡æ¬„ä½ä¸­çš„å¯¦éš›åˆ†é…ä¾†é©—è­‰
    
    return false;
}

// é©—è­‰ç…§ç‰‡èˆ‡æ¨™ç±¤åˆ†é¡çš„åˆ†é…é—œä¿‚æ˜¯å¦æ­£ç¢º
function validatePhotoCategoryAssignment(filename, label, categoryKey) {
    // æª¢æŸ¥ç…§ç‰‡æ˜¯å¦çœŸçš„å±¬æ–¼é€™å€‹æ¨™ç±¤çš„é€™å€‹åˆ†é¡
    const photoNumber = filename.match(/\d+/);
    if (!photoNumber) return false;
    
    const photoNum = photoNumber[0];
    
    if (label[categoryKey] && label[categoryKey] !== 'N/A') {
        const parts = label[categoryKey].split(/[,\-]/).map(num => num.trim()).filter(num => num);
        
        for (const part of parts) {
            if (part.includes('-')) {
                // ç¯„åœæ ¼å¼
                const rangeParts = part.split('-');
                if (rangeParts.length === 2) {
                    const start = parseInt(rangeParts[0].trim());
                    const end = parseInt(rangeParts[1].trim());
                    if (!isNaN(start) && !isNaN(end) && start <= end) {
                        const photoNumInt = parseInt(photoNum);
                        if (photoNumInt >= start && photoNumInt <= end) {
                            return true;
                        }
                    }
                }
            } else {
                // å–®å€‹ç·¨è™Ÿ
                if (part === photoNum) {
                    return true;
                }
            }
        }
    }
    
    return false;
}

// æ¸…ç†æ¨™ç±¤åˆªé™¤æ™‚çš„ç…§ç‰‡åˆ†é…è¨˜éŒ„
function cleanupPhotoAssignmentsOnLabelDelete(deletedLabel) {
    window.logger.log('Cleaning up photo assignments for deleted label:', deletedLabel.inspectionNo);
    
    // æ¸…ç† assignedPhotos ä¸­èˆ‡è©²æ¨™ç±¤ç›¸é—œçš„ç…§ç‰‡
    categories.forEach(category => {
        if (assignedPhotos[category.id]) {
            const photosToRemove = [];
            assignedPhotos[category.id].forEach(filename => {
                // æª¢æŸ¥ç…§ç‰‡æ˜¯å¦å±¬æ–¼è¢«åˆªé™¤çš„æ¨™ç±¤
                if (validatePhotoLabelAssignment(filename, deletedLabel)) {
                    photosToRemove.push(filename);
                }
            });
            
            photosToRemove.forEach(filename => {
                assignedPhotos[category.id].delete(filename);
                window.logger.log(`Removed photo ${filename} from category ${category.id} assignments`);
            });
        }
    });
    
    // æ¸…ç† categoryNumbers ä¸­èˆ‡è©²æ¨™ç±¤ç›¸é—œçš„ç·¨è™Ÿ
    categories.forEach(category => {
        const categoryKey = category.id;
        if (deletedLabel[categoryKey] && deletedLabel[categoryKey] !== 'N/A') {
            // è§£æè¢«åˆªé™¤æ¨™ç±¤ä¸­çš„ç…§ç‰‡ç·¨è™Ÿ
            const parts = deletedLabel[categoryKey].split(/[,\-]/).map(num => num.trim()).filter(num => num);
            const photoNumbersToRemove = [];
            
            parts.forEach(part => {
                if (part.includes('-')) {
                    const rangeParts = part.split('-');
                    if (rangeParts.length === 2) {
                        const start = parseInt(rangeParts[0].trim());
                        const end = parseInt(rangeParts[1].trim());
                        if (!isNaN(start) && !isNaN(end) && start <= end) {
                            for (let i = start; i <= end; i++) {
                                photoNumbersToRemove.push(i.toString());
                            }
                        }
                    }
                } else {
                    photoNumbersToRemove.push(part);
                }
            });
            
            // å¾ categoryNumbers ä¸­ç§»é™¤é€™äº›ç·¨è™Ÿ
            photoNumbersToRemove.forEach(photoNum => {
                const index = categoryNumbers[categoryKey].indexOf(photoNum);
                if (index > -1) {
                    categoryNumbers[categoryKey].splice(index, 1);
                    window.logger.log(`Removed photo number ${photoNum} from category ${categoryKey}`);
                }
            });
        }
    });
    
    // æ›´æ–°åˆ†é¡é¡¯ç¤º
    categories.forEach(category => {
        updateCategoryDisplay(category.id);
    });
    
    window.logger.log('Photo assignments cleanup completed for label:', deletedLabel.inspectionNo);
}

// åŒæ­¥å‡½æ•¸ï¼šå¾ defects detail-table åŒæ­¥åˆ° labels detail-tableï¼ˆè™•ç†æ›´æ–°æƒ…æ³ï¼‰
function syncDefectsToLabelsDetailTable() {
    window.logger.log('Syncing defects to labels detail table (update case)');
    
    if (!window.defectEntries || !window.labels) {
        window.logger.log('No defects or labels data available');
        return;
    }
    
    // æ›´æ–°æ¯å€‹æ¨™ç±¤çš„ç¼ºé™·åˆ—ï¼Œå¾ç¼ºé™·è©³ç´°è¡¨æ ¼ä¸­æŸ¥æ‰¾æ•¸æ“š
    window.labels.forEach((label, labelIndex) => {
        const inspectionNo = label.inspectionNo;
        const defectsFromTable = getDefectsFromDefectsDetailTable(inspectionNo);
        
        // æ›´æ–°æ¨™ç±¤çš„ç¼ºé™·åˆ—
        if (label.j !== defectsFromTable) {
            window.logger.log(`Updating label ${inspectionNo} defects column from defects table`);
            label.j = defectsFromTable;
        }
    });
    
    // ä¿å­˜æ›´æ–°å¾Œçš„æ¨™ç±¤æ•¸æ“š
    if (typeof window.saveLabelsToStorage === 'function') {
        window.saveLabelsToStorage();
    }
}

// é¡¯ç¤ºæª¢æŸ¥è©³ç´°è¦–çª—ï¼ˆè—è‰²æ¨™ç±¤é›™æ“Šæ™‚ï¼‰
function showInspectionDetailsWindow(labelData) {
    // è‹¥å·²æœ‰é–‹å•Ÿä¸­çš„è¦–çª—ï¼Œå…ˆå¿½ç•¥
    if (document.getElementById('inspectionDetailsOverlay')) return;
    
    // ğŸ” èª¿è©¦ï¼šæª¢æŸ¥æ•¸æ“šæ˜¯å¦å­˜åœ¨
    console.log('ğŸ” showInspectionDetailsWindow called');
    console.log('ğŸ” window.defectEntries:', window.defectEntries);
    console.log('ğŸ” window.submittedDefectEntries:', window.submittedDefectEntries);
    console.log('ğŸ” Type check:', {
        defectEntriesType: typeof window.defectEntries,
        defectEntriesIsArray: Array.isArray(window.defectEntries),
        submittedDefectEntriesType: typeof window.submittedDefectEntries,
        submittedDefectEntriesIsArray: Array.isArray(window.submittedDefectEntries)
    });
    
    // å»ºç«‹è¦†è“‹å±¤
    const overlay = document.createElement('div');
    overlay.id = 'inspectionDetailsOverlay';
    overlay.className = 'inspection-details-overlay';
    overlay.style.cssText = `
        position: fixed; inset: 0; background: rgba(0,0,0,0.6);
        display: flex; align-items: center; justify-content: center;
        z-index: 6000; padding: 20px; box-sizing: border-box;
    `;
    document.body.appendChild(overlay);
    
    // å»ºç«‹è¦–çª—å®¹å™¨
    const modalWindow = document.createElement('div');
    modalWindow.className = 'inspection-details-window';
    modalWindow.style.cssText = `
        background: white; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        max-width: 90vw; max-height: 90vh; width: 800px; height: 600px;
        display: flex; flex-direction: column; overflow: hidden;
    `;
    overlay.appendChild(modalWindow);
    
    // å»ºç«‹æ¨™é¡Œåˆ—
    const header = document.createElement('div');
    header.id = 'inspectionDetailsHeader';
    header.className = 'inspection-details-header';
    header.style.cssText = `
        padding: 16px 20px; border-bottom: 1px solid #eee;
        display: flex; justify-content: space-between; align-items: center;
        background: #f8f9fa;
    `;
    header.innerHTML = `
        <h3 id="inspectionDetailsTitle" style="margin: 0; color: #333; font-size: 1.2em;">
            <i class="fas fa-clipboard-list" style="margin-right: 8px; color: #007bff;"></i>
            Inspection Details - ${labelData.inspectionNo || 'Unknown'}
        </h3>
        <div style="display: flex; gap: 12px; align-items: center;">
            <button id="addMorePhotosBtn" class="inspection-details-add-btn" style="
                background: #28a745; color: white; border: none; border-radius: 6px;
                padding: 8px 16px; cursor: pointer; font-size: 14px; font-weight: 500;
                display: flex; align-items: center; gap: 6px; transition: all 0.3s ease;
            ">
                <i class="fas fa-plus-circle"></i>
                Add More Photos
            </button>
            <button id="closeInspectionDetails" class="inspection-details-close-btn" style="
                background: #dc3545; color: white; border: none; border-radius: 6px;
                padding: 8px 12px; cursor: pointer; font-size: 14px;
            ">Close</button>
        </div>
    `;
    modalWindow.appendChild(header);
    
    // å»ºç«‹å…§å®¹å€åŸŸ
    const content = document.createElement('div');
    content.id = 'inspectionDetailsContent';
    content.className = 'inspection-details-content';
    content.style.cssText = `
        flex: 1; padding: 20px; overflow-y: auto;
        display: flex; flex-direction: column; gap: 20px;
    `;
    modalWindow.appendChild(content);
    
    // å»ºç«‹æ¨™ç±¤è³‡è¨Šå€å¡Š
    const infoSection = document.createElement('div');
    infoSection.id = 'inspectionDetailsInfoSection';
    infoSection.className = 'inspection-details-info-section';
    infoSection.style.cssText = `
        background: #f8f9fa; padding: 16px; border-radius: 8px;
        border-left: 4px solid #007bff;
    `;
    infoSection.innerHTML = `
        <h4 id="inspectionDetailsInfoTitle" style="margin: 0 0 12px 0; color: #333;">Label Information</h4>
        <div id="inspectionDetailsInfoGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
            <div class="info-item">
                <strong>Inspection No:</strong> <span id="inspectionDetailsInspectionNo">${labelData.inspectionNo || 'N/A'}</span>
            </div>
            <div class="info-item">
                <strong>Floor:</strong> <span id="inspectionDetailsFloor">${labelData.floor || 'N/A'}</span>
            </div>
            <div class="info-item">
                <strong>Area Name:</strong> <span id="inspectionDetailsAreaName">${labelData.areaName || 'N/A'}</span>
            </div>
            <div class="info-item">
                <strong>Room No:</strong> <span id="inspectionDetailsRoomNo">${labelData.roomNo || 'N/A'}</span>
            </div>
            <div class="info-item">
                <strong>Inspection Date:</strong> <span id="inspectionDetailsInspectionDate">${labelData.inspectionDate || 'N/A'}</span>
            </div>
            <div class="info-item">
                <strong>Status:</strong> <span id="inspectionDetailsStatus" style="color: #007bff; font-weight: bold;">Submitted</span>
            </div>
        </div>
    `;
    content.appendChild(infoSection);
    
    // å»ºç«‹ç¼ºé™·é …ç›®å€å¡Š
    const defectsSection = document.createElement('div');
    defectsSection.id = 'inspectionDetailsDefectsSection';
    defectsSection.className = 'inspection-details-defects-section';
    defectsSection.style.cssText = `
        background: #fff8f0; padding: 16px; border-radius: 8px;
        border-left: 4px solid #ff6b6b;
    `;
    
    // é¡åˆ¥åç¨±æ˜ å°„
    const categoryNameMap = {
        'a': 'Exposed structural metalwork',
        'b': 'Structural elements',
        'c': 'External building elements',
        'd': 'Suspended objects',
        'e': 'High level internal finishes',
        'f': 'Heavy metal gates/doors',
        'g': 'Window and glass louvers',
        'h': 'Drainage and Plumbing systems',
        'i': 'Fire safety elements',
        'j': 'Defects'
    };
    
    // è§£æç¼ºé™·é …ç›® (Category J)
    const defectString = labelData.j || '';
    const defectItems = defectString ? defectString.split('\n').filter(item => item.trim()) : [];
    
    if (defectItems.length > 0) {
        let defectsHTML = `
            <h4 id="inspectionDetailsDefectsTitle" style="margin: 0 0 12px 0; color: #333;">
                <i class="fas fa-exclamation-triangle" style="margin-right: 8px; color: #ff6b6b;"></i>
                Defect Items (Category J)
            </h4>
            <div id="inspectionDetailsDefectsGrid" style="display: grid; gap: 12px;">
        `;
        
        defectItems.forEach((defectItem, index) => {
            // è§£æç¼ºé™·é …ç›®æ ¼å¼ï¼šdefectNo) photoNumbers_defectType
            // ä¾‹å¦‚ï¼š1) 3708,3709_Water seepage around cable tray
            // æˆ–å¸¶æ˜Ÿè™Ÿçš„ï¼š* 1) 3708,3709_Water seepage around cable tray
            const match = defectItem.match(/^\*?\s*(\d+)\)\s*([0-9,\-\s]+)_(.+)$/);
            
            if (match) {
                const defectNo = match[1];
                const photoNumbersStr = match[2];
                const defectType = match[3];
                
                // å¾ allPhotos ä¸­å°‹æ‰¾å°æ‡‰çš„ç…§ç‰‡
                const photoNumbers = photoNumbersStr.split(/[,\-]/).map(n => n.trim()).filter(n => n);
                const photos = allPhotos.filter(photo => {
                    const photoNum = photo.name.match(/\d+/);
                    return photoNum && photoNumbers.includes(photoNum[0]);
                });
                
                // å¾ All Defects Detail Table (window.defectEntries æˆ– window.submittedDefectEntries) ä¸­æŸ¥æ‰¾å°æ‡‰çš„ç¼ºé™·é¡åˆ¥
                console.log(`ğŸ” Looking for defect - defectNo: ${defectNo}, inspectionNo: ${labelData.inspectionNo}`);
                
                // å„ªå…ˆä½¿ç”¨ window.defectEntriesï¼Œå¦‚æœä¸å­˜åœ¨å‰‡ä½¿ç”¨ window.submittedDefectEntries ä½œç‚ºå‚™ç”¨
                const defectEntriesSource = window.defectEntries || window.submittedDefectEntries;
                
                console.log(`ğŸ” Defect entries source:`, {
                    usingDefectEntries: !!window.defectEntries,
                    usingSubmittedDefectEntries: !window.defectEntries && !!window.submittedDefectEntries,
                    totalEntries: defectEntriesSource ? defectEntriesSource.length : 0
                });
                
                if (defectEntriesSource && defectEntriesSource.length > 0) {
                    console.log(`ğŸ” Sample defectEntry structure:`, defectEntriesSource[0]);
                }
                
                const defectEntry = defectEntriesSource && defectEntriesSource.find(entry => {
                    // åŒ¹é… defectNo å’Œ inspectionNo ç¢ºä¿æ‰¾åˆ°æ­£ç¢ºçš„ç¼ºé™·
                    const matchDefectNo = String(entry.defectNo) === String(defectNo);
                    const matchInspectionNo = String(entry.locationId) === String(labelData.inspectionNo) || 
                                            String(entry.inspectionNo) === String(labelData.inspectionNo);
                    
                    console.log(`ğŸ” Checking entry - defectNo: ${entry.defectNo}, locationId: ${entry.locationId}, inspectionNo: ${entry.inspectionNo}, matchDefectNo: ${matchDefectNo}, matchInspectionNo: ${matchInspectionNo}`);
                    
                    return matchDefectNo && matchInspectionNo;
                });
                
                // å¦‚æœæ‰¾ä¸åˆ°ç¼ºé™·æ¢ç›®ï¼Œè¨˜éŒ„è©³ç´°è­¦å‘Š
                if (!defectEntry) {
                    console.warn(`âš ï¸ Defect entry not found for defectNo: ${defectNo}, inspectionNo: ${labelData.inspectionNo}`);
                    console.warn(`âš ï¸ Available defect entries:`, defectEntriesSource);
                } else {
                    console.log(`âœ… Found defect entry:`, defectEntry);
                }
                
                // å¾ defectEntry ç²å–é¡åˆ¥å’Œ Imminent Danger ç‹€æ…‹ï¼ˆAll Defects Detail Table ä¸­çš„ç¼ºé™·å¿…å®šæœ‰é¡åˆ¥ï¼‰
                const defectCategoryKey = defectEntry && defectEntry.category ? defectEntry.category.toLowerCase() : null;
                const defectCategoryName = defectCategoryKey ? categoryNameMap[defectCategoryKey] : null;
                const defectCategoryLabel = (defectCategoryKey && defectCategoryName) 
                    ? (defectCategoryKey.toUpperCase() + ': ' + defectCategoryName) 
                    : null;
                
                // ç²å– Imminent Danger ç‹€æ…‹
                const imminentDanger = defectEntry && defectEntry.imminentDanger ? true : false;
                const imminentDangerText = imminentDanger ? 'Yes' : 'No';
                const imminentDangerColor = imminentDanger ? '#dc3545' : '#28a745';
                
                defectsHTML += `
                    <div id="inspectionDetailsDefectItem${index}" class="defect-item-card" style="
                        background: white; padding: 12px; border-radius: 6px;
                        border: 1px solid #ffe0d9; display: flex; flex-direction: column; gap: 12px;
                    ">
                        <div class="defect-info" style="width: 100%;">
                            <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px; font-size: 0.9rem;">
                                <strong>Defect No:</strong>
                                <span>${defectNo}</span>
                                
                                <strong>Imminent Danger:</strong>
                                <span style="font-weight: 600; color: ${imminentDangerColor};">${imminentDangerText}</span>
                                
                                ${defectCategoryLabel ? `
                                <strong>Category:</strong>
                                <span>${defectCategoryLabel}</span>
                                ` : ''}
                                
                                <strong>Type:</strong>
                                <span>${defectType}</span>
                                
                                <strong>Photos:</strong>
                                <span>${photoNumbers.join(', ')}</span>
                            </div>
                        </div>
                        <div class="defect-photo-thumbnail" style="width: 100%; display: flex; flex-wrap: wrap; gap: 8px;">
                            ${photos.length > 0 ? photos.map(photo => {
                                const photoNum = photo.name.match(/\d+/);
                                const photoNumber = photoNum ? photoNum[0] : '';
                                return `
                 <div class="photo-item inspection-details-photo-item" 
                      ondblclick="(async function(event) {
                         try {
                             await showPhotoPreviewPopup({name: '${photo.name}', dataURL: '${photo.dataURL || photo.src}'}, event.currentTarget);
                         } catch(err) { console.error(err); }
                      }).call(this, event)">
                                    <img src="${photo.dataURL || photo.src}" alt="Defect ${defectNo}">
                                    <div class="photo-number">${photoNumber}</div>
                                </div>
                            `;}).join('') : `
                                <div class="photo-item inspection-details-photo-item" style="opacity: 0.5;">
                                    <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #f0f0f0;">
                                        <i class="fas fa-image" style="font-size: 24px; color: #999;"></i>
                                    </div>
                                </div>
                            `}
                        </div>
                    </div>
                `;
            } else {
                // å¦‚æœæ ¼å¼ä¸åŒ¹é…ï¼Œé¡¯ç¤ºåŸå§‹æ–‡æœ¬
                defectsHTML += `
                    <div id="inspectionDetailsDefectItem${index}" class="defect-item-card" style="
                        background: white; padding: 12px; border-radius: 6px;
                        border: 1px solid #ffe0d9;
                    ">
                        <p style="margin: 0; font-size: 0.9rem;">${defectItem}</p>
                    </div>
                `;
            }
        });
        
        defectsHTML += `</div>`;
        defectsSection.innerHTML = defectsHTML;
        content.appendChild(defectsSection);
    }
    
    // å»ºç«‹ç…§ç‰‡åˆ†é¡å€å¡Š
    const photosSection = document.createElement('div');
    photosSection.id = 'inspectionDetailsPhotosSection';
    photosSection.className = 'inspection-details-photos-section';
    photosSection.style.cssText = `
        background: rgba(255,255,255,0.35);
        border-radius: var(--border-radius);
        padding: 15px;
        box-shadow: 0 3px 10px rgba(0,0,0,0.12);
        backdrop-filter: blur(12px) saturate(160%);
        -webkit-backdrop-filter: blur(12px) saturate(160%);
        border: 1px solid #e0e0e0;
        display: flex;
        flex-direction: column;
        flex: 1;
        transition: var(--transition);
        position: relative;
    `;
    photosSection.innerHTML = `
        <div id="inspectionDetailsPhotosHeader" class="preview-header" style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
            <h4 id="inspectionDetailsPhotosTitle" class="preview-title" style="margin: 0; color: #333; font-size: 1.2rem;">
                <i class="fas fa-images" style="margin-right: 8px;"></i>
                Submitted Photos by Category
            </h4>
        </div>
    `;
    content.appendChild(photosSection);
    
    // ç²å–å·²æäº¤çš„ç…§ç‰‡ä¸¦æŒ‰åˆ†é¡åˆ†çµ„
    const submittedPhotos = getSubmittedPhotosByCategory(labelData);
    
    if (submittedPhotos.length === 0) {
        const emptyDiv = document.createElement('div');
        emptyDiv.id = 'inspectionDetailsEmptyState';
        emptyDiv.className = 'inspection-details-empty-state';
        emptyDiv.style.cssText = `
            text-align: center; padding: 40px; color: #666;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            flex: 1;
        `;
        emptyDiv.innerHTML = `
            <i class="fas fa-image" style="font-size: 48px; margin-bottom: 16px; opacity: 0.3;"></i>
            <p id="inspectionDetailsEmptyMessage">No submitted photos found for this inspection.</p>
        `;
        photosSection.appendChild(emptyDiv);
    } else {
        // æŒ‰åˆ†é¡åˆ†çµ„é¡¯ç¤ºç…§ç‰‡
        const categories = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
        const categoryNames = {
            'A': 'A: å¤–éœ²çµæ§‹é‡‘å±¬ä»¶',
            'B': 'B: çµæ§‹å…ƒç´ ', 
            'C': 'C: å¤–éƒ¨å»ºç¯‰å…ƒç´ ',
            'D': 'D: æ‡¸æ›ç‰©ä»¶',
            'E': 'E: é«˜å±¤å…§éƒ¨è£ä¿®',
            'F': 'F: é‡å‹é‡‘å±¬é–€/é–˜é–€',
            'G': 'G: çª—æˆ¶å’Œç»ç’ƒç™¾è‘‰',
            'H': 'H: æ’æ°´å’Œç®¡é“ç³»çµ±',
            'I': 'I: æ¶ˆé˜²å®‰å…¨å…ƒç´ ',
            'J': 'J: ç¼ºé™·'
        };
        
        categories.forEach(category => {
            // Skip Category J (Defects) as it's shown in the defects section below
            if (category === 'J') {
                return;
            }
            
            const categoryPhotos = submittedPhotos.filter(photo => 
                photo.category === category || photo.category === category.toLowerCase()
            );
            
            // å°ç…§ç‰‡é€²è¡Œæ’åºï¼ˆæŒ‰æª”åä¸­çš„æ•¸å­—é †åºï¼‰
            categoryPhotos.sort((a, b) => {
                const numA = a.name.match(/\d+/);
                const numB = b.name.match(/\d+/);
                if (numA && numB) {
                    return parseInt(numA[0]) - parseInt(numB[0]);
                }
                return a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'});
            });
            
            if (categoryPhotos.length > 0) {
                const categoryDiv = document.createElement('div');
                categoryDiv.id = `inspectionDetailsCategory${category}`;
                categoryDiv.className = `inspection-details-category-${category.toLowerCase()}`;
                categoryDiv.style.cssText = `
                    margin-bottom: 20px; padding: 15px; 
                    background: rgba(255,255,255,0.2);
                    border-radius: var(--border-radius);
                    border: 1px solid rgba(255,255,255,0.3);
                `;
                
                categoryDiv.innerHTML = `
                    <h5 id="inspectionDetailsCategoryTitle${category}" class="preview-title" style="margin: 0 0 15px 0; color: #333; font-size: 1em; font-weight: 700;">
                        ${categoryNames[category]} (${categoryPhotos.length} photos)
                    </h5>
                    <div id="inspectionDetailsCategoryGrid${category}" class="photo-grid" style="display: grid; grid-template-columns: repeat(5, 120px); gap: 8px; padding: 5px; max-height: 300px; overflow-y: auto;">
                    </div>
                `;
                
                categoryPhotos.forEach((photo, index) => {
                    const photoDiv = document.createElement('div');
                    photoDiv.id = `inspectionDetailsPhoto${category}${index}`;
                    photoDiv.className = `photo-item`;
                    photoDiv.style.cssText = `
                        position: relative; width: 120px; height: 120px;
                        border-radius: 8px; overflow: hidden; cursor: pointer;
                        box-shadow: 0 3px 8px rgba(0,0,0,0.12);
                        transition: all 0.3s ease;
                    `;
                    photoDiv.innerHTML = `
                        <img id="inspectionDetailsPhotoImg${category}${index}" src="${photo.dataURL || photo.src}" alt="${photo.name}" 
                             style="width: 100%; height: 100%; object-fit: cover;
                                    transition: filter 0.3s ease, opacity 0.3s ease;
                                    background-color: #f0f0f0;">
                        <div id="inspectionDetailsPhotoNumber${category}${index}" class="photo-number" style="position: absolute; bottom: 0; left: 0; right: 0;
                                    background: rgba(0,0,0,0.7); color: white; font-size: 0.7rem;
                                    padding: 3px 5px; text-align: center; font-weight: 500; z-index: 2;">
                            ${photo.name.match(/\d+/) ? photo.name.match(/\d+/)[0] : 'N/A'}
                        </div>
                    `;
                    
                    // ç¢ºä¿ç…§ç‰‡ç‰©ä»¶æœ‰æ­£ç¢ºçš„å±¬æ€§ä¾›é è¦½ä½¿ç”¨
                    const photoObject = {
                        name: photo.name,
                        dataURL: photo.dataURL || photo.src,
                        webkitRelativePath: photo.webkitRelativePath || '',
                        size: photo.size || 0,
                        type: photo.type || 'image/jpeg',
                        lastModified: photo.lastModified || Date.now()
                    };
                    
                    // æª¢æŸ¥ä¸¦æ·»åŠ  360 åœ–æ¨™
                    if (typeof add360BadgeToPhoto === 'function') {
                        add360BadgeToPhoto(photoDiv, photo.dataURL || photo.src);
                    }
                    
                    // é›™æ“Šç…§ç‰‡ç¸®åœ–é–‹å•Ÿé è¦½
                    photoDiv.addEventListener('dblclick', async (e) => {
                        e.stopPropagation();
                        try {
                            await showPhotoPreviewPopup(photoObject, photoDiv);
                        } catch (err) {
                            console.error('Failed to open photo preview:', err);
                        }
                    });
                    
                    // æ·»åŠ  hover æ•ˆæœ
                    photoDiv.addEventListener('mouseenter', () => {
                        photoDiv.style.transform = 'translateY(-3px)';
                        photoDiv.style.boxShadow = '0 6px 12px rgba(0,0,0,0.15)';
                    });
                    
                    photoDiv.addEventListener('mouseleave', () => {
                        photoDiv.style.transform = 'translateY(0)';
                        photoDiv.style.boxShadow = '0 3px 8px rgba(0,0,0,0.12)';
                    });
                    
                    // å°‡ç…§ç‰‡æ·»åŠ åˆ°å°æ‡‰çš„ç¶²æ ¼å®¹å™¨ä¸­
                    const gridContainer = categoryDiv.querySelector(`#inspectionDetailsCategoryGrid${category}`);
                    if (gridContainer) {
                        gridContainer.appendChild(photoDiv);
                    }
                });
                
                photosSection.appendChild(categoryDiv);
            }
        });
    }
    
    // Add More Photos æŒ‰éˆ•äº‹ä»¶
    const addMorePhotosBtn = document.getElementById('addMorePhotosBtn');
    addMorePhotosBtn.addEventListener('click', () => {
        // 1. é—œé–‰ç¹ªåœ–æ¨¡å¼
        const floorPlanOverlay = document.getElementById('floorPlanOverlay');
        if (floorPlanOverlay && floorPlanOverlay.style.display !== 'none') {
            // ä½¿ç”¨ z-index æ–¹æ³•é—œé–‰ç¹ªåœ–æ¨¡å¼ï¼Œä¿æŒ DOM ç‹€æ…‹
            floorPlanOverlay.style.zIndex = '-3';
            window.logger.log('Drawing mode closed for Add More Photos');
        }
        
        // 2. å‹¾é¸æ‰€æœ‰ header-field è¤‡é¸æ¡†
        const headerCheckboxes = [
            'locationIdCheck',
            'inspectionDateCheck', 
            'floorHeaderCheck',
            'areaNameHeaderCheck',
            'roomNoCheck'
        ];
        
        headerCheckboxes.forEach(checkboxId => {
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.checked = true;
            }
        });
        
        // 4. å•Ÿç”¨ Submit to Table æŒ‰éˆ•ï¼ˆå› ç‚ºæ‰€æœ‰ checkbox éƒ½å·²å‹¾é¸ï¼‰
        if (typeof checkHeaderCheckboxes === 'function') {
            checkHeaderCheckboxes();
        }
        
        // 3. å¡«å…… header fields çš„æ•¸æ“š
        fillHeaderFieldsFromLabel(labelData);
        
        // é—œé–‰ inspection details window
        overlay.remove();
        
        // é¡¯ç¤ºæç¤ºè¨Šæ¯
        if (typeof showToast === 'function') {
            showToast('Label data loaded. You can now add more photos and defects.', 'success');
        }
        
        // æ»¾å‹•åˆ°ç…§ç‰‡ä¸Šå‚³å€åŸŸ
        const photoUploadSection = document.getElementById('photoUploadSection');
        if (photoUploadSection) {
            photoUploadSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    });
    
    // é—œé–‰æŒ‰éˆ•äº‹ä»¶
    const closeBtn = document.getElementById('closeInspectionDetails');
    closeBtn.addEventListener('click', () => {
        overlay.remove();
    });
    
    // é»æ“Šé®ç½©é—œé–‰
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            overlay.remove();
        }
    });
    
    // Esc éµé—œé–‰
    const onKeyDown = (e) => {
        if (e.key === 'Escape') {
            e.preventDefault();
            overlay.remove();
            document.removeEventListener('keydown', onKeyDown);
        }
    };
    document.addEventListener('keydown', onKeyDown);
    
    // æª¢æŸ¥ä¸¦æ·»åŠ  360 åœ–æ¨™åˆ°æ‰€æœ‰ç…§ç‰‡
    setTimeout(() => {
        if (typeof add360BadgeToPhoto === 'function') {
            // ç‚º Submitted Photos by Category ä¸­çš„ç…§ç‰‡æ·»åŠ åœ–æ¨™
            const categoryPhotoItems = overlay.querySelectorAll('.photo-item');
            categoryPhotoItems.forEach(photoItem => {
                const img = photoItem.querySelector('img');
                if (img && img.src) {
                    add360BadgeToPhoto(photoItem, img.src);
                }
            });
            
            // ç‚º Defects éƒ¨åˆ†çš„ç…§ç‰‡æ·»åŠ åœ–æ¨™
            const defectPhotoItems = overlay.querySelectorAll('.inspection-details-photo-item');
            defectPhotoItems.forEach(photoItem => {
                const img = photoItem.querySelector('img');
                if (img && img.src) {
                    add360BadgeToPhoto(photoItem, img.src);
                }
            });
        }
    }, 300);
}

// åˆä½µç…§ç‰‡ç·¨è™Ÿï¼ˆç”¨æ–¼ç·¨è¼¯æ¨¡å¼ï¼‰
function mergePhotoNumbers(existingNumbers, newNumbers) {
    if (!existingNumbers && !newNumbers) return '';
    if (!existingNumbers) return newNumbers;
    if (!newNumbers) return existingNumbers;
    
    // è§£æç¾æœ‰ç·¨è™Ÿ
    const existing = existingNumbers.split(',').map(n => n.trim()).filter(n => n);
    // è§£ææ–°ç·¨è™Ÿ
    const newNums = newNumbers.split(',').map(n => n.trim()).filter(n => n);
    
    // åˆä½µä¸¦å»é‡
    const merged = [...new Set([...existing, ...newNums])];
    
    // æ’åº
    merged.sort((a, b) => {
        const numA = parseInt(a);
        const numB = parseInt(b);
        return numA - numB;
    });
    
    return merged.join(', ');
}

// åˆä½µç¼ºé™·é …ç›®ï¼ˆç”¨æ–¼ç·¨è¼¯æ¨¡å¼ï¼‰
function mergeDefectItems(existingDefects, newDefects) {
    if (!existingDefects && !newDefects) return '';
    if (!existingDefects) return newDefects;
    if (!newDefects) return existingDefects;
    
    // å°‡ç¾æœ‰ç¼ºé™·æ‹†åˆ†æˆæ•¸çµ„
    const existingItems = existingDefects.split('\n').filter(item => item.trim());
    // å°‡æ–°ç¼ºé™·æ‹†åˆ†æˆæ•¸çµ„
    const newItems = newDefects.split('\n').filter(item => item.trim());
    
    // åˆä½µï¼ˆæ–°çš„ç¼ºé™·æœƒæœ‰æ–°çš„ç·¨è™Ÿï¼Œä¸éœ€è¦å»é‡ï¼‰
    const merged = [...existingItems, ...newItems];
    
    return merged.join('\n');
}

// å¾ label æ•¸æ“šå¡«å…… header fields
function fillHeaderFieldsFromLabel(labelData) {
    console.log('ğŸ”„ Filling header fields from label:', labelData);
    
    // å¡«å…… Inspection No (locationId)
    const locationIdInput = document.getElementById('locationId');
    if (locationIdInput) {
        locationIdInput.value = labelData.inspectionNo || '';
        console.log('âœ“ Location ID filled:', labelData.inspectionNo);
    } else {
        console.warn('âš ï¸ Location ID input not found');
    }
    
    // å¡«å…… Inspection Date
    const inspectionDateInput = document.getElementById('inspectionDate');
    if (inspectionDateInput) {
        inspectionDateInput.value = labelData.inspectionDate || '';
        console.log('âœ“ Inspection Date filled:', labelData.inspectionDate);
    } else {
        console.warn('âš ï¸ Inspection Date input not found');
    }
    
    // å¡«å…… Floor
    const floorInput = document.getElementById('floorHeader');
    if (floorInput) {
        floorInput.value = labelData.floor || '';
        console.log('âœ“ Floor filled:', labelData.floor);
    } else {
        console.warn('âš ï¸ Floor input not found');
    }
    
    // å¡«å…… Area Name
    const areaNameInput = document.getElementById('areaNameHeader');
    if (areaNameInput) {
        areaNameInput.value = labelData.areaName || '';
        console.log('âœ“ Area Name filled:', labelData.areaName);
    } else {
        console.warn('âš ï¸ Area Name input not found');
    }
    
    // å¡«å…… Room No
    const roomNoInput = document.getElementById('roomNo');
    if (roomNoInput) {
        roomNoInput.value = labelData.roomNo || '';
        console.log('âœ“ Room No filled:', labelData.roomNo);
    } else {
        console.warn('âš ï¸ Room No input not found');
    }
    
    // å„²å­˜ç•¶å‰çš„ labelData åˆ°å…¨å±€è®Šé‡ï¼Œç”¨æ–¼å¾ŒçºŒåˆä½µ
    window.currentEditingLabel = {
        ...labelData,
        id: labelData.id,
        isEditMode: true // æ¨™è¨˜ç‚ºç·¨è¼¯æ¨¡å¼
    };
    
    console.log('âœ… Header fields filled successfully');
    console.log('ğŸ“ Current editing label stored:', window.currentEditingLabel);
}

// ç²å–ç‰¹å®šæ¨™ç±¤çš„å·²æäº¤ç…§ç‰‡ä¸¦æŒ‰åˆ†é¡åˆ†çµ„
function getSubmittedPhotosByCategory(labelData) {
    const submittedPhotos = [];
    
    console.log('ğŸ” getSubmittedPhotosByCategory called with labelData:', labelData);
    
    // ç²å–æ‰€æœ‰å·²æäº¤çš„æª¢æŸ¥è¨˜éŒ„
    const allInspectionRecords = window.inspectionRecords || [];
    console.log('ğŸ” Total inspection records:', allInspectionRecords.length);
    
    // æ‰¾åˆ°èˆ‡ç•¶å‰æ¨™ç±¤æª¢æŸ¥ç·¨è™ŸåŒ¹é…çš„è¨˜éŒ„
    const matchingRecords = allInspectionRecords.filter(record => 
        record.locationId === labelData.inspectionNo
    );
    
    console.log('ğŸ” Matching records for inspectionNo', labelData.inspectionNo, ':', matchingRecords.length);
    
    if (matchingRecords.length === 0) {
        console.warn('âš ï¸ No matching inspection records found for:', labelData.inspectionNo);
        return submittedPhotos;
    }
    
    // éæ­·æ‰€æœ‰åŒ¹é…çš„è¨˜éŒ„
    matchingRecords.forEach(record => {
        // æª¢æŸ¥æ¯å€‹åˆ†é¡æ¬„ä½
        const categories = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
        
        categories.forEach(categoryKey => {
            const categoryValue = record[categoryKey];
            if (categoryValue && categoryValue !== 'N/A' && categoryValue.trim() !== '') {
                // è§£æåˆ†é¡å€¼ä¸­çš„ç…§ç‰‡ç·¨è™Ÿ
                const photoNumbers = parsePhotoNumbers(categoryValue);
                
                photoNumbers.forEach(photoNumber => {
                    // åœ¨ allPhotos ä¸­æ‰¾åˆ°å°æ‡‰çš„ç…§ç‰‡
                    const photo = allPhotos.find(p => {
                        const photoNum = p.name.match(/\d+/);
                        return photoNum && photoNum[0] === photoNumber.toString();
                    });
                    
                    if (photo) {
                        // æª¢æŸ¥ç…§ç‰‡æ˜¯å¦å·²ç¶“åœ¨åˆ—è¡¨ä¸­ï¼ˆé¿å…é‡è¤‡ï¼‰
                        const existingPhoto = submittedPhotos.find(p => p.name === photo.name);
                        if (!existingPhoto) {
                            submittedPhotos.push({
                                name: photo.name,
                                dataURL: photo.dataURL,
                                src: photo.dataURL,
                                category: categoryKey.toUpperCase(),
                                webkitRelativePath: photo.webkitRelativePath || '',
                                size: photo.size || 0,
                                type: photo.type || 'image/jpeg',
                                lastModified: photo.lastModified || Date.now()
                            });
                        }
                    }
                });
            }
        });
    });
    
    console.log('ğŸ” Total submitted photos found:', submittedPhotos.length);
    
    return submittedPhotos;
}

// è§£æç…§ç‰‡ç·¨è™Ÿçš„è¼”åŠ©å‡½æ•¸
function parsePhotoNumbers(categoryValue) {
    const photoNumbers = [];
    
    // å…ˆæŒ‰é€—è™Ÿåˆ†å‰²ï¼Œä¿æŒç¯„åœå®Œæ•´
    const parts = categoryValue.split(',').map(part => part.trim()).filter(part => part);
    
    parts.forEach(part => {
        if (part.includes('-')) {
            // ç¯„åœæ ¼å¼ (ä¾‹å¦‚: 1051-1054)
            const rangeParts = part.split('-').map(p => p.trim());
            if (rangeParts.length === 2) {
                const start = parseInt(rangeParts[0]);
                const end = parseInt(rangeParts[1]);
                if (!isNaN(start) && !isNaN(end) && start <= end) {
                    for (let i = start; i <= end; i++) {
                        photoNumbers.push(i);
                    }
                }
            }
        } else {
            // å–®å€‹ç·¨è™Ÿ
            const num = parseInt(part);
            if (!isNaN(num)) {
                photoNumbers.push(num);
            }
        }
    });
    
    return photoNumbers;
}

// ==================== TASK MANAGEMENT FUNCTIONS ====================

// Global flag to track if user has task data
window.hasTaskData = false;

// ==================== START FRESH OVERLAY FUNCTIONS ====================

// Show Start Fresh overlay
function showStartFreshOverlay() {
    const overlay = document.getElementById('startFreshOverlay');
    if (overlay) {
        overlay.style.display = 'flex';
        console.log('ğŸš€ Start Fresh overlay displayed');
    }
}

// Hide Start Fresh overlay
function hideStartFreshOverlay() {
    const overlay = document.getElementById('startFreshOverlay');
    if (overlay) {
        overlay.style.display = 'none';
        console.log('ğŸš€ Start Fresh overlay hidden');
    }
}

// Setup Start Fresh overlay event listeners
function setupStartFreshOverlayListeners() {
    const overlay = document.getElementById('startFreshOverlay');
    const closeBtn = document.getElementById('startFreshCloseBtn');
    const startNewTaskBtn = document.getElementById('startNewTaskBtn');
    const openPneFileBtn = document.getElementById('openPneFileBtn');
    
    // Close button
    if (closeBtn) {
        closeBtn.addEventListener('click', hideStartFreshOverlay);
    }
    
    // Close when clicking outside
    if (overlay) {
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                hideStartFreshOverlay();
            }
        });
    }
    
    // Start New Task button
    if (startNewTaskBtn) {
        startNewTaskBtn.addEventListener('click', () => {
            hideStartFreshOverlay();
            // Show task entries modal
            const taskEntriesModal = document.getElementById('taskEntriesModal');
            if (taskEntriesModal) {
                taskEntriesModal.style.display = 'flex';
                populateCurrentTaskForm();
            }
        });
    }
    
    // Open PNE File button
    if (openPneFileBtn) {
        openPneFileBtn.addEventListener('click', () => {
            hideStartFreshOverlay();
            // Trigger the PNE file open functionality
            const openPneBtn = document.querySelector('.pne-dropdown-item[data-action="open"]');
            if (openPneBtn) {
                openPneBtn.click();
            }
        });
    }
}

// Initialize task management system
async function initializeTaskManagement() {
    console.log('ğŸ”§ Initializing task management system...');
    
    // Load current task from storage
    await loadCurrentTaskFromStorage();
    
    // Setup event listeners
    setupTaskEventListeners();
    
    // Setup Start Fresh overlay event listeners
    setupStartFreshOverlayListeners();
    
    // Update task display
    updateTaskDisplay();
    
    console.log('âœ… Task management system initialized');
}

// Setup task event listeners - Simplified
function setupTaskEventListeners() {
    const taskDisplayBtn = document.getElementById('taskDisplayBtn');
    const taskEntriesModal = document.getElementById('taskEntriesModal');
    const taskEntriesCloseBtn = document.getElementById('taskEntriesCloseBtn');
    const taskCancelBtn = document.getElementById('taskCancelBtn');
    const taskSaveBtn = document.getElementById('taskSaveBtn');
    
    // Task display button click
    if (taskDisplayBtn) {
        taskDisplayBtn.addEventListener('click', () => {
            if (taskEntriesModal) {
                taskEntriesModal.style.display = 'flex';
                populateCurrentTaskForm();
            }
        });
    }
    
    // Close modal buttons
    if (taskEntriesCloseBtn) {
        taskEntriesCloseBtn.addEventListener('click', closeTaskModal);
    }
    
    if (taskCancelBtn) {
        taskCancelBtn.addEventListener('click', closeTaskModal);
    }
    
    // Save task button
    if (taskSaveBtn) {
        taskSaveBtn.addEventListener('click', saveCurrentTask);
    }
    
    // Close modal when clicking outside
    if (taskEntriesModal) {
        taskEntriesModal.addEventListener('click', (e) => {
            if (e.target === taskEntriesModal) {
                closeTaskModal();
            }
        });
    }
}

// Close task modal - Simplified
function closeTaskModal() {
    const taskEntriesModal = document.getElementById('taskEntriesModal');
    if (taskEntriesModal) {
        taskEntriesModal.style.display = 'none';
    }
}

// Populate task form with current task data
function populateCurrentTaskForm() {
    const taskNameInput = document.getElementById('taskName');
    const taskLocationInput = document.getElementById('taskLocation');
    const taskStartDateInput = document.getElementById('taskStartDate');
    const taskTargetDateInput = document.getElementById('taskTargetDate');
    const taskDescriptionInput = document.getElementById('taskDescription');
    
    if (currentTask) {
        if (taskNameInput) taskNameInput.value = currentTask.name || '';
        if (taskLocationInput) taskLocationInput.value = currentTask.location || '';
        if (taskStartDateInput) taskStartDateInput.value = currentTask.startDate || '';
        if (taskTargetDateInput) taskTargetDateInput.value = currentTask.targetDate || '';
        if (taskDescriptionInput) taskDescriptionInput.value = currentTask.description || '';
    } else {
        if (taskNameInput) taskNameInput.value = '';
        if (taskLocationInput) taskLocationInput.value = '';
        if (taskStartDateInput) taskStartDateInput.value = '';
        if (taskTargetDateInput) taskTargetDateInput.value = '';
        if (taskDescriptionInput) taskDescriptionInput.value = '';
    }
}

// Save current task
function saveCurrentTask() {
    const form = document.getElementById('taskFormElement');
    if (!form) return;
    
    const formData = new FormData(form);
    const taskData = {
        name: formData.get('taskName').trim(),
        location: formData.get('taskLocation').trim(),
        startDate: formData.get('taskStartDate'),
        targetDate: formData.get('taskTargetDate'),
        description: formData.get('taskDescription').trim(),
        updatedAt: new Date().toISOString()
    };
    
    // Validate required fields
    if (!taskData.name) {
        showNotification(getText('taskName') + ' is required', 'error');
        return;
    }
    
    // Update current task
    currentTask = taskData;
    
    // Set task data flag
    window.hasTaskData = true;
    
    // Save to storage
    saveCurrentTaskToStorage();
    
    // Update display
    updateTaskDisplay();
    
    // Close modal
    closeTaskModal();
    
    // Show success message
    showNotification(getText('taskSaved'), 'success');
}

// Load current task from storage
async function loadCurrentTaskFromStorage() {
    try {
        const savedData = await window.storageAdapter.getItem('photoNumberExtractorData');
        if (savedData && savedData.currentTask) {
            currentTask = savedData.currentTask;
            window.hasTaskData = true;
            console.log('ğŸ“¥ Loaded current task from storage:', currentTask.name);
            // Update display immediately after loading
            updateTaskDisplay();
        } else {
            window.hasTaskData = false;
        }
    } catch (error) {
        console.error('Error loading current task:', error);
        window.hasTaskData = false;
    }
}

// Save current task to storage
async function saveCurrentTaskToStorage() {
    try {
        const savedData = await window.storageAdapter.getItem('photoNumberExtractorData') || {};
        savedData.currentTask = currentTask;
        await window.storageAdapter.setItem('photoNumberExtractorData', savedData);
    } catch (error) {
        console.error('Error saving current task:', error);
    }
}

// Update task display
function updateTaskDisplay() {
    const taskDisplayText = document.getElementById('taskDisplayText');
    const taskCount = document.getElementById('taskCount');
    
    console.log('ğŸ”„ updateTaskDisplay called:', {
        currentTask: currentTask,
        taskName: currentTask ? currentTask.name : 'none',
        taskDisplayText: taskDisplayText,
        timestamp: new Date().toLocaleTimeString()
    });
    
    if (currentTask && currentTask.name) {
        if (taskDisplayText) {
            taskDisplayText.textContent = currentTask.name;
            console.log('âœ… Task name displayed:', currentTask.name);
        }
        if (taskCount) {
            taskCount.style.display = 'none';
        }
    } else {
        if (taskDisplayText) {
            taskDisplayText.textContent = getText('taskDisplay');
            console.log('ğŸ“ Default task display text shown');
        }
        if (taskCount) {
            taskCount.style.display = 'none';
        }
    }
}

// Show task form
function showTaskForm(task = null) {
    const taskForm = document.getElementById('taskForm');
    const taskListContainer = document.querySelector('.task-list-container');
    
    if (taskForm && taskListContainer) {
        taskForm.style.display = 'block';
        taskListContainer.style.display = 'none';
        
        if (task) {
            // Edit mode
            currentEditingTask = task;
            populateTaskForm(task);
        } else {
            // Add mode
            currentEditingTask = null;
            clearTaskForm();
        }
    }
}

// Hide task form
function hideTaskForm() {
    const taskForm = document.getElementById('taskForm');
    const taskListContainer = document.querySelector('.task-list-container');
    
    if (taskForm && taskListContainer) {
        taskForm.style.display = 'none';
        taskListContainer.style.display = 'block';
    }
}

// Clear task form
function clearTaskForm() {
    const form = document.getElementById('taskFormElement');
    if (form) {
        form.reset();
    }
}

// Populate task form with data
function populateTaskForm(task) {
    if (!task) return;
    document.getElementById('taskName').value = task.name || '';
    document.getElementById('taskLocation').value = task.location || '';
    document.getElementById('taskStartDate').value = task.startDate || '';
    document.getElementById('taskTargetDate').value = task.targetDate || '';
    document.getElementById('taskDescription').value = task.description || '';
}

// Save task
function saveTask() {
    const form = document.getElementById('taskFormElement');
    if (!form) return;
    
    const formData = new FormData(form);
    const taskData = {
        id: currentEditingTask ? currentEditingTask.id : Date.now().toString(),
        name: formData.get('taskName').trim(),
        location: formData.get('taskLocation').trim(),
        startDate: formData.get('taskStartDate'),
        targetDate: formData.get('taskTargetDate'),
        description: formData.get('taskDescription').trim(),
        createdAt: currentEditingTask ? currentEditingTask.createdAt : new Date().toISOString(),
        updatedAt: new Date().toISOString()
    };
    
    // Validate required fields
    if (!taskData.name) {
        showNotification(getText('taskName') + ' is required', 'error');
        return;
    }
    
    if (currentEditingTask) {
        // Update existing task
        const index = tasks.findIndex(t => t.id === currentEditingTask.id);
        if (index !== -1) {
            tasks[index] = taskData;
            showNotification(getText('taskUpdated'), 'success');
        }
    } else {
        // Add new task
        tasks.push(taskData);
        showNotification(getText('taskSaved'), 'success');
    }
    
    // Save to storage
    saveTasksToStorage();
    
    // Update display
    updateTaskList();
    updateTaskDisplay();
    
    // Hide form
    hideTaskForm();
    clearTaskForm();
    currentEditingTask = null;
}

// Delete task
function deleteTask(taskId) {
    if (confirm(getText('confirmDeleteTask'))) {
        const index = tasks.findIndex(t => t.id === taskId);
        if (index !== -1) {
            tasks.splice(index, 1);
            saveTasksToStorage();
            updateTaskList();
            updateTaskDisplay();
            showNotification(getText('taskDeleted'), 'success');
        }
    }
}

// Edit task
function editTask(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (task) {
        showTaskForm(task);
    }
}

// Update task list display
function updateTaskList() {
    const taskList = document.getElementById('taskList');
    if (!taskList) return;
    
    if (tasks.length === 0) {
        taskList.innerHTML = `
            <div class="task-empty-state">
                <i class="fas fa-tasks"></i>
                <h4>${getText('noTasksFound')}</h4>
                <p>${getText('noTasksDescription')}</p>
            </div>
        `;
        return;
    }
    
    taskList.innerHTML = tasks.map(task => `
        <div class="task-item" data-task-id="${task.id}">
            <div class="task-info">
                <div class="task-name">${escapeHtml(task.name)}</div>
                <div class="task-details">
                    ${task.location ? `<div class="task-detail-item"><i class="fas fa-map-marker-alt"></i> ${escapeHtml(task.location)}</div>` : ''}
                    ${task.startDate ? `<div class="task-detail-item"><i class="fas fa-calendar-alt"></i> ${formatDate(task.startDate)}</div>` : ''}
                    ${task.targetDate ? `<div class="task-detail-item"><i class="fas fa-flag-checkered"></i> ${formatDate(task.targetDate)}</div>` : ''}
                </div>
            </div>
            <div class="task-actions">
                <button class="task-action-btn edit" onclick="editTask('${task.id}')" title="${getText('editTask')}">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="task-action-btn delete" onclick="deleteTask('${task.id}')" title="${getText('deleteTask')}">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        </div>
    `).join('');
}

// Update task display button
function updateTaskDisplay() {
    const taskDisplayText = document.getElementById('taskDisplayText');
    const taskCount = document.getElementById('taskCount');
    
    if (currentTask && currentTask.name) {
        if (taskDisplayText) {
            taskDisplayText.textContent = currentTask.name;
        }
        if (taskCount) {
            taskCount.style.display = 'none';
        }
    } else {
        if (taskDisplayText) {
            taskDisplayText.textContent = getText('taskDisplay');
        }
        if (taskCount) {
            taskCount.style.display = 'none';
        }
    }
}

// Load tasks from storage
async function loadTasksFromStorage() {
    try {
        const savedTasks = await window.storageAdapter.getItem('pne_tasks');
        if (savedTasks && Array.isArray(savedTasks)) {
            tasks = savedTasks;
            console.log(`ğŸ“¥ Loaded ${tasks.length} tasks from storage`);
        }
    } catch (error) {
        console.error('Error loading tasks from storage:', error);
    }
}

// Save tasks to storage
async function saveTasksToStorage() {
    try {
        await window.storageAdapter.setItem('pne_tasks', tasks);
        console.log(`ğŸ’¾ Saved ${tasks.length} tasks to storage`);
    } catch (error) {
        console.error('Error saving tasks to storage:', error);
    }
}

// Utility functions
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function formatDate(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toLocaleDateString();
}

// Export current task for PNE file
function exportCurrentTaskForPNE() {
    return {
        currentTask: currentTask,
        exportDate: new Date().toISOString()
    };
}

// Import current task from PNE file
function importCurrentTaskFromPNE(data) {
    if (data && data.currentTask) {
        currentTask = data.currentTask;
        saveCurrentTaskToStorage();
        updateTaskDisplay();
        console.log(`ğŸ“¥ Imported current task from PNE file: ${currentTask.name}`);
    }
}
